[{"content":"<h2 id=\"-addons\">Addons</h2><p>Ember Addons are installed using NPM (e.g. <code>npm install --save-dev ember-cli-sass</code>). Addons may bring in other dependencies by modifying your project’s <code>bower.json</code> file automatically.</p><p>You can find listings of addons on <a href=\"http://emberobserver.com\">Ember Observer</a>.</p>","link":"./BR/addons-and-dependencies/managing-dependencies.pt-BR.html","spaLink":"#/BR/addons-and-dependencies/managing-dependencies.pt-BR","title":"ADDONS"},{"content":"<h2 id=\"-bower\">Bower</h2><p>Ember CLI uses the <a href=\"http://bower.io\">Bower</a> package manager, making it easy to keep your front-end dependencies up to date. The Bower configuration file, <code>bower.json</code>, is located at the root of your Ember CLI project, and lists the dependencies for your project. Executing <code>bower install</code> will install all of the dependencies listed in <code>bower.json</code> in one step.</p><p>Ember CLI watches <code>bower.json</code> for changes. Thus it reloads your app if you install new dependencies via <code>bower install &lt;dependencies&gt; --save</code>.</p>","link":"./BR/addons-and-dependencies/managing-dependencies.pt-BR.html","spaLink":"#/BR/addons-and-dependencies/managing-dependencies.pt-BR","title":"BOWER"},{"content":"<h2 id=\"-other-assets\">Other assets</h2><p>Assets not available as an addon or Bower package should be placed in the <code>vendor</code> folder in your project.</p>","link":"./BR/addons-and-dependencies/managing-dependencies.pt-BR.html","spaLink":"#/BR/addons-and-dependencies/managing-dependencies.pt-BR","title":"OTHER ASSETS"},{"content":"<h2 id=\"-compiling-assets\">Compiling Assets</h2><p>When you’re using dependencies that are not included in an addon, you will have to instruct Ember CLI to include your assets in the build. This is done using the asset manifest file <code>ember-cli-build.js</code>. You should only try to import assets located in the <code>bower_components</code> and <code>vendor</code> folders.</p>","link":"./BR/addons-and-dependencies/managing-dependencies.pt-BR.html","spaLink":"#/BR/addons-and-dependencies/managing-dependencies.pt-BR","title":"COMPILING ASSETS"},{"content":"<h3 id=\"-compiling-assets-globals-provided-by-javascript-assets\">Globals provided by Javascript assets</h3><p>The globals provided by some assets (like <code>moment</code> in the below example) can be used in your application without the need to <code>import</code> them. Provide the asset path as the first and only argument.</p><p>```ember-cli-build.js app.import(‘bower_components/moment/moment.js’);</p><p>You can now <code>import</code> them in your app. (e.g. <code>import { raw as icAjaxRaw } from 'ic-ajax';</code>)</p>","link":"./BR/addons-and-dependencies/managing-dependencies.pt-BR.html","spaLink":"#/BR/addons-and-dependencies/managing-dependencies.pt-BR","title":"Globals provided by Javascript assets"},{"content":"<h3 id=\"-compiling-assets-environment-specific-assets\">Environment Specific Assets</h3><p>If you need to use different assets in different environments, specify an object as the first parameter. That object’s key should be the environment name, and the value should be the asset to use in that environment.</p><p>```ember-cli-build.js app.import({ development: ‘bower_components/ember/ember.js’, production: ‘bower_components/ember/ember.prod.js’ });</p>","link":"./BR/addons-and-dependencies/managing-dependencies.pt-BR.html","spaLink":"#/BR/addons-and-dependencies/managing-dependencies.pt-BR","title":"Environment Specific Assets"},{"content":"<h3 id=\"-compiling-assets-css\">CSS</h3><p>Provide the asset path as the first argument:</p><p>```ember-cli-build.js app.import(‘bower_components/foundation/css/foundation.css’);</p><p>This example would create the font file in <code>dist/font-awesome/fonts/fontawesome-webfont.ttf</code>.</p><p>You can also optionally tell <code>import()</code> to place the file at a different path. The following example will copy the file to <code>dist/assets/fontawesome-webfont.ttf</code>.</p><p>```ember-cli-build.js app.import(‘bower_components/font-awesome/fonts/fontawesome-webfont.ttf’, { destDir: ‘assets’ });</p>","link":"./BR/addons-and-dependencies/managing-dependencies.pt-BR.html","spaLink":"#/BR/addons-and-dependencies/managing-dependencies.pt-BR","title":"CSS"},{"content":"<h2 id=\"-factory-registrations\">Factory Registrations</h2><p>A factory can represent any part of your application, like a <em>route</em>, <em>template</em>, or custom class. Every factory is registered with a particular key. For example, the index template is registered with the key <code>template:index</code>, and the application route is registered with the key <code>route:application</code>.</p><p>Registration keys have two segments split by a colon (<code>:</code>). The first segment is the framework factory type, and the second is the name of the particular factory. Hence, the <code>index</code> template has the key <code>template:index</code>. Ember has several built-in factory types, such as <code>service</code>, <code>route</code>, <code>template</code>, and <code>component</code>.</p><p>You can create your own factory type by simply registering a factory with the new type. For example, to create a <code>user</code> type, you’d simply register your factory with <code>application.register('user:user-to-register')</code>.</p><p>Factory registrations must be performed either in application or application instance initializers (with the former being much more common).</p><p>For example, an application initializer could register a <code>Logger</code> factory with the key <code>logger:main</code>:</p><p>```app/initializers/logger.js export function initialize(application) { var Logger = Ember.Object.extend({ log(m) { console.log(m); } });</p><p>application.register(‘logger:main’, Logger); }</p><p>export default { name: ‘logger’, initialize: initialize };</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"FACTORY REGISTRATIONS"},{"content":"<h3 id=\"-factory-registrations-registering-singletons-vs-non-singletons\">Registering Singletons vs. Non-Singletons</h3><p>By default, registrations are treated as “singletons”. This simply means that an instance will be created when it is first looked up, and this same instance will be cached and returned from subsequent lookups.</p><p>When you want fresh objects to be created for every lookup, register your factories as non-singletons using the <code>singleton: false</code> option.</p><p>In the following example, the <code>Message</code> class is registered as a non-singleton:</p><p>```app/initializers/notification.js export function initialize(application) { var Message = Ember.Object.extend({ text: ‘’ });</p><p>application.register(‘notification:message’, Message, { singleton: false }); }</p><p>export default { name: ‘notification’, initialize: initialize };</p><p>As a result of this type injection, all factories of the type <code>route</code> will be instantiated with the property <code>logger</code> injected. The value of <code>logger</code> will come from the factory named <code>logger:main</code>.</p><p>Routes in this example application can now access the injected logger:</p><p>```app/routes/index.js export default Ember.Route.extend({ activate() { // The logger property is injected into all routes this.get(‘logger’).log(‘Entered the index route!’); } });</p><p>In this case, the logger will only be injected on the index route.</p><p>Injections can be made onto any class that requires instantiation. This includes all of Ember’s major framework classes, such as components, helpers, routes, and the router.</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"Registering Singletons vs. Non-Singletons"},{"content":"<h3 id=\"-factory-registrations-ad-hoc-injections\">Ad Hoc Injections</h3><p>Dependency injections can also be declared directly on Ember classes using <code>Ember.inject</code>. Currently, <code>Ember.inject</code> supports injecting controllers (via <code>Ember.inject.controller</code>) and services (via <code>Ember.inject.service</code>).</p><p>The following code injects the <code>shopping-cart</code> service on the <code>cart-contents</code> component as the property <code>cart</code>:</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ cart: Ember.inject.service(‘shopping-cart’) });</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"Ad Hoc Injections"},{"content":"<h2 id=\"-factory-instance-lookups\">Factory Instance Lookups</h2><p>To fetch an instantiated factory from the running application you can call the <a href=\"http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup\"><code>lookup</code></a> method on an application instance. This method takes a string to identify a factory and returns the appropriate object.</p><p>The application instance is passed to Ember’s instance initializer hooks and it is added as the “owner” of each object that was instantiated by the application instance.</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"FACTORY INSTANCE LOOKUPS"},{"content":"<h3 id=\"-factory-instance-lookups-using-an-application-instance-within-an-instance-initializer\">Using an Application Instance Within an Instance Initializer</h3><p>Instance initializers receive an application instance as an argument, providing an opportunity to look up an instance of a registered factory.</p><p>```app/instance-initializers/logger.js export function initialize(applicationInstance) { let logger = applicationInstance.lookup(‘logger:main’);</p><p>logger.log(‘Hello from the instance initializer!’); }</p><p>export default { name: ‘logger’, initialize: initialize };</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"Using an Application Instance Within an Instance Initializer"},{"content":"<h2 id=\"-application-initializers\">Application Initializers</h2><p>Application initializers can be created with Ember CLI’s <code>initializer</code> generator:</p><p>Let’s customize the <code>shopping-cart</code> initializer to inject a <code>cart</code> property into all the routes in your application:</p><p>```app/initializers/shopping-cart.js export function initialize(application) { application.inject(‘route’, ‘cart’, ‘service:shopping-cart’); };</p><p>export default { name: ‘shopping-cart’, initialize: initialize };</p><p>Let’s add some simple logging to indicate that the instance has booted:</p><p>```app/instance-initializers/logger.js export function initialize(applicationInstance) { var logger = applicationInstance.lookup(‘logger:main’); logger.log(‘Hello from the instance initializer!’); }</p><p>export default { name: ‘logger’, initialize: initialize };</p><p>```app/initializers/websocket-init.js export function initialize(application) { // … your code … };</p><p>export default { name: ‘websocketInit’, after: ‘configReader’, initialize: initialize }; ```</p><p>Note that ordering only applies to initializers of the same type (i.e. application or application instance). Application initializers will always run before application instance initializers.</p>","link":"./BR/applications/initializers.pt-BR.html","spaLink":"#/BR/applications/initializers.pt-BR","title":"APPLICATION INITIALIZERS"},{"content":"<h2 id=\"-why-is-the-run-loop-useful\">Why is the run loop useful?</h2><p>Very often, batching similar work has benefits. Web browsers do something quite similar by batching changes to the DOM.</p><p>Consider the following HTML snippet:</p><p>and executing the following code:</p><p>In this example, the sequence of code forced the browser to recalculate style, and relayout after each step. However, if we were able to batch similar jobs together, the browser would have only needed to recalculate the style and layout once.</p><p>Interestingly, this pattern holds true for many other types of work. Essentially, batching similar work allows for better pipelining, and further optimization.</p><p>Let’s look at a similar example that is optimized in Ember, starting with a <code>User</code> object:</p><p>and a template to display its attributes:</p><p>If we execute the following code without the run loop:</p><p>We see that the browser will rerender the template twice.</p><p>However, if we have the run loop in the above code, the browser will only rerender the template once the attributes have all been set.</p><p>In the above example with the run loop, since the user’s attributes end up at the same values as before execution, the template will not even rerender!</p><p>It is of course possible to optimize these scenarios on a case-by-case basis, but getting them for free is much nicer. Using the run loop, we can apply these classes of optimizations not only for each scenario, but holistically app-wide.</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"WHY IS THE RUN LOOP USEFUL?"},{"content":"<h2 id=\"-how-does-the-run-loop-work-in-ember\">How does the Run Loop work in Ember?</h2><p>As mentioned earlier, we schedule work (in the form of function invocations) on queues, and these queues are processed to completion in priority order.</p><p>What are the queues, and what is their priority order?</p><p>Because the priority is first to last, the “sync” queue has higher priority than the “render” or “destroy” queue.</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"HOW DOES THE RUN LOOP WORK IN EMBER?"},{"content":"<h2 id=\"-what-happens-in-these-queues\">What happens in these queues?</h2><ul>\n<li>The <code>sync</code> queue contains binding synchronization jobs.</li>\n<li>The <code>actions</code> queue is the general work queue and will typically contain scheduled tasks e.g. promises.</li>\n<li>The <code>routerTransitions</code> queue contains transition jobs in the router.</li>\n<li>The <code>render</code> queue contains jobs meant for rendering, these will typically update the DOM.</li>\n<li>The <code>afterRender</code> queue contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated.</li>\n<li>The <code>destroy</code> queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.</li>\n</ul>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"WHAT HAPPENS IN THESE QUEUES?"},{"content":"<h2 id=\"-in-what-order-are-jobs-executed-on-the-queues\">In what order are jobs executed on the queues?</h2><p>The algorithm works this way:</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"IN WHAT ORDER ARE JOBS EXECUTED ON THE QUEUES?"},{"content":"<h2 id=\"-an-example-of-the-internals\">An example of the internals</h2><p>Rather than writing the higher level app code that internally invokes the various run loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.</p><p>Working with this API directly is not common in most Ember apps, but understanding this example will help you to understand the run-loops algorithm, which will make you a better Ember developer. <iframe src=\"https://s3.amazonaws.com/emberjs.com/run-loop-guide/index.html\" width=\"678\" height=\"410\" style=\"border:1px solid rgb(170, 170, 170);margin-bottom:1.5em;\"></iframe></p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"AN EXAMPLE OF THE INTERNALS"},{"content":"<h2 id=\"-how-do-i-tell-ember-to-start-a-run-loop\">How do I tell Ember to start a run loop?</h2><p>You should begin a run loop when the callback fires.</p><p>The <code>Ember.run</code> method can be used to create a runloop. In this example, jQuery and <code>Ember.run</code> are used to handle a click event and run some Ember code.</p><p>This example uses the <code>=&gt;</code> function syntax, which is a [new ES2015 syntax for callback functions] (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>) that provides a lexical <code>this</code>. If this syntax is new, think of it as a function that has the same <code>this</code> as the context it is defined in.</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"HOW DO I TELL EMBER TO START A RUN LOOP?"},{"content":"<h2 id=\"-what-happens-if-i-forget-to-start-a-run-loop-in-an-async-handler\">What happens if I forget to start a run loop in an async handler?</h2><p>As mentioned above, you should wrap any non-Ember async callbacks in <code>Ember.run</code>. If you don’t, Ember will try to approximate a beginning and end for you. Consider the following callback:</p><p>The runloop API calls that <em>schedule</em> work i.e. <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_schedule\"><code>run.schedule</code></a>, <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce\"><code>run.scheduleOnce</code></a>, <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_once\"><code>run.once</code></a> have the property that they will approximate a runloop for you if one does not already exist. These automatically created runloops we call <em>autoruns</em>.</p><p>Here is some pseudocode to describe what happens using the example above:</p><p>Although autoruns are convenient, they are suboptimal. The current JS frame is allowed to end before the run loop is flushed, which sometimes means the browser will take the opportunity to do other things, like garbage collection. GC running in between data changing and DOM rerendering can cause visual lag and should be minimized.</p><p>Relying on autoruns is not a rigorous or efficient way to use the runloop. Wrapping event handlers manually is preferred.</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"WHAT HAPPENS IF I FORGET TO START A RUN LOOP IN AN ASYNC HANDLER?"},{"content":"<h2 id=\"-how-is-runloop-behaviour-different-when-testing\">How is runloop behaviour different when testing?</h2><p>When your application is in <em>testing mode</em> then Ember will throw an error if you try to schedule work without an available runloop.</p><p>Autoruns are disabled in testing for several reasons:</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"HOW IS RUNLOOP BEHAVIOUR DIFFERENT WHEN TESTING?"},{"content":"<h2 id=\"-where-can-i-find-more-information\">Where can I find more information?</h2><p>Check out the <a href=\"http://emberjs.com/api/classes/Ember.run.html\">Ember.run</a> API documentation, as well as the <a href=\"https://github.com/ebryn/backburner.js/\">Backburner library</a> that powers the run loop.</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"WHERE CAN I FIND MORE INFORMATION?"},{"content":"<h3 id=\"-defining-services\">Defining Services</h3><p>Services can be generated using Ember CLI’s <code>service</code> generator. For example, the following command will create the <code>ShoppingCart</code> service:</p><p>Services must extend the <a href=\"http://emberjs.com/api/classes/Ember.Service.html\"><code>Ember.Service</code></a> base class:</p><p>```app/services/shopping-cart.js export default Ember.Service.extend({ });</p>","link":"./BR/applications/services.pt-BR.html","spaLink":"#/BR/applications/services.pt-BR","title":"Defining Services"},{"content":"<h3 id=\"-accessing-services\">Accessing Services</h3><p>To access a service, you can inject it in any container-resolved object such as a component or another service using the <code>Ember.inject.service</code> function. There are 2 ways to use this function. You can either invoke it with no arguments, or you can pass it the registered name of the service. When no arguments are passed the services is loaded based in the name of the variable key. You can load the shopping cart service with no arguments like below.</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ //will load the service in file /app/services/shopping-cart.js shoppingCart: Ember.inject.service() });</p><p>This injects the shopping cart service into the component and makes it available as the <code>cart</code> property.</p><p>Injected properties are lazy loaded; meaning the service will not be instantiated until the property is explicitly called. Therefore you need to access services in your component using the <code>get</code> function otherwise you might get an undefined.</p><p>Once loaded, a service will persist until the application exits.</p><p>Below we add a remove action to the <code>cart-contents</code> component. Notice that below we access the <code>cart</code> service with a call to<code>this.get</code>.</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ cart: Ember.inject.service(‘shopping-cart’),</p><p>actions: { remove(item) { this.get(‘cart’).remove(item); } } });</p>","link":"./BR/applications/services.pt-BR.html","spaLink":"#/BR/applications/services.pt-BR","title":"Accessing Services"},{"content":"<h3 id=\"-customizing-the-element\">Customizing the Element</h3><p>To use a tag other than <code>div</code>, subclass <code>Ember.Component</code> and assign it a <code>tagName</code> property. This property can be any valid HTML5 tag name as a string.</p><p>```app/components/navigation-bar.js export default Ember.Component.extend({ tagName: ‘nav’ });</p>","link":"./BR/components/customizing-a-components-element.pt-BR.html","spaLink":"#/BR/components/customizing-a-components-element.pt-BR","title":"Customizing the Element"},{"content":"<h3 id=\"-customizing-class-names\">Customizing Class Names</h3><p>You can also specify which class names are applied to the component’s element by setting its <code>classNames</code> property to an array of strings:</p><p>```app/components/navigation-bar.js export default Ember.Component.extend({ classNames: [‘primary’] });</p><p>This component would render the following:</p><p>If <code>isUrgent</code> is changed to <code>false</code>, then the <code>is-urgent</code> class name will be removed.</p><p>By default, the name of the Boolean property is dasherized. You can customize the class name applied by delimiting it with a colon:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isUrgent:urgent’], isUrgent: true });</p><p>Besides the custom class name for the value being <code>true</code>, you can also specify a class name which is used when the value is <code>false</code>:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isEnabled:enabled:disabled’], isEnabled: false });</p><p>You can also specify a class which should only be added when the property is <code>false</code> by declaring <code>classNameBindings</code> like this:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isEnabled::disabled’], isEnabled: false });</p><p>If the <code>isEnabled</code> property is set to <code>true</code>, no class name is added:</p><p>If the bound property’s value is a string, that value will be added as a class name without modification:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘priority’], priority: ‘highestPriority’ });</p>","link":"./BR/components/customizing-a-components-element.pt-BR.html","spaLink":"#/BR/components/customizing-a-components-element.pt-BR","title":"Customizing Class Names"},{"content":"<h3 id=\"-customizing-attributes\">Customizing Attributes</h3><p>You can bind attributes to the DOM element that represents a component by using <code>attributeBindings</code>:</p><p>```app/components/link-item.js export default Ember.Component.extend({ tagName: ‘a’, attributeBindings: [‘href’], href: ‘<a href=\"http://emberjs.com\">http://emberjs.com</a>‘ });</p><p>If the attribute is null, it won’t be rendered:</p><p>```app/components/link-item.js export default Ember.Component.extend({ tagName: ‘span’, title: null, attributeBindings: [‘title’], });</p><p>…and this HTML when a title of “Ember JS” is passed to the component:</p>","link":"./BR/components/customizing-a-components-element.pt-BR.html","spaLink":"#/BR/components/customizing-a-components-element.pt-BR","title":"Customizing Attributes"},{"content":"<h1 id=\"title\">{{title}}</h1><p>{{yield}}</p><p>Edit title: {{input type=”text” value=title}}</p><p></p><p>Its model is populated in <code>model</code> hook in the route handler:</p><p>```app/routes/index.js export default Ember.Route.extend({ model() { return this.store.findAll(‘post’); } });</p><p>```app/templates/components/bar-component.hbs </p>","link":"./BR/components/defining-a-component.pt-BR.html","spaLink":"#/BR/components/defining-a-component.pt-BR","title":"{{TITLE}}"},{"content":"<h3 id=\"title-hello-from-bar\">Hello from bar!</h3><p>When the parameter passed to <code>{{component}}</code> evaluates to <code>null</code> or <code>undefined</code>, the helper renders nothing. When the parameter changes, the currently rendered component is destroyed and the new component is created and brought in.</p><p>Picking different components to render in response to the data allows you to have different template and behavior for each case. The <code>{{component}}</code> helper is a powerful tool for improving code modularity.</p>","link":"./BR/components/defining-a-component.pt-BR.html","spaLink":"#/BR/components/defining-a-component.pt-BR","title":"Hello from bar!"},{"content":"<h2 id=\"-sending-actions\">Sending Actions</h2><p>In some cases your component needs to define event handlers, perhaps to support various draggable behaviors. For example, a component may need to send an <code>id</code> when it receives a drop event:</p><p>You can define the component’s event handlers to manage the drop event. And if you need to, you may also stop events from bubbling, by using <code>return false;</code>.</p><p>```app/components/drop-target.js export default Ember.Component.extend({ attributeBindings: [‘draggable’], draggable: ‘true’,</p><p>dragOver() { return false; },</p><p>drop(event) { let id = event.dataTransfer.getData(‘text/data’); this.sendAction(‘action’, id); } }); ```</p>","link":"./BR/components/handling-events.pt-BR.html","spaLink":"#/BR/components/handling-events.pt-BR","title":"SENDING ACTIONS"},{"content":"<h2 id=\"-event-names\">Event Names</h2><p>The event handling examples described above respond to one set of events. The names of the built-in events are listed below. Custom events can be registered by using <a href=\"http://emberjs.com/api/classes/Ember.Application.html#property_customEvents\">Ember.Application.customEvents</a>.</p><p>Touch events:</p><ul>\n<li><code>touchStart</code></li>\n<li><code>touchMove</code></li>\n<li><code>touchEnd</code></li>\n<li><code>touchCancel</code></li>\n</ul><p>Keyboard events</p><ul>\n<li><code>keyDown</code></li>\n<li><code>keyUp</code></li>\n<li><code>keyPress</code></li>\n</ul><p>Mouse events</p><ul>\n<li><code>mouseDown</code></li>\n<li><code>mouseUp</code></li>\n<li><code>contextMenu</code></li>\n<li><code>click</code></li>\n<li><code>doubleClick</code></li>\n<li><code>mouseMove</code></li>\n<li><code>focusIn</code></li>\n<li><code>focusOut</code></li>\n<li><code>mouseEnter</code></li>\n<li><code>mouseLeave</code></li>\n</ul><p>Form events:</p><ul>\n<li><code>submit</code></li>\n<li><code>change</code></li>\n<li><code>focusIn</code></li>\n<li><code>focusOut</code></li>\n<li><code>input</code></li>\n</ul><p>HTML5 drag and drop events:</p><ul>\n<li><code>dragStart</code></li>\n<li><code>drag</code></li>\n<li><code>dragEnter</code></li>\n<li><code>dragLeave</code></li>\n<li><code>dragOver</code></li>\n<li><code>dragEnd</code></li>\n<li><code>drop</code></li>\n</ul>","link":"./BR/components/handling-events.pt-BR.html","spaLink":"#/BR/components/handling-events.pt-BR","title":"EVENT NAMES"},{"content":"<h1 id=\"title\">{{title}}</h1><p>{{body}}</p><p></p><p>If we tried to use the component like this:</p><p>```app/templates/index.hbs {{#each model as |post|}} {{blog-post}} {{/each}}</p><p>In order to make a property available to a component, you must pass it in like this:</p><p>```app/templates/index.hbs {{#each model as |post|}} {{blog-post title=post.title body=post.body}} {{/each}}</p><p>To set the component up to receive parameters this way, you need set the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams\"><code>positionalParams</code></a> attribute in your component class.</p><p>```app/components/blog-post.js const BlogPostComponent = Ember.Component.extend({});</p><p>BlogPostComponent.reopenClass({ positionalParams: [‘title’, ‘body’] });</p><p>export default BlogPostComponent;</p>","link":"./BR/components/passing-properties-to-a-component.pt-BR.html","spaLink":"#/BR/components/passing-properties-to-a-component.pt-BR","title":"{{TITLE}}"},{"content":"<h2 id=\"-order-of-lifecycle-hooks-called\">Order of Lifecycle Hooks Called</h2><p>Listed below are the component lifecycle hooks in order of execution according to render scenario.</p>","link":"./BR/components/the-component-lifecycle.pt-BR.html","spaLink":"#/BR/components/the-component-lifecycle.pt-BR","title":"ORDER OF LIFECYCLE HOOKS CALLED"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-initial-render\">On Initial Render</h3>","link":"./BR/components/the-component-lifecycle.pt-BR.html","spaLink":"#/BR/components/the-component-lifecycle.pt-BR","title":"On Initial Render"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-re-render\">On Re-Render</h3>","link":"./BR/components/the-component-lifecycle.pt-BR.html","spaLink":"#/BR/components/the-component-lifecycle.pt-BR","title":"On Re-Render"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-component-destroy\">On Component Destroy</h3>","link":"./BR/components/the-component-lifecycle.pt-BR.html","spaLink":"#/BR/components/the-component-lifecycle.pt-BR","title":"On Component Destroy"},{"content":"<h2 id=\"-lifecycle-hook-examples\">Lifecycle Hook Examples</h2><p>Below are some samples of ways to use lifecycle hooks within your components.</p>","link":"./BR/components/the-component-lifecycle.pt-BR.html","spaLink":"#/BR/components/the-component-lifecycle.pt-BR","title":"LIFECYCLE HOOK EXAMPLES"},{"content":"<h3 id=\"-lifecycle-hook-examples-resetting-presentation-state-on-attribute-change-with-didupdateattrs\">Resetting Presentation State on Attribute Change with <code>didUpdateAttrs</code></h3><p><code>didUpdateAttrs</code> runs when the attributes of a component have changed, but not when the component is re-rendered, via <code>component.rerender</code>, <code>component.set</code>, or changes in models or services used by the template.</p><p>A <code>didUpdateAttrs</code> is called prior to rerender, you can use this hook to execute code when specific attributes are changed. This hook can be an effective alternative to an observer, as it will run prior to a re-render, but after an attribute has changed.</p><p>An example of this scenario in action is a profile editor component. As you are editing one user, and the user attribute is changed, you can use <code>didUpdateAttrs</code> to clear any error state that was built up from editing the previous user.</p><p><code>/app/templates/components/profile-editor.hbs</code></p><p><code>/app/components/profile-editor.js</code></p>","link":"./BR/components/the-component-lifecycle.pt-BR.html","spaLink":"#/BR/components/the-component-lifecycle.pt-BR","title":"Resetting Presentation State on Attribute Change with didUpdateAttrs"},{"content":"<h3 id=\"-lifecycle-hook-examples-formatting-component-attributes-with-didreceiveattrs\">Formatting Component Attributes with <code>didReceiveAttrs</code></h3><p><code>didReceiveAttrs</code> runs after <code>init</code>, and it also runs on subsequent re-renders, which is useful for logic that is the same on all renders. It does not run when the re-rendered has been initiated internally.</p><p>Since the <code>didReceiveAttrs</code> hook is called every time a component’s attributes are updated whether on render or re-render, you can use the hook to effectively act as an observer, ensuring code is executed every time an attribute changes.</p><p>For example, if you have a component that renders based on a json configuration, but you want to provide your component with the option of taking the config as a string, you can leverage <code>didReceiveAttrs</code> to ensure the incoming config is always parsed.</p>","link":"./BR/components/the-component-lifecycle.pt-BR.html","spaLink":"#/BR/components/the-component-lifecycle.pt-BR","title":"Formatting Component Attributes with didReceiveAttrs"},{"content":"<h3 id=\"-lifecycle-hook-examples-integrating-with-third-party-libraries-with-didinsertelement\">Integrating with Third-Party Libraries with <code>didInsertElement</code></h3><p>Suppose you want to integrate your favorite date picker library into an Ember project. Typically, 3rd party JS/jQuery libraries require a DOM element to bind to. So, where is the best place to initialize and attach the library?</p><p>After a component successfully renders its backing HTML element into the DOM, it will trigger its <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> hook.</p><p>Ember guarantees that, by the time <code>didInsertElement()</code> is called:</p><p>A component’s <a href=\"http://emberjs.com/api/classes/Ember.Component.html#method__\"><code>$()</code></a> method allows you to access the component’s DOM element by returning a JQuery element. For example, you can set an attribute using jQuery’s <code>attr()</code> method:</p><p><a href=\"http://emberjs.com/api/classes/Ember.Component.html#method__\"><code>$()</code></a> will, by default, return a jQuery object for the component’s root element, but you can also target child elements within the component’s template by passing a selector:</p><p>Let’s initialize our date picker by overriding the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> method.</p><p>Date picker libraries usually attach to an <code>&lt;input&gt;</code> element, so we will use jQuery to find an appropriate input within our component’s template.</p><p><a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> is also a good place to attach event listeners. This is particularly useful for custom events or other browser events which do not have a <a href=\"http://guides.emberjs.com/v2.1.0/components/handling-events/#toc_event-names\">built-in event handler</a>.</p><p>For example, perhaps you have some custom CSS animations trigger when the component is rendered and you want to handle some cleanup when it ends:</p><p>There are a few things to note about the <code>didInsertElement()</code> hook:</p><ul>\n<li>It is only triggered once when the component element is first rendered.</li>\n<li>In cases where you have components nested inside other components, the child component will always receive the <code>didInsertElement()</code> call before its parent does.</li>\n<li>Setting properties on the component in <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> triggers a re-render, and for performance reasons, is not allowed.</li>\n<li>While <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> is technically an event that can be listened for using <a href=\"http://emberjs.com/api/classes/Ember.Component.html#method_on\"><code>on()</code></a>, it is encouraged to override the default method itself, particularly when order of execution is important.</li>\n</ul>","link":"./BR/components/the-component-lifecycle.pt-BR.html","spaLink":"#/BR/components/the-component-lifecycle.pt-BR","title":"Integrating with Third-Party Libraries with didInsertElement"},{"content":"<h3 id=\"-lifecycle-hook-examples-making-updates-to-the-rendered-dom-with-didrender\">Making Updates to the Rendered DOM with <code>didRender</code></h3><p>The <code>didRender</code> hook is called during both render and re-render after the template has rendered and the DOM updated. You can leverage this hook to perform post-processing on the DOM of a component after its been updated.</p><p>In this example, there is a list component that needs to scroll to a selected item when rendered. Since scrolling to a specific spot is based on positions within the DOM, we need to ensure that the list has been rendered before scrolling. We can first render this list, and then set the scroll.</p><p>The component below takes a list of items and displays them on the screen. Additionally, it takes an object representing which item is selected and will select and set the scroll top to that item.</p><p>When rendered the component will iterate through the given list and apply a class to the one that is selected.</p><p><code>/app/templates/components/selected-item-list.hbs</code></p><p>The scroll happens on <code>didRender</code>, where it will scroll the component’s container to the element with the selected class name.</p><p><code>/app/components/selected-item-list.js</code></p>","link":"./BR/components/the-component-lifecycle.pt-BR.html","spaLink":"#/BR/components/the-component-lifecycle.pt-BR","title":"Making Updates to the Rendered DOM with didRender"},{"content":"<h3 id=\"-lifecycle-hook-examples-detaching-and-tearing-down-component-elements-with-willdestroyelement\">Detaching and Tearing Down Component Elements with <code>willDestroyElement</code></h3><p>When a component detects that it is time to remove itself from the DOM, Ember will trigger the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_willDestroyElement\"><code>willDestroyElement()</code></a> method, allowing for any teardown logic to be performed.</p><p>Component teardown can be triggered by a number of different conditions. For instance, the user may navigate to a different route, or a conditional Handlebars block surrounding your component may change:</p><p>Let’s use this hook to cleanup our date picker and event listener from above:</p>","link":"./BR/components/the-component-lifecycle.pt-BR.html","spaLink":"#/BR/components/the-component-lifecycle.pt-BR","title":"Detaching and Tearing Down Component Elements with willDestroyElement"},{"content":"<h2 id=\"-creating-the-component\">Creating the Component</h2><p>Let’s call our component <code>button-with-confirmation</code>. We can create it by typing:</p><p>We’ll plan to use the component in a template something like this:</p><p>```app/templates/components/user-profile.hbs {{button-with-confirmation text=”Click OK to delete your account.”}}</p>","link":"./BR/components/triggering-changes-with-actions.pt-BR.html","spaLink":"#/BR/components/triggering-changes-with-actions.pt-BR","title":"CREATING THE COMPONENT"},{"content":"<h2 id=\"-designing-the-action\">Designing the Action</h2><p>When implementing an action on a component, you need to break it down into two steps:</p><p>Let’s take it step by step.</p>","link":"./BR/components/triggering-changes-with-actions.pt-BR.html","spaLink":"#/BR/components/triggering-changes-with-actions.pt-BR","title":"DESIGNING THE ACTION"},{"content":"<h2 id=\"-implementing-the-action\">Implementing the Action</h2><p>In the parent component, let’s first define what we want to happen when the user clicks the button and then confirms. In this case, we’ll find the user’s account and delete it.</p><p>In Ember, each component can have a property called <code>actions</code>, where you put functions that can be <a href=\"../../templates/actions/\">invoked by the user interacting with the component itself</a>, or by child components.</p><p>Let’s look at the parent component’s JavaScript file. In this example, imagine we have a parent component called <code>user-profile</code> that shows the user’s profile to them.</p><p>We’ll implement an action on the parent component called <code>userDidDeleteAccount()</code> that, when called, gets a hypothetical <code>login</code> <a href=\"../../applications/services/\">service</a> and calls the service’s <code>deleteUser()</code> method.</p><p>```app/components/user-profile.js export default Ember.Component.extend({ login: Ember.inject.service(),</p><p>actions: { userDidDeleteAccount() { this.get(‘login’).deleteUser(); } } });</p><p>The component template will have a button and a div that shows the confirmation dialog based on the value of <code>confirmShown</code>.</p><p>```app/templates/components/button-with-confirmation.hbs <button {{action=\"\" \"launchconfirmdialog\"}}=\"\">{{text}}</button> {{#if confirmShown}} </p><p></p><p></p><p>This snippet says “take the <code>userDidDeleteAccount</code> action from the parent and make it available on the child component as <code>onConfirm</code>.”</p><p>We can do a similar thing for our <code>send-message</code> component:</p><p>```app/templates/components/send-message.hbs {{button-with-confirmation text=”Click to send your message.” onConfirm=(action “sendMessage”)}}</p><p><code>this.get('onConfirm')</code> will return the function passed from the parent as the value of <code>onConfirm</code>, and the following <code>()</code> will invoke the function.</p><p>Like normal attributes, actions can be a property on the component; the only difference is that the property is set to a function that knows how to trigger behavior.</p><p>That makes it easy to remember how to add an action to a component. It’s like passing an attribute, but you use the <code>action</code> helper to pass a function instead.</p><p>Actions in components allow you to decouple an event happening from how it’s handled, leading to modular, more reusable components.</p>","link":"./BR/components/triggering-changes-with-actions.pt-BR.html","spaLink":"#/BR/components/triggering-changes-with-actions.pt-BR","title":"IMPLEMENTING THE ACTION"},{"content":"<h2 id=\"-handling-action-completion\">Handling Action Completion</h2><p>Often actions perform asynchronous tasks, such as making an ajax request to a server. Since actions are functions that can be passed in by a parent component, they are able to return values when called. The most common scenario is for an action to return a promise so that the component can handle the action’s completion.</p><p>In our user <code>button-with-confirmation</code> component we want to leave the confirmation modal open until we know that the operation has completed successfully. This is accomplished by expecting a promise to be returned from <code>onConfirm</code>. Upon resolution of the promise, we set a property used to indicate the visibility of the confirmation modal.</p><p>```app/components/button-with-confirmation.js export default Ember.Component.extend({ actions: { launchConfirmDialog() { this.set(‘confirmShown’, true); },</p><p>} });</p><p>In this case, the code in <code>button-with-confirmation</code> does not change. It will still invoke <code>onConfirm</code> with no arguments. The action helper will add the arguments provided in the template to the call.</p><p>Action arguments curry, meaning that you can provide partial arguments to the action helper and provide the rest of the arguments when you call the function within the component javascript file. For example, our <code>button-with-confirmation</code> component will now <a href=\"../wrapping-content-in-a-component/\">yield</a> the content of the confirmation dialog to collect extra information to be sent along with the <code>onConfirm</code> action:</p><p>```app/templates/components/button-with-confirmation.hbs <button {{action=\"\" \"launchconfirmdialog\"}}=\"\">{{text}}</button> {{#if confirmShown}} </p><p></p><p></p><p>Now when the <code>submitConfirm</code> action is invoked, we call it with the value provided by our yielded input.</p><p>```app/components/button-with-confirmation.js export default Ember.Component.extend({ actions: { launchConfirmDialog() { this.set(“confirmShown”, true); },</p><p>} });</p>","link":"./BR/components/triggering-changes-with-actions.pt-BR.html","spaLink":"#/BR/components/triggering-changes-with-actions.pt-BR","title":"HANDLING ACTION COMPLETION"},{"content":"<h2 id=\"-invoking-actions-directly-on-component-collaborators\">Invoking Actions Directly on Component Collaborators</h2><p>Actions can be invoked on objects other than the component directly from the template. For example, in our <code>send-message</code> component we might include a service that processes the <code>sendMessage</code> logic.</p><p>```app/components/send-message.js export default Ember.Component.extend({ messaging: Ember.inject.service(),</p><p>// component implementation });</p><p>By supplying the <code>target</code> attribute, the action helper will look to invoke the <code>sendMessage</code> action directly on the messaging service, saving us from writing code on the component that just passes the action along to the service.</p><p>```app/services/messaging.js export default Ember.Service.extend({ actions: { sendMessage(messageType, text) { //handle message send and return a promise } } });</p><p>All our <code>system-preferences-editor</code> component really needs to process a user deletion is an account ID. For this case, the action helper provides the <code>value</code> attribute to allow a parent component to dig into the passed object to pull out only what it needs.</p><p>```app/templates/components/system-preferences-editor.hbs {{user-profile didDelete=(action “userDeleted” value=”account.id”)}}</p>","link":"./BR/components/triggering-changes-with-actions.pt-BR.html","spaLink":"#/BR/components/triggering-changes-with-actions.pt-BR","title":"INVOKING ACTIONS DIRECTLY ON COMPONENT COLLABORATORS"},{"content":"<h2 id=\"-calling-actions-up-multiple-component-layers\">Calling Actions Up Multiple Component Layers</h2><p>When your components go multiple template layers deep, its common to need to handle an action several layers up the tree. Using the action helper, it is possible to make actions defined in parent components available at the bottom layers of your component tree without adding JavaScript code to the components in between.</p><p>For example, we want to take account deletion out of the <code>user-profile</code> component and handle deletion in its parent. In our template in <code>user-profile.hbs</code>, we can change our action to call <code>deleteCurrentUser</code>, which will be defined on <code>system-preferences-editor</code>.</p><p>```app/templates/components/user-profile.hbs {{button-with-confirmation onConfirm=(action deleteCurrentUser) text=”Click OK to delete your account.”}}</p><p>Now when you confirm deletion, the action goes straight to the <code>system-preferences-editor</code> to handle.</p><p>```app/components/system-preferences-editor.js import Ember from ‘ember’;</p><p>export default Ember.Component.extend({ login: Ember.inject.service(), actions: { deleteUser(idStr) { return this.get(‘login’).deleteUserAccount(idStr); } } }); ```</p>","link":"./BR/components/triggering-changes-with-actions.pt-BR.html","spaLink":"#/BR/components/triggering-changes-with-actions.pt-BR","title":"CALLING ACTIONS UP MULTIPLE COMPONENT LAYERS"},{"content":"<h1 id=\"title\">{{title}}</h1><p>(See <a href=\"../passing-properties-to-a-component/\">Passing Properties to a Component</a> for more.)</p><p>In this case, the content we wanted to display came from the model. But what if we want the developer using our component to be able to provide custom HTML content?</p><p>In addition to the simple form you’ve learned so far, components also support being used in <strong>block form</strong>. In block form, components can be passed a Handlebars template that is rendered inside the component’s template wherever the <code>{{yield}}</code> expression appears.</p><p>To use the block form, add a <code>#</code> character to the beginning of the component name, then make sure to add a closing tag. (See the Handlebars documentation on <a href=\"http://handlebarsjs.com/#block-expressions\">block expressions</a> for more.)</p><p>In that case, we can use the <code>{{blog-post}}</code> component in <strong>block form</strong> and tell Ember where the block content should be rendered using the <code>{{yield}}</code> helper. To update the example above, we’ll first change the component’s template:</p><p>```app/templates/components/blog-post.hbs </p>","link":"./BR/components/wrapping-content-in-a-component.pt-BR.html","spaLink":"#/BR/components/wrapping-content-in-a-component.pt-BR","title":"{{TITLE}}"},{"content":"<h2 id=\"-routing\">Routing</h2><p>```app/app.js export default Ember.Application.extend({ // Basic logging, e.g. “Transitioned into ‘post’” LOG_TRANSITIONS: true,</p><p>// Extremely detailed logging, highlighting every internal // step made while transitioning into a route, including // <code>beforeModel</code>, <code>model</code>, and <code>afterModel</code> hooks, and // information about redirects and aborted transitions LOG_TRANSITIONS_INTERNAL: true });</p>","link":"./BR/configuring-ember/debugging.pt-BR.html","spaLink":"#/BR/configuring-ember/debugging.pt-BR","title":"ROUTING"},{"content":"<h2 id=\"-controllers\">Controllers</h2><p>```config/environment.js ENV.APP.LOG_ACTIVE_GENERATION = true;</p><p>```config/environments.js ENV.APP.LOG_BINDINGS = true</p><p>If you are using imports with Ember, be sure to import the console:</p><p>There are times when dealing with promises that it seems like any errors are being ‘swallowed’, and not properly raised. This makes it extremely difficult to track down where a given issue is coming from. Thankfully, <code>RSVP</code> has a solution for this problem built in.</p><p>You can provide an <code>onerror</code> function that will be called with the error details if any errors occur within your promise. This function can be anything, but a common practice is to call <code>console.assert</code> to dump the error to the console.</p><p>```app/app.js Ember.RSVP.on(‘error’, function(error) { Ember.Logger.assert(false, error); });</p>","link":"./BR/configuring-ember/debugging.pt-BR.html","spaLink":"#/BR/configuring-ember/debugging.pt-BR","title":"CONTROLLERS"},{"content":"<h2 id=\"-life-without-prototype-extension\">Life Without Prototype Extension</h2><p>In order for your application to behave correctly, you will need to manually extend or create the objects that the native objects were creating before.</p>","link":"./BR/configuring-ember/disabling-prototype-extensions.pt-BR.html","spaLink":"#/BR/configuring-ember/disabling-prototype-extensions.pt-BR","title":"LIFE WITHOUT PROTOTYPE EXTENSION"},{"content":"<h3 id=\"-life-without-prototype-extension-arrays\">Arrays</h3><p>Native arrays will no longer implement the functionality needed to observe them. If you disable prototype extension and attempt to use native arrays with things like a template’s <code>{{#each}}</code> helper, Ember.js will have no way to detect changes to the array and the template will not update as the underlying array changes.</p><p>Additionally, if you try to set the model of an <code>Ember.ArrayController</code> to a plain native array, it will raise an exception since it no longer implements the <code>Ember.Array</code> interface.</p><p>You can manually coerce a native array into an array that implements the required interfaces using the convenience method <code>Ember.A</code>:</p>","link":"./BR/configuring-ember/disabling-prototype-extensions.pt-BR.html","spaLink":"#/BR/configuring-ember/disabling-prototype-extensions.pt-BR","title":"Arrays"},{"content":"<h3 id=\"-life-without-prototype-extension-strings\">Strings</h3><p>Strings will no longer have the convenience methods described in the <a href=\"http://emberjs.com/api/classes/Ember.String.html\">Ember.String API reference.</a>. Instead, you can use the similarly-named methods of the <code>Ember.String</code> object and pass the string to use as the first parameter:</p>","link":"./BR/configuring-ember/disabling-prototype-extensions.pt-BR.html","spaLink":"#/BR/configuring-ember/disabling-prototype-extensions.pt-BR","title":"Strings"},{"content":"<h3 id=\"-life-without-prototype-extension-functions\">Functions</h3><p>The <a href=\"../../object-model/\">Object Model</a> section of the Guides describes how to write computed properties, observers, and bindings without prototype extensions. Below you can learn about how to convert existing code to the format now encouraged.</p><p>To annotate computed properties, use the <code>Ember.computed()</code> method to wrap the function:</p><p>Observers are annotated using <code>Ember.observer()</code>:</p><p>Evented functions are annotated using <code>Ember.on()</code>:</p>","link":"./BR/configuring-ember/disabling-prototype-extensions.pt-BR.html","spaLink":"#/BR/configuring-ember/disabling-prototype-extensions.pt-BR","title":"Functions"},{"content":"<h3 id=\"-changing-the-root-element\">Changing the Root Element</h3><p>By default, your application will render the <a href=\"../../routing/defining-your-routes/#toc_the-application-route\">application template</a> and attach it to the document’s <code>body</code> element.</p><p>You can tell the application to append the application template to a different element by specifying its <code>rootElement</code> property:</p><p>```app/app.js export default Ember.Application.extend({ rootElement: ‘#app’ });</p>","link":"./BR/configuring-ember/embedding-applications.pt-BR.html","spaLink":"#/BR/configuring-ember/embedding-applications.pt-BR","title":"Changing the Root Element"},{"content":"<h3 id=\"-specifying-a-root-url\">Specifying a Root URL</h3><p>If your Ember application is one of multiple web applications served from the same domain, it may be necessary to indicate to the router what the root URL for your Ember application is. By default, Ember will assume it is served from the root of your domain.</p><p>For example, if you wanted to serve your blogging application from <code>http://emberjs.com/blog/</code>, it would be necessary to specify a root URL of <code>/blog/</code>.</p><p>This can be achieved by setting the <code>rootURL</code> on the router:</p>","link":"./BR/configuring-ember/embedding-applications.pt-BR.html","spaLink":"#/BR/configuring-ember/embedding-applications.pt-BR","title":"Specifying a Root URL"},{"content":"<h2 id=\"-feature-life-cycle\">Feature Life-Cycle</h2><p>A newly-flagged feature is only available in canary builds and can be enabled at runtime through your project’s configuration file.</p><p>At the start of a beta cycle the Ember core team evaluates each new feature. Features deemed stable are made available in the next beta and enabled by default.</p><p>Beta features that receive negative feedback from the community are disabled in the next beta point release, and are not included in the next stable release. They may still be included in the next beta cycle if the issues/concerns are resolved.</p><p>Once the beta cycle has completed, the next stable release will include any features that were enabled during the beta cycle. At this point the feature flags will be removed from the canary and future beta branches, and the feature becomes part of the framework.</p>","link":"./BR/configuring-ember/feature-flags.pt-BR.html","spaLink":"#/BR/configuring-ember/feature-flags.pt-BR","title":"FEATURE LIFE-CYCLE"},{"content":"<h2 id=\"-flagging-details\">Flagging Details</h2><p>The flag status in the generated build is controlled by the <a href=\"https://github.com/emberjs/ember.js/blob/master/features.json\"><code>features.json</code></a> file in the root of the Ember.js project. This file lists all new features and their current status.</p><p>A feature can have one of a three flags:</p><ul>\n<li><code>true</code> - The feature is <strong>present</strong> and <strong>enabled</strong>: the code behind the flag is always enabled in the generated build.</li>\n<li><code>null</code> - The feature is <strong>present</strong> but <strong>disabled</strong> in the build output. It must be enabled at runtime.</li>\n<li><code>false</code> - The feature is entirely <strong>disabled</strong>: the code behind the flag is not present in the generated build.</li>\n</ul><p>The process of removing the feature flags from the resulting build output is handled by <a href=\"https://github.com/thomasboyt/defeatureify\"><code>defeatureify</code></a>.</p>","link":"./BR/configuring-ember/feature-flags.pt-BR.html","spaLink":"#/BR/configuring-ember/feature-flags.pt-BR","title":"FLAGGING DETAILS"},{"content":"<h2 id=\"-feature-listing-featuresmd\">Feature Listing (<a href=\"https://github.com/emberjs/ember.js/blob/master/FEATURES.md\"><code>FEATURES.md</code></a>)</h2><p>When a developer adds a new feature to the <code>canary</code> channel (i.e. the <code>master</code> branch on github), they also add an entry to <a href=\"https://github.com/emberjs/ember.js/blob/master/FEATURES.md\"><code>FEATURES.md</code></a> explaining what the feature does, and linking to their originating pull request. This list is kept current, and reflects what is available in each channel (<code>release</code>, <code>beta</code>, and <code>canary</code>).</p>","link":"./BR/configuring-ember/feature-flags.pt-BR.html","spaLink":"#/BR/configuring-ember/feature-flags.pt-BR","title":"FEATURE LISTING (FEATURES.MD)"},{"content":"<h2 id=\"-enabling-at-runtime\">Enabling At Runtime</h2><p>When using the Ember.js canary or beta builds you can enable a “<strong>present</strong> but <strong>disabled</strong>“ feature by setting its flag value to <code>true</code> before your application boots:</p><p>For the truly ambitious developer, setting <code>ENV.EmberENV.ENABLE_ALL_FEATURES</code> to <code>true</code> will enable all experimental features.</p>","link":"./BR/configuring-ember/feature-flags.pt-BR.html","spaLink":"#/BR/configuring-ember/feature-flags.pt-BR","title":"ENABLING AT RUNTIME"},{"content":"<h2 id=\"-filtering-deprecations\">Filtering Deprecations</h2><p>When your project has a lot of deprecations, you can start by filtering out deprecations that do not have to be addressed right away. You can use the <a href=\"http://emberjs.com/api/classes/Ember.Debug.html#method_registerDeprecationHandler\">deprecation handlers</a> API to check for what release a deprecated feature will be removed. An example handler is shown below that filters out all deprecations that are not going away in release 2.0.0.</p><p>``` app/initializers/main.js if (Ember.Debug &amp;&amp; typeof Ember.Debug.registerDeprecationHandler === ‘function’) { Ember.Debug.registerDeprecationHandler((message, options, next) =&gt; { if (options &amp;&amp; options.until &amp;&amp; options.until !== ‘2.0.0’) { return; } next(message, options); }); }</p><p>You might notice that you have a lot of duplicated messages in your workflow file, like the 3 messages in the above example that start with <code>Accessing 'template' in...</code>. This is because some of the deprecation messages provide context to the specific deprecation, making them different than the same deprecation in other parts of the app. If you want to consolidate the duplication, you can use a simple regular expression with a wildcard (<code>.*</code>) for the part of the message that varies per instance.</p><p>Below is the same deprecation-workflow file as above, now with a regular expression on line 7 to remove some redundant messages. Note that the double quotes around <code>matchMessage</code> have also been replaced with forward slashes.</p><p><code>`` /config/deprecation-workflow.js window.deprecationWorkflow = window.deprecationWorkflow || {}; window.deprecationWorkflow.config = { workflow: [ { handler: \"silence\", matchMessage: \"Ember.Handlebars.registerHelper is deprecated, please refactor to Ember.Helper.helper.\" }, { handler: \"silence\", matchMessage: \"</code>lookup<code>was called on a Registry. The</code>initializer<code>API no longer receives a container, and you should use an</code>instanceInitializer<code>to look up objects from the container.\" }, { handler: \"silence\", matchMessage: \"Using</code>Ember.HTMLBars.makeBoundHelper<code>is deprecated. Please refactor to using</code>Ember.Helper<code>or</code>Ember.Helper.helper`.” }, { handler: “silence”, matchMessage: /Accessing ‘template’ in .<em> is deprecated. To determine if a block was specified to .</em> please use ‘{{#if hasBlock}}’ in the components layout./ } ] };</p><p><img width=\"675px\" src=\"../../images/guides/configuring-ember/handling-deprecations/failed-test-from-deprecation.png\"></p>","link":"./BR/configuring-ember/handling-deprecations.pt-BR.html","spaLink":"#/BR/configuring-ember/handling-deprecations.pt-BR","title":"FILTERING DEPRECATIONS"},{"content":"<h3 id=\"-filtering-deprecations-3-fix-and-repeat\">3. Fix and Repeat</h3><p>After fixing a deprecation and getting your scenarios working again, you might want to leave the deprecation message in the workflow file with the throw handler enabled. This will ensure you haven’t missed anything, and ensure no new deprecated calls of that type are introduced to your project. Next, it’s just a matter of going down the list, updating the handler, and fixing each remaining deprecation.</p><p>In the end, your deprecations can be fully turned on as “throw” and you should be able to use your application without error. At this point, you can go ahead and update your Ember version! When you upgrade, be sure you remove the deprecations you’ve fixed from the deprecation workflow file, so that you can start the process over for the next release.</p>","link":"./BR/configuring-ember/handling-deprecations.pt-BR.html","spaLink":"#/BR/configuring-ember/handling-deprecations.pt-BR","title":"3. Fix and Repeat"},{"content":"<h2 id=\"-silencing-deprecation-warnings-during-compile\">Silencing Deprecation Warnings During Compile</h2><p>As you upgrade between releases, you might also notice that your terminal log begins to stream template-related deprecation warnings during the compile process, making it difficult to review your compilation logs.</p><p><img width=\"675px\" src=\"../../images/guides/configuring-ember/handling-deprecations/compile-deprecations.png\" title=\"Compile Deprecations Clouding Log\"></p><p>If you are using the deprecation workflow process above, you will likely prefer to gather these warnings during runtime execution instead. The way to hide these warnings during compile is to install the <a href=\"http://emberobserver.com/addons/ember-cli-template-lint\">ember-cli-template-lint</a> addon. It suppresses template deprecation warnings during compile in favor of showing them in the browser console during test suite execution or application usage.</p>","link":"./BR/configuring-ember/handling-deprecations.pt-BR.html","spaLink":"#/BR/configuring-ember/handling-deprecations.pt-BR","title":"SILENCING DEPRECATION WARNINGS DURING COMPILE"},{"content":"<h2 id=\"-deprecation-handling-in-ember-inspector\">Deprecation Handling in Ember Inspector</h2><p>Ember Inspector also provides deprecation handling capability. It can work complimentary to ember-cli-deprecation-workflow. As you unsilence deprecations to fix them, the inspector can allow you to more quickly find where in your code a deprecation occurs when you run into it at runtime, reducing the amount of stack trace browsing you have to do. For more information on using deprecation handling in Ember Inspector, see its <a href=\"../../ember-inspector/deprecations/\">guides section</a>.</p>","link":"./BR/configuring-ember/handling-deprecations.pt-BR.html","spaLink":"#/BR/configuring-ember/handling-deprecations.pt-BR","title":"DEPRECATION HANDLING IN EMBER INSPECTOR"},{"content":"<h2 id=\"-history\">history</h2><p>When using <code>history</code>, Ember uses the browser’s <a href=\"http://caniuse.com/history\">history</a> API to produce URLs with a structure like <code>/posts/new</code>.</p><p>Given the following router, entering <code>/posts/new</code> will take you to the <code>posts.new</code> route.</p><p>Keep in mind that your server must serve the Ember app from all the URLs defined in your <code>Router.map</code> function. In other words, if your user directly navigates to <code>/posts/new</code>, your server must be configured to serve your Ember app in response.</p>","link":"./BR/configuring-ember/specifying-url-type.pt-BR.html","spaLink":"#/BR/configuring-ember/specifying-url-type.pt-BR","title":"HISTORY"},{"content":"<h2 id=\"-hash\">hash</h2><p>The <code>hash</code> option uses the URL’s anchor to load the starting state of your application and will keep it in sync as you move around. At present, this relies on a <a href=\"http://caniuse.com/hashchange\">hashchange</a> event existing in the browser.</p><p>In the router example above, entering <code>/#/posts/new</code> will take you to the <code>posts.new</code> route.</p>","link":"./BR/configuring-ember/specifying-url-type.pt-BR.html","spaLink":"#/BR/configuring-ember/specifying-url-type.pt-BR","title":"HASH"},{"content":"<h2 id=\"-none\">none</h2><p>Finally, if you don’t want the browser’s URL to interact with your application at all, you can disable the location API entirely by setting <code>ENV.locationType</code> to <code>none</code>. This is useful for testing, or when you don’t want Ember to muck with the URL (for example when you embed your application in a larger page).</p>","link":"./BR/configuring-ember/specifying-url-type.pt-BR.html","spaLink":"#/BR/configuring-ember/specifying-url-type.pt-BR","title":"NONE"},{"content":"<h3 id=\"-bug-fixes\">Bug Fixes</h3><p>Urgent bugfixes are bugfixes that need to be applied to the existing release branch. If possible, they should be made on master and prefixed with [BUGFIX release].</p><p>Beta bugfixes are bugfixes that need to be applied to the beta branch. If possible, they should be made on master and tagged with [BUGFIX beta].</p><p>Security fixes need to be applied to the beta branch, the current release branch, and the previous tag. If possible, they should be made on master and tagged with [SECURITY].</p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"Bug Fixes"},{"content":"<h3 id=\"-features\">Features</h3><p>Features must always be wrapped in a feature flag. Tests for the feature must also be wrapped in a feature flag.</p><p>Because the build-tools will process feature-flags, flags must use precisely this format. We are choosing conditionals rather than a block form because functions change the surrounding scope and may introduce problems with early return.</p><p>Tests will always run with all features on, so make sure that any tests for the feature are passing against the current state of the feature.</p><p>Commits related to a specific feature should include a prefix like [FEATURE htmlbars]. This will allow us to quickly identify all commits for a specific feature in the future. Features will never be applied to beta or release branches. Once a beta or release branch has been cut, it contains all of the new features it will ever have.</p><p>If a feature has made it into beta or release, and you make a commit to master that fixes a bug in the feature, treat it like a bugfix as described above.</p><p>```config/environment.js Ember.FEATURES[‘<packagename>-<feature>‘] // if package specific Ember.FEATURES[‘container-factory-injections’] Ember.FEATURES[‘htmlbars’]</feature></packagename></p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"Features"},{"content":"<h3 id=\"-featuresjson\"><code>features.json</code></h3><p>The root of the repository will contain a features.json file, which will contain a list of features that should be enabled for beta or release builds.</p><p>This file is populated when branching, and may not gain additional features after the original branch. It may remove features.</p><p>The build process will remove any features not included in the list, and remove the conditionals for features in the list.</p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"features.json"},{"content":"<h3 id=\"-travis-testing\">Travis Testing</h3><p>For a new PR:</p><p>For a new commit to master:</p><p>The idea is that new commits should be submitted as PRs to ensure they apply cleanly, and once the merge button is pressed, Travis will apply them to the right branches.</p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"Travis Testing"},{"content":"<h3 id=\"-gono-go-process\">Go/No-Go Process</h3><p>Every six weeks, the core team goes through the following process.</p><p>All remaining features on the beta branch are vetted for readiness. If any feature isn’t ready, it is removed from features.json.</p><p>Once this is done, the beta branch is tagged and merged into release.</p><p>All features on the master branch are vetted for readiness. In order for a feature to be considered “ready” at this stage, it must be ready as-is with no blockers. Features are a no-go even if they are close and additional work on the beta branch would make it ready.</p><p>Because this process happens every six weeks, there will be another opportunity for a feature to make it soon enough.</p><p>Once this is done, the master branch is merged into beta. A <code>features.json</code> file is added with the features that are ready.</p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"Go/No-Go Process"},{"content":"<h3 id=\"-beta-releases\">Beta Releases</h3><p>Every week, we repeat the Go/No-Go process for the features that remain on the beta branch. Any feature that has become unready is removed from the features.json.</p><p>Once this is done, a Beta release is tagged and pushed.</p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"Beta Releases"},{"content":"<h1 id=\"main-repositories\">Main Repositories</h1><p><strong>Ember.js</strong> - The main repository for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/ember.js\">https://github.com/emberjs/ember.js</a></li>\n</ul><p><strong>Ember Data</strong> - A data persistence library for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/data\">https://github.com/emberjs/data</a></li>\n</ul><p><strong>Ember Website</strong> - Source for <a href=\"http://emberjs.com\">http://emberjs.com</a></p><ul>\n<li><a href=\"https://github.com/emberjs/website\">https://github.com/emberjs/website</a></li>\n</ul><p><strong>Ember Guides</strong> - Source for <a href=\"http://guides.emberjs.com\">http://guides.emberjs.com</a> which you are currently reading.</p><ul>\n<li><a href=\"https://github.com/emberjs/guides\">https://github.com/emberjs/guides</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"MAIN REPOSITORIES"},{"content":"<h1 id=\"libraries-used-by-ember\">Libraries Used By Ember</h1><p>These libraries are part of the Ember.js source, but development of them takes place in a separate repository.</p>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"LIBRARIES USED BY EMBER"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-metallibvendorbackburnerjs\"><code>packages/ember-metal/lib/vendor/backburner.js</code></h2><ul>\n<li><strong>backburner.js</strong> - Implements the Ember run loop.</li>\n<li><a href=\"https://github.com/ebryn/backburner.js\">https://github.com/ebryn/backburner.js</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"PACKAGES/EMBER-METAL/LIB/VENDOR/BACKBURNER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorroute-recognizerjs\"><code>packages/ember-routing/lib/vendor/route-recognizer.js</code></h2><ul>\n<li><strong>route-recognizer.js</strong> - A lightweight JavaScript library that matches paths against registered routes.</li>\n<li><a href=\"https://github.com/tildeio/route-recognizer\">https://github.com/tildeio/route-recognizer</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTE-RECOGNIZER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorrouterjs\"><code>packages/ember-routing/lib/vendor/router.js</code></h2><ul>\n<li><strong>router.js</strong> - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.</li>\n<li><a href=\"https://github.com/tildeio/router.js\">https://github.com/tildeio/router.js</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesmetamorph\"><code>packages/metamorph</code></h2><ul>\n<li><strong>Metamorph.js</strong> - Used by Ember for databinding handlebars templates</li>\n<li><a href=\"https://github.com/tomhuda/metamorph.js\">https://github.com/tomhuda/metamorph.js</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"PACKAGES/METAMORPH"},{"content":"<h2 id=\"libraries-used-by-ember-packagesrsvp\"><code>packages/rsvp</code></h2><ul>\n<li><strong>RSVP.js</strong> - Implementation of the of Promises/A+ spec used by Ember.</li>\n<li><a href=\"https://github.com/tildeio/rsvp.js\">https://github.com/tildeio/rsvp.js</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"PACKAGES/RSVP"},{"content":"<h2 id=\"-addons\">Addons</h2><p>Ember Addons werden mit NPM installiert (z.B. <code>npm install --save-dev ember-cli-sass</code>). Addons können auch weitere Abhängigkeiten einbringen und dadurch die <code>bower.json</code>-Datei in deinem Projekt automatisch anpassen.</p><p>Eine Übersicht von Addons kannst du auf <a href=\"http://emberobserver.com\">Ember Observer</a> vorfinden.</p>","link":"./DE/addons-and-dependencies/managing-dependencies.de-DE.html","spaLink":"#/DE/addons-and-dependencies/managing-dependencies.de-DE","title":"ADDONS"},{"content":"<h2 id=\"-bower\">Bower</h2><p>Ember CLI benutzt den Paketmanager <a href=\"http://bower.io\">Bower</a>, mit dem du deine Frontend-Abhängigkeiten auf einfache Art aktuell halten kannst. Die Bower-Konfigurationsdatei, <code>bower.json</code>, befindet sich im Wurzelverzeichnis deines Ember-CLI-Projektes und erfasst die Abhängigkeiten deines Projekts. Durch Ausführen von <code>bower install</code> kannst du alle Abhängigkeiten, die in <code>bower.json</code> aufgeführt sind, auf einmal installieren.</p><p>Ember CLI überwacht <code>bower.json</code> auf Änderungen, d.h. es wird deine Anwendung neuladen, wenn du neue Abhängigkeiten mit <code>bower install &lt;abhaengigkeiten&gt; --save</code> installierst.</p>","link":"./DE/addons-and-dependencies/managing-dependencies.de-DE.html","spaLink":"#/DE/addons-and-dependencies/managing-dependencies.de-DE","title":"BOWER"},{"content":"<h2 id=\"-andere-ressourcen\">Andere Ressourcen</h2><p>Ressourcen, die nicht als Addon oder Bower-Paket verfügbar sind, solltest du im <code>vendor</code>-Verzeichnis deines Projekts ablegen.</p>","link":"./DE/addons-and-dependencies/managing-dependencies.de-DE.html","spaLink":"#/DE/addons-and-dependencies/managing-dependencies.de-DE","title":"ANDERE RESSOURCEN"},{"content":"<h2 id=\"-ressourcen-kompilieren\">Ressourcen kompilieren</h2><p>Wenn du Abhängigkeiten benutzt, die nicht in einem Addon verteilt werden, musst du Ember CLI anweisen, die benötigten Ressourcen in den Build-Prozess einzubinden. Das geschieht über die Datei <code>ember-cli-build.js</code>. Du solltest nach Möglichkeit nur Ressourcen importieren, die sich in einem der Verzeichnisse <code>bower_components</code> und <code>vendor</code> befinden.</p>","link":"./DE/addons-and-dependencies/managing-dependencies.de-DE.html","spaLink":"#/DE/addons-and-dependencies/managing-dependencies.de-DE","title":"RESSOURCEN KOMPILIEREN"},{"content":"<h3 id=\"-ressourcen-kompilieren-globals-provided-by-javascript-assets\">Globals provided by Javascript assets</h3><p>The globals provided by some assets (like <code>moment</code> in the below example) can be used in your application without the need to <code>import</code> them. Provide the asset path as the first and only argument.</p><p>```ember-cli-build.js app.import(‘bower_components/moment/moment.js’);</p><p>You can now <code>import</code> them in your app. (e.g. <code>import { raw as icAjaxRaw } from 'ic-ajax';</code>)</p>","link":"./DE/addons-and-dependencies/managing-dependencies.de-DE.html","spaLink":"#/DE/addons-and-dependencies/managing-dependencies.de-DE","title":"Globals provided by Javascript assets"},{"content":"<h3 id=\"-ressourcen-kompilieren-environment-specific-assets\">Environment Specific Assets</h3><p>If you need to use different assets in different environments, specify an object as the first parameter. That object’s key should be the environment name, and the value should be the asset to use in that environment.</p><p>```ember-cli-build.js app.import({ development: ‘bower_components/ember/ember.js’, production: ‘bower_components/ember/ember.prod.js’ });</p>","link":"./DE/addons-and-dependencies/managing-dependencies.de-DE.html","spaLink":"#/DE/addons-and-dependencies/managing-dependencies.de-DE","title":"Environment Specific Assets"},{"content":"<h3 id=\"-ressourcen-kompilieren-css\">CSS</h3><p>Provide the asset path as the first argument:</p><p>```ember-cli-build.js app.import(‘bower_components/foundation/css/foundation.css’);</p><p>This example would create the font file in <code>dist/font-awesome/fonts/fontawesome-webfont.ttf</code>.</p><p>You can also optionally tell <code>import()</code> to place the file at a different path. The following example will copy the file to <code>dist/assets/fontawesome-webfont.ttf</code>.</p><p>```ember-cli-build.js app.import(‘bower_components/font-awesome/fonts/fontawesome-webfont.ttf’, { destDir: ‘assets’ });</p>","link":"./DE/addons-and-dependencies/managing-dependencies.de-DE.html","spaLink":"#/DE/addons-and-dependencies/managing-dependencies.de-DE","title":"CSS"},{"content":"<h2 id=\"-factory-registrations\">Factory Registrations</h2><p>A factory can represent any part of your application, like a <em>route</em>, <em>template</em>, or custom class. Every factory is registered with a particular key. For example, the index template is registered with the key <code>template:index</code>, and the application route is registered with the key <code>route:application</code>.</p><p>Registration keys have two segments split by a colon (<code>:</code>). The first segment is the framework factory type, and the second is the name of the particular factory. Hence, the <code>index</code> template has the key <code>template:index</code>. Ember has several built-in factory types, such as <code>service</code>, <code>route</code>, <code>template</code>, and <code>component</code>.</p><p>You can create your own factory type by simply registering a factory with the new type. For example, to create a <code>user</code> type, you’d simply register your factory with <code>application.register('user:user-to-register')</code>.</p><p>Factory registrations must be performed either in application or application instance initializers (with the former being much more common).</p><p>For example, an application initializer could register a <code>Logger</code> factory with the key <code>logger:main</code>:</p><p>```app/initializers/logger.js export function initialize(application) { var Logger = Ember.Object.extend({ log(m) { console.log(m); } });</p><p>application.register(‘logger:main’, Logger); }</p><p>export default { name: ‘logger’, initialize: initialize };</p>","link":"./DE/applications/dependency-injection.de-DE.html","spaLink":"#/DE/applications/dependency-injection.de-DE","title":"FACTORY REGISTRATIONS"},{"content":"<h3 id=\"-factory-registrations-registering-singletons-vs-non-singletons\">Registering Singletons vs. Non-Singletons</h3><p>By default, registrations are treated as “singletons”. This simply means that an instance will be created when it is first looked up, and this same instance will be cached and returned from subsequent lookups.</p><p>When you want fresh objects to be created for every lookup, register your factories as non-singletons using the <code>singleton: false</code> option.</p><p>In the following example, the <code>Message</code> class is registered as a non-singleton:</p><p>```app/initializers/notification.js export function initialize(application) { var Message = Ember.Object.extend({ text: ‘’ });</p><p>application.register(‘notification:message’, Message, { singleton: false }); }</p><p>export default { name: ‘notification’, initialize: initialize };</p><p>As a result of this type injection, all factories of the type <code>route</code> will be instantiated with the property <code>logger</code> injected. The value of <code>logger</code> will come from the factory named <code>logger:main</code>.</p><p>Routes in this example application can now access the injected logger:</p><p>```app/routes/index.js export default Ember.Route.extend({ activate() { // The logger property is injected into all routes this.get(‘logger’).log(‘Entered the index route!’); } });</p><p>In this case, the logger will only be injected on the index route.</p><p>Injections can be made onto any class that requires instantiation. This includes all of Ember’s major framework classes, such as components, helpers, routes, and the router.</p>","link":"./DE/applications/dependency-injection.de-DE.html","spaLink":"#/DE/applications/dependency-injection.de-DE","title":"Registering Singletons vs. Non-Singletons"},{"content":"<h3 id=\"-factory-registrations-ad-hoc-injections\">Ad Hoc Injections</h3><p>Dependency injections can also be declared directly on Ember classes using <code>Ember.inject</code>. Currently, <code>Ember.inject</code> supports injecting controllers (via <code>Ember.inject.controller</code>) and services (via <code>Ember.inject.service</code>).</p><p>The following code injects the <code>shopping-cart</code> service on the <code>cart-contents</code> component as the property <code>cart</code>:</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ cart: Ember.inject.service(‘shopping-cart’) });</p>","link":"./DE/applications/dependency-injection.de-DE.html","spaLink":"#/DE/applications/dependency-injection.de-DE","title":"Ad Hoc Injections"},{"content":"<h2 id=\"-factory-instance-lookups\">Factory Instance Lookups</h2><p>To fetch an instantiated factory from the running application you can call the <a href=\"http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup\"><code>lookup</code></a> method on an application instance. This method takes a string to identify a factory and returns the appropriate object.</p><p>The application instance is passed to Ember’s instance initializer hooks and it is added as the “owner” of each object that was instantiated by the application instance.</p>","link":"./DE/applications/dependency-injection.de-DE.html","spaLink":"#/DE/applications/dependency-injection.de-DE","title":"FACTORY INSTANCE LOOKUPS"},{"content":"<h3 id=\"-factory-instance-lookups-using-an-application-instance-within-an-instance-initializer\">Using an Application Instance Within an Instance Initializer</h3><p>Instance initializers receive an application instance as an argument, providing an opportunity to look up an instance of a registered factory.</p><p>```app/instance-initializers/logger.js export function initialize(applicationInstance) { let logger = applicationInstance.lookup(‘logger:main’);</p><p>logger.log(‘Hello from the instance initializer!’); }</p><p>export default { name: ‘logger’, initialize: initialize };</p>","link":"./DE/applications/dependency-injection.de-DE.html","spaLink":"#/DE/applications/dependency-injection.de-DE","title":"Using an Application Instance Within an Instance Initializer"},{"content":"<h2 id=\"-application-initializers\">Application Initializers</h2><p>Application initializers can be created with Ember CLI’s <code>initializer</code> generator:</p><p>Let’s customize the <code>shopping-cart</code> initializer to inject a <code>cart</code> property into all the routes in your application:</p><p>```app/initializers/shopping-cart.js export function initialize(application) { application.inject(‘route’, ‘cart’, ‘service:shopping-cart’); };</p><p>export default { name: ‘shopping-cart’, initialize: initialize };</p><p>Let’s add some simple logging to indicate that the instance has booted:</p><p>```app/instance-initializers/logger.js export function initialize(applicationInstance) { var logger = applicationInstance.lookup(‘logger:main’); logger.log(‘Hello from the instance initializer!’); }</p><p>export default { name: ‘logger’, initialize: initialize };</p><p>```app/initializers/websocket-init.js export function initialize(application) { // … your code … };</p><p>export default { name: ‘websocketInit’, after: ‘configReader’, initialize: initialize }; ```</p><p>Note that ordering only applies to initializers of the same type (i.e. application or application instance). Application initializers will always run before application instance initializers.</p>","link":"./DE/applications/initializers.de-DE.html","spaLink":"#/DE/applications/initializers.de-DE","title":"APPLICATION INITIALIZERS"},{"content":"<h2 id=\"-why-is-the-run-loop-useful\">Why is the run loop useful?</h2><p>Very often, batching similar work has benefits. Web browsers do something quite similar by batching changes to the DOM.</p><p>Consider the following HTML snippet:</p><p>and executing the following code:</p><p>In this example, the sequence of code forced the browser to recalculate style, and relayout after each step. However, if we were able to batch similar jobs together, the browser would have only needed to recalculate the style and layout once.</p><p>Interestingly, this pattern holds true for many other types of work. Essentially, batching similar work allows for better pipelining, and further optimization.</p><p>Let’s look at a similar example that is optimized in Ember, starting with a <code>User</code> object:</p><p>and a template to display its attributes:</p><p>If we execute the following code without the run loop:</p><p>We see that the browser will rerender the template twice.</p><p>However, if we have the run loop in the above code, the browser will only rerender the template once the attributes have all been set.</p><p>In the above example with the run loop, since the user’s attributes end up at the same values as before execution, the template will not even rerender!</p><p>It is of course possible to optimize these scenarios on a case-by-case basis, but getting them for free is much nicer. Using the run loop, we can apply these classes of optimizations not only for each scenario, but holistically app-wide.</p>","link":"./DE/applications/run-loop.de-DE.html","spaLink":"#/DE/applications/run-loop.de-DE","title":"WHY IS THE RUN LOOP USEFUL?"},{"content":"<h2 id=\"-how-does-the-run-loop-work-in-ember\">How does the Run Loop work in Ember?</h2><p>As mentioned earlier, we schedule work (in the form of function invocations) on queues, and these queues are processed to completion in priority order.</p><p>What are the queues, and what is their priority order?</p><p>Because the priority is first to last, the “sync” queue has higher priority than the “render” or “destroy” queue.</p>","link":"./DE/applications/run-loop.de-DE.html","spaLink":"#/DE/applications/run-loop.de-DE","title":"HOW DOES THE RUN LOOP WORK IN EMBER?"},{"content":"<h2 id=\"-what-happens-in-these-queues\">What happens in these queues?</h2><ul>\n<li>The <code>sync</code> queue contains binding synchronization jobs.</li>\n<li>The <code>actions</code> queue is the general work queue and will typically contain scheduled tasks e.g. promises.</li>\n<li>The <code>routerTransitions</code> queue contains transition jobs in the router.</li>\n<li>The <code>render</code> queue contains jobs meant for rendering, these will typically update the DOM.</li>\n<li>The <code>afterRender</code> queue contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated.</li>\n<li>The <code>destroy</code> queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.</li>\n</ul>","link":"./DE/applications/run-loop.de-DE.html","spaLink":"#/DE/applications/run-loop.de-DE","title":"WHAT HAPPENS IN THESE QUEUES?"},{"content":"<h2 id=\"-in-what-order-are-jobs-executed-on-the-queues\">In what order are jobs executed on the queues?</h2><p>The algorithm works this way:</p>","link":"./DE/applications/run-loop.de-DE.html","spaLink":"#/DE/applications/run-loop.de-DE","title":"IN WHAT ORDER ARE JOBS EXECUTED ON THE QUEUES?"},{"content":"<h2 id=\"-an-example-of-the-internals\">An example of the internals</h2><p>Rather than writing the higher level app code that internally invokes the various run loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.</p><p>Working with this API directly is not common in most Ember apps, but understanding this example will help you to understand the run-loops algorithm, which will make you a better Ember developer. <iframe src=\"https://s3.amazonaws.com/emberjs.com/run-loop-guide/index.html\" width=\"678\" height=\"410\" style=\"border:1px solid rgb(170, 170, 170);margin-bottom:1.5em;\"></iframe></p>","link":"./DE/applications/run-loop.de-DE.html","spaLink":"#/DE/applications/run-loop.de-DE","title":"AN EXAMPLE OF THE INTERNALS"},{"content":"<h2 id=\"-how-do-i-tell-ember-to-start-a-run-loop\">How do I tell Ember to start a run loop?</h2><p>You should begin a run loop when the callback fires.</p><p>The <code>Ember.run</code> method can be used to create a runloop. In this example, jQuery and <code>Ember.run</code> are used to handle a click event and run some Ember code.</p><p>This example uses the <code>=&gt;</code> function syntax, which is a [new ES2015 syntax for callback functions] (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>) that provides a lexical <code>this</code>. If this syntax is new, think of it as a function that has the same <code>this</code> as the context it is defined in.</p>","link":"./DE/applications/run-loop.de-DE.html","spaLink":"#/DE/applications/run-loop.de-DE","title":"HOW DO I TELL EMBER TO START A RUN LOOP?"},{"content":"<h2 id=\"-what-happens-if-i-forget-to-start-a-run-loop-in-an-async-handler\">What happens if I forget to start a run loop in an async handler?</h2><p>As mentioned above, you should wrap any non-Ember async callbacks in <code>Ember.run</code>. If you don’t, Ember will try to approximate a beginning and end for you. Consider the following callback:</p><p>The runloop API calls that <em>schedule</em> work i.e. <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_schedule\"><code>run.schedule</code></a>, <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce\"><code>run.scheduleOnce</code></a>, <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_once\"><code>run.once</code></a> have the property that they will approximate a runloop for you if one does not already exist. These automatically created runloops we call <em>autoruns</em>.</p><p>Here is some pseudocode to describe what happens using the example above:</p><p>Although autoruns are convenient, they are suboptimal. The current JS frame is allowed to end before the run loop is flushed, which sometimes means the browser will take the opportunity to do other things, like garbage collection. GC running in between data changing and DOM rerendering can cause visual lag and should be minimized.</p><p>Relying on autoruns is not a rigorous or efficient way to use the runloop. Wrapping event handlers manually is preferred.</p>","link":"./DE/applications/run-loop.de-DE.html","spaLink":"#/DE/applications/run-loop.de-DE","title":"WHAT HAPPENS IF I FORGET TO START A RUN LOOP IN AN ASYNC HANDLER?"},{"content":"<h2 id=\"-how-is-runloop-behaviour-different-when-testing\">How is runloop behaviour different when testing?</h2><p>When your application is in <em>testing mode</em> then Ember will throw an error if you try to schedule work without an available runloop.</p><p>Autoruns are disabled in testing for several reasons:</p>","link":"./DE/applications/run-loop.de-DE.html","spaLink":"#/DE/applications/run-loop.de-DE","title":"HOW IS RUNLOOP BEHAVIOUR DIFFERENT WHEN TESTING?"},{"content":"<h2 id=\"-where-can-i-find-more-information\">Where can I find more information?</h2><p>Check out the <a href=\"http://emberjs.com/api/classes/Ember.run.html\">Ember.run</a> API documentation, as well as the <a href=\"https://github.com/ebryn/backburner.js/\">Backburner library</a> that powers the run loop.</p>","link":"./DE/applications/run-loop.de-DE.html","spaLink":"#/DE/applications/run-loop.de-DE","title":"WHERE CAN I FIND MORE INFORMATION?"},{"content":"<h3 id=\"-defining-services\">Defining Services</h3><p>Services can be generated using Ember CLI’s <code>service</code> generator. For example, the following command will create the <code>ShoppingCart</code> service:</p><p>Services must extend the <a href=\"http://emberjs.com/api/classes/Ember.Service.html\"><code>Ember.Service</code></a> base class:</p><p>```app/services/shopping-cart.js export default Ember.Service.extend({ });</p>","link":"./DE/applications/services.de-DE.html","spaLink":"#/DE/applications/services.de-DE","title":"Defining Services"},{"content":"<h3 id=\"-accessing-services\">Accessing Services</h3><p>To access a service, you can inject it in any container-resolved object such as a component or another service using the <code>Ember.inject.service</code> function. There are 2 ways to use this function. You can either invoke it with no arguments, or you can pass it the registered name of the service. When no arguments are passed the services is loaded based in the name of the variable key. You can load the shopping cart service with no arguments like below.</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ //will load the service in file /app/services/shopping-cart.js shoppingCart: Ember.inject.service() });</p><p>This injects the shopping cart service into the component and makes it available as the <code>cart</code> property.</p><p>Injected properties are lazy loaded; meaning the service will not be instantiated until the property is explicitly called. Therefore you need to access services in your component using the <code>get</code> function otherwise you might get an undefined.</p><p>Once loaded, a service will persist until the application exits.</p><p>Below we add a remove action to the <code>cart-contents</code> component. Notice that below we access the <code>cart</code> service with a call to<code>this.get</code>.</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ cart: Ember.inject.service(‘shopping-cart’),</p><p>actions: { remove(item) { this.get(‘cart’).remove(item); } } });</p>","link":"./DE/applications/services.de-DE.html","spaLink":"#/DE/applications/services.de-DE","title":"Accessing Services"},{"content":"<h3 id=\"-customizing-the-element\">Customizing the Element</h3><p>To use a tag other than <code>div</code>, subclass <code>Ember.Component</code> and assign it a <code>tagName</code> property. This property can be any valid HTML5 tag name as a string.</p><p>```app/components/navigation-bar.js export default Ember.Component.extend({ tagName: ‘nav’ });</p>","link":"./DE/components/customizing-a-components-element.de-DE.html","spaLink":"#/DE/components/customizing-a-components-element.de-DE","title":"Customizing the Element"},{"content":"<h3 id=\"-customizing-class-names\">Customizing Class Names</h3><p>You can also specify which class names are applied to the component’s element by setting its <code>classNames</code> property to an array of strings:</p><p>```app/components/navigation-bar.js export default Ember.Component.extend({ classNames: [‘primary’] });</p><p>This component would render the following:</p><p>If <code>isUrgent</code> is changed to <code>false</code>, then the <code>is-urgent</code> class name will be removed.</p><p>By default, the name of the Boolean property is dasherized. You can customize the class name applied by delimiting it with a colon:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isUrgent:urgent’], isUrgent: true });</p><p>Besides the custom class name for the value being <code>true</code>, you can also specify a class name which is used when the value is <code>false</code>:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isEnabled:enabled:disabled’], isEnabled: false });</p><p>You can also specify a class which should only be added when the property is <code>false</code> by declaring <code>classNameBindings</code> like this:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isEnabled::disabled’], isEnabled: false });</p><p>If the <code>isEnabled</code> property is set to <code>true</code>, no class name is added:</p><p>If the bound property’s value is a string, that value will be added as a class name without modification:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘priority’], priority: ‘highestPriority’ });</p>","link":"./DE/components/customizing-a-components-element.de-DE.html","spaLink":"#/DE/components/customizing-a-components-element.de-DE","title":"Customizing Class Names"},{"content":"<h3 id=\"-customizing-attributes\">Customizing Attributes</h3><p>You can bind attributes to the DOM element that represents a component by using <code>attributeBindings</code>:</p><p>```app/components/link-item.js export default Ember.Component.extend({ tagName: ‘a’, attributeBindings: [‘href’], href: ‘<a href=\"http://emberjs.com\">http://emberjs.com</a>‘ });</p><p>If the attribute is null, it won’t be rendered:</p><p>```app/components/link-item.js export default Ember.Component.extend({ tagName: ‘span’, title: null, attributeBindings: [‘title’], });</p><p>…and this HTML when a title of “Ember JS” is passed to the component:</p>","link":"./DE/components/customizing-a-components-element.de-DE.html","spaLink":"#/DE/components/customizing-a-components-element.de-DE","title":"Customizing Attributes"},{"content":"<h1 id=\"title\">{{title}}</h1><p>{{yield}}</p><p>Edit title: {{input type=”text” value=title}}</p><p></p><p>Its model is populated in <code>model</code> hook in the route handler:</p><p>```app/routes/index.js export default Ember.Route.extend({ model() { return this.store.findAll(‘post’); } });</p><p>```app/templates/components/bar-component.hbs </p>","link":"./DE/components/defining-a-component.de-DE.html","spaLink":"#/DE/components/defining-a-component.de-DE","title":"{{TITLE}}"},{"content":"<h3 id=\"title-hello-from-bar\">Hello from bar!</h3><p>When the parameter passed to <code>{{component}}</code> evaluates to <code>null</code> or <code>undefined</code>, the helper renders nothing. When the parameter changes, the currently rendered component is destroyed and the new component is created and brought in.</p><p>Picking different components to render in response to the data allows you to have different template and behavior for each case. The <code>{{component}}</code> helper is a powerful tool for improving code modularity.</p>","link":"./DE/components/defining-a-component.de-DE.html","spaLink":"#/DE/components/defining-a-component.de-DE","title":"Hello from bar!"},{"content":"<h2 id=\"-sending-actions\">Sending Actions</h2><p>In some cases your component needs to define event handlers, perhaps to support various draggable behaviors. For example, a component may need to send an <code>id</code> when it receives a drop event:</p><p>You can define the component’s event handlers to manage the drop event. And if you need to, you may also stop events from bubbling, by using <code>return false;</code>.</p><p>```app/components/drop-target.js export default Ember.Component.extend({ attributeBindings: [‘draggable’], draggable: ‘true’,</p><p>dragOver() { return false; },</p><p>drop(event) { let id = event.dataTransfer.getData(‘text/data’); this.sendAction(‘action’, id); } }); ```</p>","link":"./DE/components/handling-events.de-DE.html","spaLink":"#/DE/components/handling-events.de-DE","title":"SENDING ACTIONS"},{"content":"<h2 id=\"-event-names\">Event Names</h2><p>The event handling examples described above respond to one set of events. The names of the built-in events are listed below. Custom events can be registered by using <a href=\"http://emberjs.com/api/classes/Ember.Application.html#property_customEvents\">Ember.Application.customEvents</a>.</p><p>Touch events:</p><ul>\n<li><code>touchStart</code></li>\n<li><code>touchMove</code></li>\n<li><code>touchEnd</code></li>\n<li><code>touchCancel</code></li>\n</ul><p>Keyboard events</p><ul>\n<li><code>keyDown</code></li>\n<li><code>keyUp</code></li>\n<li><code>keyPress</code></li>\n</ul><p>Mouse events</p><ul>\n<li><code>mouseDown</code></li>\n<li><code>mouseUp</code></li>\n<li><code>contextMenu</code></li>\n<li><code>click</code></li>\n<li><code>doubleClick</code></li>\n<li><code>mouseMove</code></li>\n<li><code>focusIn</code></li>\n<li><code>focusOut</code></li>\n<li><code>mouseEnter</code></li>\n<li><code>mouseLeave</code></li>\n</ul><p>Form events:</p><ul>\n<li><code>submit</code></li>\n<li><code>change</code></li>\n<li><code>focusIn</code></li>\n<li><code>focusOut</code></li>\n<li><code>input</code></li>\n</ul><p>HTML5 drag and drop events:</p><ul>\n<li><code>dragStart</code></li>\n<li><code>drag</code></li>\n<li><code>dragEnter</code></li>\n<li><code>dragLeave</code></li>\n<li><code>dragOver</code></li>\n<li><code>dragEnd</code></li>\n<li><code>drop</code></li>\n</ul>","link":"./DE/components/handling-events.de-DE.html","spaLink":"#/DE/components/handling-events.de-DE","title":"EVENT NAMES"},{"content":"<h1 id=\"title\">{{title}}</h1><p>{{body}}</p><p></p><p>If we tried to use the component like this:</p><p>```app/templates/index.hbs {{#each model as |post|}} {{blog-post}} {{/each}}</p><p>In order to make a property available to a component, you must pass it in like this:</p><p>```app/templates/index.hbs {{#each model as |post|}} {{blog-post title=post.title body=post.body}} {{/each}}</p><p>To set the component up to receive parameters this way, you need set the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams\"><code>positionalParams</code></a> attribute in your component class.</p><p>```app/components/blog-post.js const BlogPostComponent = Ember.Component.extend({});</p><p>BlogPostComponent.reopenClass({ positionalParams: [‘title’, ‘body’] });</p><p>export default BlogPostComponent;</p>","link":"./DE/components/passing-properties-to-a-component.de-DE.html","spaLink":"#/DE/components/passing-properties-to-a-component.de-DE","title":"{{TITLE}}"},{"content":"<h2 id=\"-order-of-lifecycle-hooks-called\">Order of Lifecycle Hooks Called</h2><p>Listed below are the component lifecycle hooks in order of execution according to render scenario.</p>","link":"./DE/components/the-component-lifecycle.de-DE.html","spaLink":"#/DE/components/the-component-lifecycle.de-DE","title":"ORDER OF LIFECYCLE HOOKS CALLED"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-initial-render\">On Initial Render</h3>","link":"./DE/components/the-component-lifecycle.de-DE.html","spaLink":"#/DE/components/the-component-lifecycle.de-DE","title":"On Initial Render"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-re-render\">On Re-Render</h3>","link":"./DE/components/the-component-lifecycle.de-DE.html","spaLink":"#/DE/components/the-component-lifecycle.de-DE","title":"On Re-Render"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-component-destroy\">On Component Destroy</h3>","link":"./DE/components/the-component-lifecycle.de-DE.html","spaLink":"#/DE/components/the-component-lifecycle.de-DE","title":"On Component Destroy"},{"content":"<h2 id=\"-lifecycle-hook-examples\">Lifecycle Hook Examples</h2><p>Below are some samples of ways to use lifecycle hooks within your components.</p>","link":"./DE/components/the-component-lifecycle.de-DE.html","spaLink":"#/DE/components/the-component-lifecycle.de-DE","title":"LIFECYCLE HOOK EXAMPLES"},{"content":"<h3 id=\"-lifecycle-hook-examples-resetting-presentation-state-on-attribute-change-with-didupdateattrs\">Resetting Presentation State on Attribute Change with <code>didUpdateAttrs</code></h3><p><code>didUpdateAttrs</code> runs when the attributes of a component have changed, but not when the component is re-rendered, via <code>component.rerender</code>, <code>component.set</code>, or changes in models or services used by the template.</p><p>A <code>didUpdateAttrs</code> is called prior to rerender, you can use this hook to execute code when specific attributes are changed. This hook can be an effective alternative to an observer, as it will run prior to a re-render, but after an attribute has changed.</p><p>An example of this scenario in action is a profile editor component. As you are editing one user, and the user attribute is changed, you can use <code>didUpdateAttrs</code> to clear any error state that was built up from editing the previous user.</p><p><code>/app/templates/components/profile-editor.hbs</code></p><p><code>/app/components/profile-editor.js</code></p>","link":"./DE/components/the-component-lifecycle.de-DE.html","spaLink":"#/DE/components/the-component-lifecycle.de-DE","title":"Resetting Presentation State on Attribute Change with didUpdateAttrs"},{"content":"<h3 id=\"-lifecycle-hook-examples-formatting-component-attributes-with-didreceiveattrs\">Formatting Component Attributes with <code>didReceiveAttrs</code></h3><p><code>didReceiveAttrs</code> runs after <code>init</code>, and it also runs on subsequent re-renders, which is useful for logic that is the same on all renders. It does not run when the re-rendered has been initiated internally.</p><p>Since the <code>didReceiveAttrs</code> hook is called every time a component’s attributes are updated whether on render or re-render, you can use the hook to effectively act as an observer, ensuring code is executed every time an attribute changes.</p><p>For example, if you have a component that renders based on a json configuration, but you want to provide your component with the option of taking the config as a string, you can leverage <code>didReceiveAttrs</code> to ensure the incoming config is always parsed.</p>","link":"./DE/components/the-component-lifecycle.de-DE.html","spaLink":"#/DE/components/the-component-lifecycle.de-DE","title":"Formatting Component Attributes with didReceiveAttrs"},{"content":"<h3 id=\"-lifecycle-hook-examples-integrating-with-third-party-libraries-with-didinsertelement\">Integrating with Third-Party Libraries with <code>didInsertElement</code></h3><p>Suppose you want to integrate your favorite date picker library into an Ember project. Typically, 3rd party JS/jQuery libraries require a DOM element to bind to. So, where is the best place to initialize and attach the library?</p><p>After a component successfully renders its backing HTML element into the DOM, it will trigger its <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> hook.</p><p>Ember guarantees that, by the time <code>didInsertElement()</code> is called:</p><p>A component’s <a href=\"http://emberjs.com/api/classes/Ember.Component.html#method__\"><code>$()</code></a> method allows you to access the component’s DOM element by returning a JQuery element. For example, you can set an attribute using jQuery’s <code>attr()</code> method:</p><p><a href=\"http://emberjs.com/api/classes/Ember.Component.html#method__\"><code>$()</code></a> will, by default, return a jQuery object for the component’s root element, but you can also target child elements within the component’s template by passing a selector:</p><p>Let’s initialize our date picker by overriding the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> method.</p><p>Date picker libraries usually attach to an <code>&lt;input&gt;</code> element, so we will use jQuery to find an appropriate input within our component’s template.</p><p><a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> is also a good place to attach event listeners. This is particularly useful for custom events or other browser events which do not have a <a href=\"http://guides.emberjs.com/v2.1.0/components/handling-events/#toc_event-names\">built-in event handler</a>.</p><p>For example, perhaps you have some custom CSS animations trigger when the component is rendered and you want to handle some cleanup when it ends:</p><p>There are a few things to note about the <code>didInsertElement()</code> hook:</p><ul>\n<li>It is only triggered once when the component element is first rendered.</li>\n<li>In cases where you have components nested inside other components, the child component will always receive the <code>didInsertElement()</code> call before its parent does.</li>\n<li>Setting properties on the component in <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> triggers a re-render, and for performance reasons, is not allowed.</li>\n<li>While <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> is technically an event that can be listened for using <a href=\"http://emberjs.com/api/classes/Ember.Component.html#method_on\"><code>on()</code></a>, it is encouraged to override the default method itself, particularly when order of execution is important.</li>\n</ul>","link":"./DE/components/the-component-lifecycle.de-DE.html","spaLink":"#/DE/components/the-component-lifecycle.de-DE","title":"Integrating with Third-Party Libraries with didInsertElement"},{"content":"<h3 id=\"-lifecycle-hook-examples-making-updates-to-the-rendered-dom-with-didrender\">Making Updates to the Rendered DOM with <code>didRender</code></h3><p>The <code>didRender</code> hook is called during both render and re-render after the template has rendered and the DOM updated. You can leverage this hook to perform post-processing on the DOM of a component after its been updated.</p><p>In this example, there is a list component that needs to scroll to a selected item when rendered. Since scrolling to a specific spot is based on positions within the DOM, we need to ensure that the list has been rendered before scrolling. We can first render this list, and then set the scroll.</p><p>The component below takes a list of items and displays them on the screen. Additionally, it takes an object representing which item is selected and will select and set the scroll top to that item.</p><p>When rendered the component will iterate through the given list and apply a class to the one that is selected.</p><p><code>/app/templates/components/selected-item-list.hbs</code></p><p>The scroll happens on <code>didRender</code>, where it will scroll the component’s container to the element with the selected class name.</p><p><code>/app/components/selected-item-list.js</code></p>","link":"./DE/components/the-component-lifecycle.de-DE.html","spaLink":"#/DE/components/the-component-lifecycle.de-DE","title":"Making Updates to the Rendered DOM with didRender"},{"content":"<h3 id=\"-lifecycle-hook-examples-detaching-and-tearing-down-component-elements-with-willdestroyelement\">Detaching and Tearing Down Component Elements with <code>willDestroyElement</code></h3><p>When a component detects that it is time to remove itself from the DOM, Ember will trigger the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_willDestroyElement\"><code>willDestroyElement()</code></a> method, allowing for any teardown logic to be performed.</p><p>Component teardown can be triggered by a number of different conditions. For instance, the user may navigate to a different route, or a conditional Handlebars block surrounding your component may change:</p><p>Let’s use this hook to cleanup our date picker and event listener from above:</p>","link":"./DE/components/the-component-lifecycle.de-DE.html","spaLink":"#/DE/components/the-component-lifecycle.de-DE","title":"Detaching and Tearing Down Component Elements with willDestroyElement"},{"content":"<h2 id=\"-creating-the-component\">Creating the Component</h2><p>Let’s call our component <code>button-with-confirmation</code>. We can create it by typing:</p><p>We’ll plan to use the component in a template something like this:</p><p>```app/templates/components/user-profile.hbs {{button-with-confirmation text=”Click OK to delete your account.”}}</p>","link":"./DE/components/triggering-changes-with-actions.de-DE.html","spaLink":"#/DE/components/triggering-changes-with-actions.de-DE","title":"CREATING THE COMPONENT"},{"content":"<h2 id=\"-designing-the-action\">Designing the Action</h2><p>When implementing an action on a component, you need to break it down into two steps:</p><p>Let’s take it step by step.</p>","link":"./DE/components/triggering-changes-with-actions.de-DE.html","spaLink":"#/DE/components/triggering-changes-with-actions.de-DE","title":"DESIGNING THE ACTION"},{"content":"<h2 id=\"-implementing-the-action\">Implementing the Action</h2><p>In the parent component, let’s first define what we want to happen when the user clicks the button and then confirms. In this case, we’ll find the user’s account and delete it.</p><p>In Ember, each component can have a property called <code>actions</code>, where you put functions that can be <a href=\"../../templates/actions/\">invoked by the user interacting with the component itself</a>, or by child components.</p><p>Let’s look at the parent component’s JavaScript file. In this example, imagine we have a parent component called <code>user-profile</code> that shows the user’s profile to them.</p><p>We’ll implement an action on the parent component called <code>userDidDeleteAccount()</code> that, when called, gets a hypothetical <code>login</code> <a href=\"../../applications/services/\">service</a> and calls the service’s <code>deleteUser()</code> method.</p><p>```app/components/user-profile.js export default Ember.Component.extend({ login: Ember.inject.service(),</p><p>actions: { userDidDeleteAccount() { this.get(‘login’).deleteUser(); } } });</p><p>The component template will have a button and a div that shows the confirmation dialog based on the value of <code>confirmShown</code>.</p><p>```app/templates/components/button-with-confirmation.hbs <button {{action=\"\" \"launchconfirmdialog\"}}=\"\">{{text}}</button> {{#if confirmShown}} </p><p></p><p></p><p>This snippet says “take the <code>userDidDeleteAccount</code> action from the parent and make it available on the child component as <code>onConfirm</code>.”</p><p>We can do a similar thing for our <code>send-message</code> component:</p><p>```app/templates/components/send-message.hbs {{button-with-confirmation text=”Click to send your message.” onConfirm=(action “sendMessage”)}}</p><p><code>this.get('onConfirm')</code> will return the function passed from the parent as the value of <code>onConfirm</code>, and the following <code>()</code> will invoke the function.</p><p>Like normal attributes, actions can be a property on the component; the only difference is that the property is set to a function that knows how to trigger behavior.</p><p>That makes it easy to remember how to add an action to a component. It’s like passing an attribute, but you use the <code>action</code> helper to pass a function instead.</p><p>Actions in components allow you to decouple an event happening from how it’s handled, leading to modular, more reusable components.</p>","link":"./DE/components/triggering-changes-with-actions.de-DE.html","spaLink":"#/DE/components/triggering-changes-with-actions.de-DE","title":"IMPLEMENTING THE ACTION"},{"content":"<h2 id=\"-handling-action-completion\">Handling Action Completion</h2><p>Often actions perform asynchronous tasks, such as making an ajax request to a server. Since actions are functions that can be passed in by a parent component, they are able to return values when called. The most common scenario is for an action to return a promise so that the component can handle the action’s completion.</p><p>In our user <code>button-with-confirmation</code> component we want to leave the confirmation modal open until we know that the operation has completed successfully. This is accomplished by expecting a promise to be returned from <code>onConfirm</code>. Upon resolution of the promise, we set a property used to indicate the visibility of the confirmation modal.</p><p>```app/components/button-with-confirmation.js export default Ember.Component.extend({ actions: { launchConfirmDialog() { this.set(‘confirmShown’, true); },</p><p>} });</p><p>In this case, the code in <code>button-with-confirmation</code> does not change. It will still invoke <code>onConfirm</code> with no arguments. The action helper will add the arguments provided in the template to the call.</p><p>Action arguments curry, meaning that you can provide partial arguments to the action helper and provide the rest of the arguments when you call the function within the component javascript file. For example, our <code>button-with-confirmation</code> component will now <a href=\"../wrapping-content-in-a-component/\">yield</a> the content of the confirmation dialog to collect extra information to be sent along with the <code>onConfirm</code> action:</p><p>```app/templates/components/button-with-confirmation.hbs <button {{action=\"\" \"launchconfirmdialog\"}}=\"\">{{text}}</button> {{#if confirmShown}} </p><p></p><p></p><p>Now when the <code>submitConfirm</code> action is invoked, we call it with the value provided by our yielded input.</p><p>```app/components/button-with-confirmation.js export default Ember.Component.extend({ actions: { launchConfirmDialog() { this.set(“confirmShown”, true); },</p><p>} });</p>","link":"./DE/components/triggering-changes-with-actions.de-DE.html","spaLink":"#/DE/components/triggering-changes-with-actions.de-DE","title":"HANDLING ACTION COMPLETION"},{"content":"<h2 id=\"-invoking-actions-directly-on-component-collaborators\">Invoking Actions Directly on Component Collaborators</h2><p>Actions can be invoked on objects other than the component directly from the template. For example, in our <code>send-message</code> component we might include a service that processes the <code>sendMessage</code> logic.</p><p>```app/components/send-message.js export default Ember.Component.extend({ messaging: Ember.inject.service(),</p><p>// component implementation });</p><p>By supplying the <code>target</code> attribute, the action helper will look to invoke the <code>sendMessage</code> action directly on the messaging service, saving us from writing code on the component that just passes the action along to the service.</p><p>```app/services/messaging.js export default Ember.Service.extend({ actions: { sendMessage(messageType, text) { //handle message send and return a promise } } });</p><p>All our <code>system-preferences-editor</code> component really needs to process a user deletion is an account ID. For this case, the action helper provides the <code>value</code> attribute to allow a parent component to dig into the passed object to pull out only what it needs.</p><p>```app/templates/components/system-preferences-editor.hbs {{user-profile didDelete=(action “userDeleted” value=”account.id”)}}</p>","link":"./DE/components/triggering-changes-with-actions.de-DE.html","spaLink":"#/DE/components/triggering-changes-with-actions.de-DE","title":"INVOKING ACTIONS DIRECTLY ON COMPONENT COLLABORATORS"},{"content":"<h2 id=\"-calling-actions-up-multiple-component-layers\">Calling Actions Up Multiple Component Layers</h2><p>When your components go multiple template layers deep, its common to need to handle an action several layers up the tree. Using the action helper, it is possible to make actions defined in parent components available at the bottom layers of your component tree without adding JavaScript code to the components in between.</p><p>For example, we want to take account deletion out of the <code>user-profile</code> component and handle deletion in its parent. In our template in <code>user-profile.hbs</code>, we can change our action to call <code>deleteCurrentUser</code>, which will be defined on <code>system-preferences-editor</code>.</p><p>```app/templates/components/user-profile.hbs {{button-with-confirmation onConfirm=(action deleteCurrentUser) text=”Click OK to delete your account.”}}</p><p>Now when you confirm deletion, the action goes straight to the <code>system-preferences-editor</code> to handle.</p><p>```app/components/system-preferences-editor.js import Ember from ‘ember’;</p><p>export default Ember.Component.extend({ login: Ember.inject.service(), actions: { deleteUser(idStr) { return this.get(‘login’).deleteUserAccount(idStr); } } }); ```</p>","link":"./DE/components/triggering-changes-with-actions.de-DE.html","spaLink":"#/DE/components/triggering-changes-with-actions.de-DE","title":"CALLING ACTIONS UP MULTIPLE COMPONENT LAYERS"},{"content":"<h1 id=\"title\">{{title}}</h1><p>(See <a href=\"../passing-properties-to-a-component/\">Passing Properties to a Component</a> for more.)</p><p>In this case, the content we wanted to display came from the model. But what if we want the developer using our component to be able to provide custom HTML content?</p><p>In addition to the simple form you’ve learned so far, components also support being used in <strong>block form</strong>. In block form, components can be passed a Handlebars template that is rendered inside the component’s template wherever the <code>{{yield}}</code> expression appears.</p><p>To use the block form, add a <code>#</code> character to the beginning of the component name, then make sure to add a closing tag. (See the Handlebars documentation on <a href=\"http://handlebarsjs.com/#block-expressions\">block expressions</a> for more.)</p><p>In that case, we can use the <code>{{blog-post}}</code> component in <strong>block form</strong> and tell Ember where the block content should be rendered using the <code>{{yield}}</code> helper. To update the example above, we’ll first change the component’s template:</p><p>```app/templates/components/blog-post.hbs </p>","link":"./DE/components/wrapping-content-in-a-component.de-DE.html","spaLink":"#/DE/components/wrapping-content-in-a-component.de-DE","title":"{{TITLE}}"},{"content":"<h2 id=\"-routing\">Routing</h2><p>```app/app.js export default Ember.Application.extend({ // Basic logging, e.g. “Transitioned into ‘post’” LOG_TRANSITIONS: true,</p><p>// Extremely detailed logging, highlighting every internal // step made while transitioning into a route, including // <code>beforeModel</code>, <code>model</code>, and <code>afterModel</code> hooks, and // information about redirects and aborted transitions LOG_TRANSITIONS_INTERNAL: true });</p>","link":"./DE/configuring-ember/debugging.de-DE.html","spaLink":"#/DE/configuring-ember/debugging.de-DE","title":"ROUTING"},{"content":"<h2 id=\"-controllers\">Controllers</h2><p>```config/environment.js ENV.APP.LOG_ACTIVE_GENERATION = true;</p><p>```config/environments.js ENV.APP.LOG_BINDINGS = true</p><p>If you are using imports with Ember, be sure to import the console:</p><p>There are times when dealing with promises that it seems like any errors are being ‘swallowed’, and not properly raised. This makes it extremely difficult to track down where a given issue is coming from. Thankfully, <code>RSVP</code> has a solution for this problem built in.</p><p>You can provide an <code>onerror</code> function that will be called with the error details if any errors occur within your promise. This function can be anything, but a common practice is to call <code>console.assert</code> to dump the error to the console.</p><p>```app/app.js Ember.RSVP.on(‘error’, function(error) { Ember.Logger.assert(false, error); });</p>","link":"./DE/configuring-ember/debugging.de-DE.html","spaLink":"#/DE/configuring-ember/debugging.de-DE","title":"CONTROLLERS"},{"content":"<h2 id=\"-life-without-prototype-extension\">Life Without Prototype Extension</h2><p>In order for your application to behave correctly, you will need to manually extend or create the objects that the native objects were creating before.</p>","link":"./DE/configuring-ember/disabling-prototype-extensions.de-DE.html","spaLink":"#/DE/configuring-ember/disabling-prototype-extensions.de-DE","title":"LIFE WITHOUT PROTOTYPE EXTENSION"},{"content":"<h3 id=\"-life-without-prototype-extension-arrays\">Arrays</h3><p>Native arrays will no longer implement the functionality needed to observe them. If you disable prototype extension and attempt to use native arrays with things like a template’s <code>{{#each}}</code> helper, Ember.js will have no way to detect changes to the array and the template will not update as the underlying array changes.</p><p>Additionally, if you try to set the model of an <code>Ember.ArrayController</code> to a plain native array, it will raise an exception since it no longer implements the <code>Ember.Array</code> interface.</p><p>You can manually coerce a native array into an array that implements the required interfaces using the convenience method <code>Ember.A</code>:</p>","link":"./DE/configuring-ember/disabling-prototype-extensions.de-DE.html","spaLink":"#/DE/configuring-ember/disabling-prototype-extensions.de-DE","title":"Arrays"},{"content":"<h3 id=\"-life-without-prototype-extension-strings\">Strings</h3><p>Strings will no longer have the convenience methods described in the <a href=\"http://emberjs.com/api/classes/Ember.String.html\">Ember.String API reference.</a>. Instead, you can use the similarly-named methods of the <code>Ember.String</code> object and pass the string to use as the first parameter:</p>","link":"./DE/configuring-ember/disabling-prototype-extensions.de-DE.html","spaLink":"#/DE/configuring-ember/disabling-prototype-extensions.de-DE","title":"Strings"},{"content":"<h3 id=\"-life-without-prototype-extension-functions\">Functions</h3><p>The <a href=\"../../object-model/\">Object Model</a> section of the Guides describes how to write computed properties, observers, and bindings without prototype extensions. Below you can learn about how to convert existing code to the format now encouraged.</p><p>To annotate computed properties, use the <code>Ember.computed()</code> method to wrap the function:</p><p>Observers are annotated using <code>Ember.observer()</code>:</p><p>Evented functions are annotated using <code>Ember.on()</code>:</p>","link":"./DE/configuring-ember/disabling-prototype-extensions.de-DE.html","spaLink":"#/DE/configuring-ember/disabling-prototype-extensions.de-DE","title":"Functions"},{"content":"<h3 id=\"-changing-the-root-element\">Changing the Root Element</h3><p>By default, your application will render the <a href=\"../../routing/defining-your-routes/#toc_the-application-route\">application template</a> and attach it to the document’s <code>body</code> element.</p><p>You can tell the application to append the application template to a different element by specifying its <code>rootElement</code> property:</p><p>```app/app.js export default Ember.Application.extend({ rootElement: ‘#app’ });</p>","link":"./DE/configuring-ember/embedding-applications.de-DE.html","spaLink":"#/DE/configuring-ember/embedding-applications.de-DE","title":"Changing the Root Element"},{"content":"<h3 id=\"-specifying-a-root-url\">Specifying a Root URL</h3><p>If your Ember application is one of multiple web applications served from the same domain, it may be necessary to indicate to the router what the root URL for your Ember application is. By default, Ember will assume it is served from the root of your domain.</p><p>For example, if you wanted to serve your blogging application from <code>http://emberjs.com/blog/</code>, it would be necessary to specify a root URL of <code>/blog/</code>.</p><p>This can be achieved by setting the <code>rootURL</code> on the router:</p>","link":"./DE/configuring-ember/embedding-applications.de-DE.html","spaLink":"#/DE/configuring-ember/embedding-applications.de-DE","title":"Specifying a Root URL"},{"content":"<h2 id=\"-feature-life-cycle\">Feature Life-Cycle</h2><p>A newly-flagged feature is only available in canary builds and can be enabled at runtime through your project’s configuration file.</p><p>At the start of a beta cycle the Ember core team evaluates each new feature. Features deemed stable are made available in the next beta and enabled by default.</p><p>Beta features that receive negative feedback from the community are disabled in the next beta point release, and are not included in the next stable release. They may still be included in the next beta cycle if the issues/concerns are resolved.</p><p>Once the beta cycle has completed, the next stable release will include any features that were enabled during the beta cycle. At this point the feature flags will be removed from the canary and future beta branches, and the feature becomes part of the framework.</p>","link":"./DE/configuring-ember/feature-flags.de-DE.html","spaLink":"#/DE/configuring-ember/feature-flags.de-DE","title":"FEATURE LIFE-CYCLE"},{"content":"<h2 id=\"-flagging-details\">Flagging Details</h2><p>The flag status in the generated build is controlled by the <a href=\"https://github.com/emberjs/ember.js/blob/master/features.json\"><code>features.json</code></a> file in the root of the Ember.js project. This file lists all new features and their current status.</p><p>A feature can have one of a three flags:</p><ul>\n<li><code>true</code> - The feature is <strong>present</strong> and <strong>enabled</strong>: the code behind the flag is always enabled in the generated build.</li>\n<li><code>null</code> - The feature is <strong>present</strong> but <strong>disabled</strong> in the build output. It must be enabled at runtime.</li>\n<li><code>false</code> - The feature is entirely <strong>disabled</strong>: the code behind the flag is not present in the generated build.</li>\n</ul><p>The process of removing the feature flags from the resulting build output is handled by <a href=\"https://github.com/thomasboyt/defeatureify\"><code>defeatureify</code></a>.</p>","link":"./DE/configuring-ember/feature-flags.de-DE.html","spaLink":"#/DE/configuring-ember/feature-flags.de-DE","title":"FLAGGING DETAILS"},{"content":"<h2 id=\"-feature-listing-featuresmd\">Feature Listing (<a href=\"https://github.com/emberjs/ember.js/blob/master/FEATURES.md\"><code>FEATURES.md</code></a>)</h2><p>When a developer adds a new feature to the <code>canary</code> channel (i.e. the <code>master</code> branch on github), they also add an entry to <a href=\"https://github.com/emberjs/ember.js/blob/master/FEATURES.md\"><code>FEATURES.md</code></a> explaining what the feature does, and linking to their originating pull request. This list is kept current, and reflects what is available in each channel (<code>release</code>, <code>beta</code>, and <code>canary</code>).</p>","link":"./DE/configuring-ember/feature-flags.de-DE.html","spaLink":"#/DE/configuring-ember/feature-flags.de-DE","title":"FEATURE LISTING (FEATURES.MD)"},{"content":"<h2 id=\"-enabling-at-runtime\">Enabling At Runtime</h2><p>When using the Ember.js canary or beta builds you can enable a “<strong>present</strong> but <strong>disabled</strong>“ feature by setting its flag value to <code>true</code> before your application boots:</p><p>For the truly ambitious developer, setting <code>ENV.EmberENV.ENABLE_ALL_FEATURES</code> to <code>true</code> will enable all experimental features.</p>","link":"./DE/configuring-ember/feature-flags.de-DE.html","spaLink":"#/DE/configuring-ember/feature-flags.de-DE","title":"ENABLING AT RUNTIME"},{"content":"<h2 id=\"-filtering-deprecations\">Filtering Deprecations</h2><p>When your project has a lot of deprecations, you can start by filtering out deprecations that do not have to be addressed right away. You can use the <a href=\"http://emberjs.com/api/classes/Ember.Debug.html#method_registerDeprecationHandler\">deprecation handlers</a> API to check for what release a deprecated feature will be removed. An example handler is shown below that filters out all deprecations that are not going away in release 2.0.0.</p><p>``` app/initializers/main.js if (Ember.Debug &amp;&amp; typeof Ember.Debug.registerDeprecationHandler === ‘function’) { Ember.Debug.registerDeprecationHandler((message, options, next) =&gt; { if (options &amp;&amp; options.until &amp;&amp; options.until !== ‘2.0.0’) { return; } next(message, options); }); }</p><p>You might notice that you have a lot of duplicated messages in your workflow file, like the 3 messages in the above example that start with <code>Accessing 'template' in...</code>. This is because some of the deprecation messages provide context to the specific deprecation, making them different than the same deprecation in other parts of the app. If you want to consolidate the duplication, you can use a simple regular expression with a wildcard (<code>.*</code>) for the part of the message that varies per instance.</p><p>Below is the same deprecation-workflow file as above, now with a regular expression on line 7 to remove some redundant messages. Note that the double quotes around <code>matchMessage</code> have also been replaced with forward slashes.</p><p><code>`` /config/deprecation-workflow.js window.deprecationWorkflow = window.deprecationWorkflow || {}; window.deprecationWorkflow.config = { workflow: [ { handler: \"silence\", matchMessage: \"Ember.Handlebars.registerHelper is deprecated, please refactor to Ember.Helper.helper.\" }, { handler: \"silence\", matchMessage: \"</code>lookup<code>was called on a Registry. The</code>initializer<code>API no longer receives a container, and you should use an</code>instanceInitializer<code>to look up objects from the container.\" }, { handler: \"silence\", matchMessage: \"Using</code>Ember.HTMLBars.makeBoundHelper<code>is deprecated. Please refactor to using</code>Ember.Helper<code>or</code>Ember.Helper.helper`.” }, { handler: “silence”, matchMessage: /Accessing ‘template’ in .<em> is deprecated. To determine if a block was specified to .</em> please use ‘{{#if hasBlock}}’ in the components layout./ } ] };</p><p><img width=\"675px\" src=\"../../images/guides/configuring-ember/handling-deprecations/failed-test-from-deprecation.png\"></p>","link":"./DE/configuring-ember/handling-deprecations.de-DE.html","spaLink":"#/DE/configuring-ember/handling-deprecations.de-DE","title":"FILTERING DEPRECATIONS"},{"content":"<h3 id=\"-filtering-deprecations-3-fix-and-repeat\">3. Fix and Repeat</h3><p>After fixing a deprecation and getting your scenarios working again, you might want to leave the deprecation message in the workflow file with the throw handler enabled. This will ensure you haven’t missed anything, and ensure no new deprecated calls of that type are introduced to your project. Next, it’s just a matter of going down the list, updating the handler, and fixing each remaining deprecation.</p><p>In the end, your deprecations can be fully turned on as “throw” and you should be able to use your application without error. At this point, you can go ahead and update your Ember version! When you upgrade, be sure you remove the deprecations you’ve fixed from the deprecation workflow file, so that you can start the process over for the next release.</p>","link":"./DE/configuring-ember/handling-deprecations.de-DE.html","spaLink":"#/DE/configuring-ember/handling-deprecations.de-DE","title":"3. Fix and Repeat"},{"content":"<h2 id=\"-silencing-deprecation-warnings-during-compile\">Silencing Deprecation Warnings During Compile</h2><p>As you upgrade between releases, you might also notice that your terminal log begins to stream template-related deprecation warnings during the compile process, making it difficult to review your compilation logs.</p><p><img width=\"675px\" src=\"../../images/guides/configuring-ember/handling-deprecations/compile-deprecations.png\" title=\"Compile Deprecations Clouding Log\"></p><p>If you are using the deprecation workflow process above, you will likely prefer to gather these warnings during runtime execution instead. The way to hide these warnings during compile is to install the <a href=\"http://emberobserver.com/addons/ember-cli-template-lint\">ember-cli-template-lint</a> addon. It suppresses template deprecation warnings during compile in favor of showing them in the browser console during test suite execution or application usage.</p>","link":"./DE/configuring-ember/handling-deprecations.de-DE.html","spaLink":"#/DE/configuring-ember/handling-deprecations.de-DE","title":"SILENCING DEPRECATION WARNINGS DURING COMPILE"},{"content":"<h2 id=\"-deprecation-handling-in-ember-inspector\">Deprecation Handling in Ember Inspector</h2><p>Ember Inspector also provides deprecation handling capability. It can work complimentary to ember-cli-deprecation-workflow. As you unsilence deprecations to fix them, the inspector can allow you to more quickly find where in your code a deprecation occurs when you run into it at runtime, reducing the amount of stack trace browsing you have to do. For more information on using deprecation handling in Ember Inspector, see its <a href=\"../../ember-inspector/deprecations/\">guides section</a>.</p>","link":"./DE/configuring-ember/handling-deprecations.de-DE.html","spaLink":"#/DE/configuring-ember/handling-deprecations.de-DE","title":"DEPRECATION HANDLING IN EMBER INSPECTOR"},{"content":"<h2 id=\"-history\">history</h2><p>When using <code>history</code>, Ember uses the browser’s <a href=\"http://caniuse.com/history\">history</a> API to produce URLs with a structure like <code>/posts/new</code>.</p><p>Given the following router, entering <code>/posts/new</code> will take you to the <code>posts.new</code> route.</p><p>Keep in mind that your server must serve the Ember app from all the URLs defined in your <code>Router.map</code> function. In other words, if your user directly navigates to <code>/posts/new</code>, your server must be configured to serve your Ember app in response.</p>","link":"./DE/configuring-ember/specifying-url-type.de-DE.html","spaLink":"#/DE/configuring-ember/specifying-url-type.de-DE","title":"HISTORY"},{"content":"<h2 id=\"-hash\">hash</h2><p>The <code>hash</code> option uses the URL’s anchor to load the starting state of your application and will keep it in sync as you move around. At present, this relies on a <a href=\"http://caniuse.com/hashchange\">hashchange</a> event existing in the browser.</p><p>In the router example above, entering <code>/#/posts/new</code> will take you to the <code>posts.new</code> route.</p>","link":"./DE/configuring-ember/specifying-url-type.de-DE.html","spaLink":"#/DE/configuring-ember/specifying-url-type.de-DE","title":"HASH"},{"content":"<h2 id=\"-none\">none</h2><p>Finally, if you don’t want the browser’s URL to interact with your application at all, you can disable the location API entirely by setting <code>ENV.locationType</code> to <code>none</code>. This is useful for testing, or when you don’t want Ember to muck with the URL (for example when you embed your application in a larger page).</p>","link":"./DE/configuring-ember/specifying-url-type.de-DE.html","spaLink":"#/DE/configuring-ember/specifying-url-type.de-DE","title":"NONE"},{"content":"<h3 id=\"-bug-fixes\">Bug Fixes</h3><p>Urgent bugfixes are bugfixes that need to be applied to the existing release branch. If possible, they should be made on master and prefixed with [BUGFIX release].</p><p>Beta bugfixes are bugfixes that need to be applied to the beta branch. If possible, they should be made on master and tagged with [BUGFIX beta].</p><p>Security fixes need to be applied to the beta branch, the current release branch, and the previous tag. If possible, they should be made on master and tagged with [SECURITY].</p>","link":"./DE/contributing/adding-new-features.de-DE.html","spaLink":"#/DE/contributing/adding-new-features.de-DE","title":"Bug Fixes"},{"content":"<h3 id=\"-features\">Features</h3><p>Features must always be wrapped in a feature flag. Tests for the feature must also be wrapped in a feature flag.</p><p>Because the build-tools will process feature-flags, flags must use precisely this format. We are choosing conditionals rather than a block form because functions change the surrounding scope and may introduce problems with early return.</p><p>Tests will always run with all features on, so make sure that any tests for the feature are passing against the current state of the feature.</p><p>Commits related to a specific feature should include a prefix like [FEATURE htmlbars]. This will allow us to quickly identify all commits for a specific feature in the future. Features will never be applied to beta or release branches. Once a beta or release branch has been cut, it contains all of the new features it will ever have.</p><p>If a feature has made it into beta or release, and you make a commit to master that fixes a bug in the feature, treat it like a bugfix as described above.</p><p>```config/environment.js Ember.FEATURES[‘<packagename>-<feature>‘] // if package specific Ember.FEATURES[‘container-factory-injections’] Ember.FEATURES[‘htmlbars’]</feature></packagename></p>","link":"./DE/contributing/adding-new-features.de-DE.html","spaLink":"#/DE/contributing/adding-new-features.de-DE","title":"Features"},{"content":"<h3 id=\"-featuresjson\"><code>features.json</code></h3><p>The root of the repository will contain a features.json file, which will contain a list of features that should be enabled for beta or release builds.</p><p>This file is populated when branching, and may not gain additional features after the original branch. It may remove features.</p><p>The build process will remove any features not included in the list, and remove the conditionals for features in the list.</p>","link":"./DE/contributing/adding-new-features.de-DE.html","spaLink":"#/DE/contributing/adding-new-features.de-DE","title":"features.json"},{"content":"<h3 id=\"-travis-testing\">Travis Testing</h3><p>For a new PR:</p><p>For a new commit to master:</p><p>The idea is that new commits should be submitted as PRs to ensure they apply cleanly, and once the merge button is pressed, Travis will apply them to the right branches.</p>","link":"./DE/contributing/adding-new-features.de-DE.html","spaLink":"#/DE/contributing/adding-new-features.de-DE","title":"Travis Testing"},{"content":"<h3 id=\"-gono-go-process\">Go/No-Go Process</h3><p>Every six weeks, the core team goes through the following process.</p><p>All remaining features on the beta branch are vetted for readiness. If any feature isn’t ready, it is removed from features.json.</p><p>Once this is done, the beta branch is tagged and merged into release.</p><p>All features on the master branch are vetted for readiness. In order for a feature to be considered “ready” at this stage, it must be ready as-is with no blockers. Features are a no-go even if they are close and additional work on the beta branch would make it ready.</p><p>Because this process happens every six weeks, there will be another opportunity for a feature to make it soon enough.</p><p>Once this is done, the master branch is merged into beta. A <code>features.json</code> file is added with the features that are ready.</p>","link":"./DE/contributing/adding-new-features.de-DE.html","spaLink":"#/DE/contributing/adding-new-features.de-DE","title":"Go/No-Go Process"},{"content":"<h3 id=\"-beta-releases\">Beta Releases</h3><p>Every week, we repeat the Go/No-Go process for the features that remain on the beta branch. Any feature that has become unready is removed from the features.json.</p><p>Once this is done, a Beta release is tagged and pushed.</p>","link":"./DE/contributing/adding-new-features.de-DE.html","spaLink":"#/DE/contributing/adding-new-features.de-DE","title":"Beta Releases"},{"content":"<h1 id=\"main-repositories\">Main Repositories</h1><p><strong>Ember.js</strong> - The main repository for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/ember.js\">https://github.com/emberjs/ember.js</a></li>\n</ul><p><strong>Ember Data</strong> - A data persistence library for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/data\">https://github.com/emberjs/data</a></li>\n</ul><p><strong>Ember Website</strong> - Source for <a href=\"http://emberjs.com\">http://emberjs.com</a></p><ul>\n<li><a href=\"https://github.com/emberjs/website\">https://github.com/emberjs/website</a></li>\n</ul><p><strong>Ember Guides</strong> - Source for <a href=\"http://guides.emberjs.com\">http://guides.emberjs.com</a> which you are currently reading.</p><ul>\n<li><a href=\"https://github.com/emberjs/guides\">https://github.com/emberjs/guides</a></li>\n</ul>","link":"./DE/contributing/repositories.de-DE.html","spaLink":"#/DE/contributing/repositories.de-DE","title":"MAIN REPOSITORIES"},{"content":"<h1 id=\"libraries-used-by-ember\">Libraries Used By Ember</h1><p>These libraries are part of the Ember.js source, but development of them takes place in a separate repository.</p>","link":"./DE/contributing/repositories.de-DE.html","spaLink":"#/DE/contributing/repositories.de-DE","title":"LIBRARIES USED BY EMBER"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-metallibvendorbackburnerjs\"><code>packages/ember-metal/lib/vendor/backburner.js</code></h2><ul>\n<li><strong>backburner.js</strong> - Implements the Ember run loop.</li>\n<li><a href=\"https://github.com/ebryn/backburner.js\">https://github.com/ebryn/backburner.js</a></li>\n</ul>","link":"./DE/contributing/repositories.de-DE.html","spaLink":"#/DE/contributing/repositories.de-DE","title":"PACKAGES/EMBER-METAL/LIB/VENDOR/BACKBURNER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorroute-recognizerjs\"><code>packages/ember-routing/lib/vendor/route-recognizer.js</code></h2><ul>\n<li><strong>route-recognizer.js</strong> - A lightweight JavaScript library that matches paths against registered routes.</li>\n<li><a href=\"https://github.com/tildeio/route-recognizer\">https://github.com/tildeio/route-recognizer</a></li>\n</ul>","link":"./DE/contributing/repositories.de-DE.html","spaLink":"#/DE/contributing/repositories.de-DE","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTE-RECOGNIZER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorrouterjs\"><code>packages/ember-routing/lib/vendor/router.js</code></h2><ul>\n<li><strong>router.js</strong> - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.</li>\n<li><a href=\"https://github.com/tildeio/router.js\">https://github.com/tildeio/router.js</a></li>\n</ul>","link":"./DE/contributing/repositories.de-DE.html","spaLink":"#/DE/contributing/repositories.de-DE","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesmetamorph\"><code>packages/metamorph</code></h2><ul>\n<li><strong>Metamorph.js</strong> - Used by Ember for databinding handlebars templates</li>\n<li><a href=\"https://github.com/tomhuda/metamorph.js\">https://github.com/tomhuda/metamorph.js</a></li>\n</ul>","link":"./DE/contributing/repositories.de-DE.html","spaLink":"#/DE/contributing/repositories.de-DE","title":"PACKAGES/METAMORPH"},{"content":"<h2 id=\"libraries-used-by-ember-packagesrsvp\"><code>packages/rsvp</code></h2><ul>\n<li><strong>RSVP.js</strong> - Implementation of the of Promises/A+ spec used by Ember.</li>\n<li><a href=\"https://github.com/tildeio/rsvp.js\">https://github.com/tildeio/rsvp.js</a></li>\n</ul>","link":"./DE/contributing/repositories.de-DE.html","spaLink":"#/DE/contributing/repositories.de-DE","title":"PACKAGES/RSVP"},{"content":"<h2 id=\"-addons\">Addons</h2><p>Ember Addons are installed using NPM (e.g. <code>npm install --save-dev ember-cli-sass</code>).\nAddons may bring in other dependencies by modifying your project’s <code>bower.json</code> file automatically.</p><p>You can find listings of addons on <a href=\"http://emberobserver.com\">Ember Observer</a>.</p>","link":"./EN/addons-and-dependencies/managing-dependencies.html","spaLink":"#/EN/addons-and-dependencies/managing-dependencies","title":"ADDONS"},{"content":"<h2 id=\"-bower\">Bower</h2><p>Ember CLI uses the <a href=\"http://bower.io\">Bower</a> package manager,\nmaking it easy to keep your front-end dependencies up to date.\nThe Bower configuration file, <code>bower.json</code>, is located at the root of your Ember CLI project,\nand lists the dependencies for your project.\nExecuting <code>bower install</code> will install all of the dependencies listed in <code>bower.json</code> in one step.</p><p>Ember CLI watches <code>bower.json</code> for changes.\nThus it reloads your app if you install new dependencies via <code>bower install &lt;dependencies&gt; --save</code>.</p>","link":"./EN/addons-and-dependencies/managing-dependencies.html","spaLink":"#/EN/addons-and-dependencies/managing-dependencies","title":"BOWER"},{"content":"<h2 id=\"-other-assets\">Other assets</h2><p>Assets not available as an addon or Bower package should be placed in the <code>vendor</code> folder in your project.</p>","link":"./EN/addons-and-dependencies/managing-dependencies.html","spaLink":"#/EN/addons-and-dependencies/managing-dependencies","title":"OTHER ASSETS"},{"content":"<h2 id=\"-compiling-assets\">Compiling Assets</h2><p>When you’re using dependencies that are not included in an addon,\nyou will have to instruct Ember CLI to include your assets in the build.\nThis is done using the asset manifest file <code>ember-cli-build.js</code>.\nYou should only try to import assets located in the <code>bower_components</code> and <code>vendor</code> folders.</p>","link":"./EN/addons-and-dependencies/managing-dependencies.html","spaLink":"#/EN/addons-and-dependencies/managing-dependencies","title":"COMPILING ASSETS"},{"content":"<h3 id=\"-compiling-assets-globals-provided-by-javascript-assets\">Globals provided by Javascript assets</h3><p>The globals provided by some assets (like <code>moment</code> in the below example) can be used in your application\nwithout the need to <code>import</code> them.\nProvide the asset path as the first and only argument.</p><p>You will need to add <code>\"moment\": true</code> to the <code>predef</code> section in <code>.jshintrc</code> to prevent JSHint errors\nabout using an undefined variable.</p>","link":"./EN/addons-and-dependencies/managing-dependencies.html","spaLink":"#/EN/addons-and-dependencies/managing-dependencies","title":"Globals provided by Javascript assets"},{"content":"<h3 id=\"-compiling-assets-amd-javascript-modules\">AMD Javascript modules</h3><p>Provide the asset path as the first argument, and the list of modules and exports as the second.</p><p>You can now <code>import</code> them in your app. (e.g. <code>import { raw as icAjaxRaw } from 'ic-ajax';</code>)</p>","link":"./EN/addons-and-dependencies/managing-dependencies.html","spaLink":"#/EN/addons-and-dependencies/managing-dependencies","title":"AMD Javascript modules"},{"content":"<h3 id=\"-compiling-assets-environment-specific-assets\">Environment Specific Assets</h3><p>If you need to use different assets in different environments, specify an object as the first parameter.\nThat object’s key should be the environment name, and the value should be the asset to use in that environment.</p><p>If you need to import an asset in only one environment you can wrap <code>app.import</code> in an <code>if</code> statement.\nFor assets needed during testing, you should also use the <code>{type: 'test'}</code> option to make sure they\nare available in test mode.</p>","link":"./EN/addons-and-dependencies/managing-dependencies.html","spaLink":"#/EN/addons-and-dependencies/managing-dependencies","title":"Environment Specific Assets"},{"content":"<h3 id=\"-compiling-assets-css\">CSS</h3><p>Provide the asset path as the first argument:</p><p>All style assets added this way will be concatenated and output as <code>/assets/vendor.css</code>.</p>","link":"./EN/addons-and-dependencies/managing-dependencies.html","spaLink":"#/EN/addons-and-dependencies/managing-dependencies","title":"CSS"},{"content":"<h3 id=\"-compiling-assets-other-assets\">Other Assets</h3><p>All other assets like images or fonts can also be added via <code>import()</code>.\nBy default, they\nwill be copied to <code>dist/</code> as they are.</p><p>This example would create the font file in <code>dist/font-awesome/fonts/fontawesome-webfont.ttf</code>.</p><p>You can also optionally tell <code>import()</code> to place the file at a different path.\nThe following example will copy the file to <code>dist/assets/fontawesome-webfont.ttf</code>.</p><p>If you need to load certain dependencies before others,\nyou can set the <code>prepend</code> property equal to <code>true</code> on the second argument of <code>import()</code>.\nThis will prepend the dependency to the vendor file instead of appending it, which is the default behavior.</p>","link":"./EN/addons-and-dependencies/managing-dependencies.html","spaLink":"#/EN/addons-and-dependencies/managing-dependencies","title":"Other Assets"},{"content":"<h2 id=\"-factory-registrations\">Factory Registrations</h2><p>A factory can represent any part of your application, like a <em>route</em>, <em>template</em>, or custom class.\nEvery factory is registered with a particular key.\nFor example, the index template is registered with the key <code>template:index</code>,\nand the application route is registered with the key <code>route:application</code>.</p><p>Registration keys have two segments split by a colon (<code>:</code>).\nThe first segment is the framework factory type, and the second is the name of the particular factory.\nHence, the <code>index</code> template has the key <code>template:index</code>.\nEmber has several built-in factory types, such as <code>service</code>, <code>route</code>, <code>template</code>, and <code>component</code>.</p><p>You can create your own factory type by simply registering a factory with the new type.\nFor example, to create a <code>user</code> type,\nyou’d simply register your factory with <code>application.register('user:user-to-register')</code>.</p><p>Factory registrations must be performed either in application\nor application instance initializers (with the former being much more common).</p><p>For example, an application initializer could register a <code>Logger</code> factory with the key <code>logger:main</code>:</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"FACTORY REGISTRATIONS"},{"content":"<h3 id=\"-factory-registrations-registering-already-instantiated-objects\">Registering Already Instantiated Objects</h3><p>By default, Ember will attempt to instantiate a registered factory when it is looked up.\nWhen registering an already instantiated object instead of a class,\nuse the <code>instantiate: false</code> option to avoid attempts to re-instantiate it during lookups.</p><p>In the following example, the <code>logger</code> is a plain JavaScript object that should\nbe returned “as is” when it’s looked up:</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"Registering Already Instantiated Objects"},{"content":"<h3 id=\"-factory-registrations-registering-singletons-vs-non-singletons\">Registering Singletons vs. Non-Singletons</h3><p>By default, registrations are treated as “singletons”.\nThis simply means that an instance will be created when it is first looked up,\nand this same instance will be cached and returned from subsequent lookups.</p><p>When you want fresh objects to be created for every lookup,\nregister your factories as non-singletons using the <code>singleton: false</code> option.</p><p>In the following example, the <code>Message</code> class is registered as a non-singleton:</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"Registering Singletons vs. Non-Singletons"},{"content":"<h2 id=\"-factory-injections\">Factory Injections</h2><p>Once a factory is registered, it can be “injected” where it is needed.</p><p>Factories can be injected into whole “types” of factories with <em>type injections</em>. For example:</p><p>As a result of this type injection,\nall factories of the type <code>route</code> will be instantiated with the property <code>logger</code> injected.\nThe value of <code>logger</code> will come from the factory named <code>logger:main</code>.</p><p>Routes in this example application can now access the injected logger:</p><p>Injections can also be made on a specific factory by using its full key:</p><p>In this case, the logger will only be injected on the index route.</p><p>Injections can be made onto any class that requires instantiation.\nThis includes all of Ember’s major framework classes, such as components, helpers, routes, and the router.</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"FACTORY INJECTIONS"},{"content":"<h3 id=\"-factory-injections-ad-hoc-injections\">Ad Hoc Injections</h3><p>Dependency injections can also be declared directly on Ember classes using <code>Ember.inject</code>.\nCurrently, <code>Ember.inject</code> supports injecting controllers (via <code>Ember.inject.controller</code>)\nand services (via <code>Ember.inject.service</code>).</p><p>The following code injects the <code>shopping-cart</code> service on the <code>cart-contents</code> component as the property <code>cart</code>:</p><p>If you’d like to inject a service with the same name as the property,\nsimply leave off the service name (the dasherized version of the name will be used):</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"Ad Hoc Injections"},{"content":"<h2 id=\"-factory-instance-lookups\">Factory Instance Lookups</h2><p>To fetch an instantiated factory from the running application you can call the\n<a href=\"http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup\"><code>lookup</code></a> method on an application instance. This method takes a string\nto identify a factory and returns the appropriate object.</p><p>The application instance is passed to Ember’s instance initializer hooks and it\nis added as the “owner” of each object that was instantiated by the application\ninstance.</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"FACTORY INSTANCE LOOKUPS"},{"content":"<h3 id=\"-factory-instance-lookups-using-an-application-instance-within-an-instance-initializer\">Using an Application Instance Within an Instance Initializer</h3><p>Instance initializers receive an application instance as an argument, providing\nan opportunity to look up an instance of a registered factory.</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"Using an Application Instance Within an Instance Initializer"},{"content":"<h3 id=\"-factory-instance-lookups-getting-an-application-instance-from-a-factory-instance\">Getting an Application Instance from a Factory Instance</h3><p><a href=\"http://emberjs.com/api/#method_getOwner\"><code>Ember.getOwner</code></a> will retrieve the application instance that “owns” an\nobject. This means that framework objects like components, helpers, and routes\ncan use <a href=\"http://emberjs.com/api/#method_getOwner\"><code>Ember.getOwner</code></a> to perform lookups through their application\ninstance at runtime.</p><p>For example, this component plays songs with different audio services based\non a song’s <code>audioType</code>.</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"Getting an Application Instance from a Factory Instance"},{"content":"<h2 id=\"-application-initializers\">Application Initializers</h2><p>Application initializers can be created with Ember CLI’s <code>initializer</code> generator:</p><p>Let’s customize the <code>shopping-cart</code> initializer to inject a <code>cart</code> property into all the routes in your application:</p>","link":"./EN/applications/initializers.html","spaLink":"#/EN/applications/initializers","title":"APPLICATION INITIALIZERS"},{"content":"<h2 id=\"-application-instance-initializers\">Application Instance Initializers</h2><p>Application instance initializers can be created with Ember CLI’s <code>instance-initializer</code> generator:</p><p>Let’s add some simple logging to indicate that the instance has booted:</p>","link":"./EN/applications/initializers.html","spaLink":"#/EN/applications/initializers","title":"APPLICATION INSTANCE INITIALIZERS"},{"content":"<h2 id=\"-specifying-initializer-order\">Specifying Initializer Order</h2><p>If you’d like to control the order in which initializers run, you can use the <code>before</code> and/or <code>after</code> options:</p><p>Note that ordering only applies to initializers of the same type (i.e. application or application instance).\nApplication initializers will always run before application instance initializers.</p>","link":"./EN/applications/initializers.html","spaLink":"#/EN/applications/initializers","title":"SPECIFYING INITIALIZER ORDER"},{"content":"<h2 id=\"-why-is-the-run-loop-useful\">Why is the run loop useful?</h2><p>Very often, batching similar work has benefits.\nWeb browsers do something quite similar by batching changes to the DOM.</p><p>Consider the following HTML snippet:</p><p>and executing the following code:</p><p>In this example, the sequence of code forced the browser to recalculate style, and relayout after each step.\nHowever, if we were able to batch similar jobs together,\nthe browser would have only needed to recalculate the style and layout once.</p><p>Interestingly, this pattern holds true for many other types of work.\nEssentially, batching similar work allows for better pipelining, and further optimization.</p><p>Let’s look at a similar example that is optimized in Ember, starting with a <code>User</code> object:</p><p>and a template to display its attributes:</p><p>If we execute the following code without the run loop:</p><p>We see that the browser will rerender the template twice.</p><p>However, if we have the run loop in the above code,\nthe browser will only rerender the template once the attributes have all been set.</p><p>In the above example with the run loop, since the user’s attributes end up at the same values as before execution,\nthe template will not even rerender!</p><p>It is of course possible to optimize these scenarios on a case-by-case basis,\nbut getting them for free is much nicer.\nUsing the run loop, we can apply these classes of optimizations not only for each scenario, but holistically app-wide.</p>","link":"./EN/applications/run-loop.html","spaLink":"#/EN/applications/run-loop","title":"WHY IS THE RUN LOOP USEFUL?"},{"content":"<h2 id=\"-how-does-the-run-loop-work-in-ember\">How does the Run Loop work in Ember?</h2><p>As mentioned earlier, we schedule work (in the form of function invocations) on queues,\nand these queues are processed to completion in priority order.</p><p>What are the queues, and what is their priority order?</p><p>Because the priority is first to last, the “sync” queue has higher priority than the “render” or “destroy” queue.</p>","link":"./EN/applications/run-loop.html","spaLink":"#/EN/applications/run-loop","title":"HOW DOES THE RUN LOOP WORK IN EMBER?"},{"content":"<h2 id=\"-what-happens-in-these-queues\">What happens in these queues?</h2><ul>\n<li>The <code>sync</code> queue contains binding synchronization jobs.</li>\n<li>The <code>actions</code> queue is the general work queue and will typically contain scheduled tasks e.g. promises.</li>\n<li>The <code>routerTransitions</code> queue contains transition jobs in the router.</li>\n<li>The <code>render</code> queue contains jobs meant for rendering, these will typically update the DOM.</li>\n<li>The <code>afterRender</code> queue contains jobs meant to be run after all previously scheduled render tasks are complete.\nThis is often good for 3rd-party DOM manipulation libraries,\nthat should only be run after an entire tree of DOM has been updated.</li>\n<li>The <code>destroy</code> queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.</li>\n</ul>","link":"./EN/applications/run-loop.html","spaLink":"#/EN/applications/run-loop","title":"WHAT HAPPENS IN THESE QUEUES?"},{"content":"<h2 id=\"-in-what-order-are-jobs-executed-on-the-queues\">In what order are jobs executed on the queues?</h2><p>The algorithm works this way:</p>","link":"./EN/applications/run-loop.html","spaLink":"#/EN/applications/run-loop","title":"IN WHAT ORDER ARE JOBS EXECUTED ON THE QUEUES?"},{"content":"<h2 id=\"-an-example-of-the-internals\">An example of the internals</h2><p>Rather than writing the higher level app code that internally invokes the various run loop scheduling functions,\nwe have stripped away the covers, and shown the raw run-loop interactions.</p><p>Working with this API directly is not common in most Ember apps,\nbut understanding this example will help you to understand the run-loops algorithm,\nwhich will make you a better Ember developer.</p>","link":"./EN/applications/run-loop.html","spaLink":"#/EN/applications/run-loop","title":"AN EXAMPLE OF THE INTERNALS"},{"content":"<h2 id=\"-how-do-i-tell-ember-to-start-a-run-loop\">How do I tell Ember to start a run loop?</h2><p>You should begin a run loop when the callback fires.</p><p>The <code>Ember.run</code> method can be used to create a runloop.\nIn this example, jQuery and <code>Ember.run</code> are used to handle a click event and run some Ember code.</p><p>This example uses the <code>=&gt;</code> function syntax, which is a [new ES2015 syntax for callback functions]\n(<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>)\nthat provides a lexical <code>this</code>.\nIf this syntax is new,\nthink of it as a function that has the same <code>this</code> as the context it is defined in.</p>","link":"./EN/applications/run-loop.html","spaLink":"#/EN/applications/run-loop","title":"HOW DO I TELL EMBER TO START A RUN LOOP?"},{"content":"<h2 id=\"-what-happens-if-i-forget-to-start-a-run-loop-in-an-async-handler\">What happens if I forget to start a run loop in an async handler?</h2><p>As mentioned above, you should wrap any non-Ember async callbacks in <code>Ember.run</code>.\nIf you don’t, Ember will try to approximate a beginning and end for you.\nConsider the following callback:</p><p>The runloop API calls that <em>schedule</em> work i.e. <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_schedule\"><code>run.schedule</code></a>, <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce\"><code>run.scheduleOnce</code></a>,\n<a href=\"http://emberjs.com/api/classes/Ember.run.html#method_once\"><code>run.once</code></a> have the property that they will approximate a runloop for you if one does not already exist.\nThese automatically created runloops we call <em>autoruns</em>.</p><p>Here is some pseudocode to describe what happens using the example above:</p><p>Although autoruns are convenient, they are suboptimal.\nThe current JS frame is allowed to end before the run loop is flushed,\nwhich sometimes means the browser will take the opportunity to do other things, like garbage collection.\nGC running in between data changing and DOM rerendering can cause visual lag and should be minimized.</p><p>Relying on autoruns is not a rigorous or efficient way to use the runloop.\nWrapping event handlers manually is preferred.</p>","link":"./EN/applications/run-loop.html","spaLink":"#/EN/applications/run-loop","title":"WHAT HAPPENS IF I FORGET TO START A RUN LOOP IN AN ASYNC HANDLER?"},{"content":"<h2 id=\"-how-is-runloop-behaviour-different-when-testing\">How is runloop behaviour different when testing?</h2><p>When your application is in <em>testing mode</em> then Ember will throw an error if you try to schedule work\nwithout an available runloop.</p><p>Autoruns are disabled in testing for several reasons:</p>","link":"./EN/applications/run-loop.html","spaLink":"#/EN/applications/run-loop","title":"HOW IS RUNLOOP BEHAVIOUR DIFFERENT WHEN TESTING?"},{"content":"<h2 id=\"-where-can-i-find-more-information\">Where can I find more information?</h2><p>Check out the <a href=\"http://emberjs.com/api/classes/Ember.run.html\">Ember.run</a> API documentation,\nas well as the <a href=\"https://github.com/ebryn/backburner.js/\">Backburner library</a> that powers the run loop.</p>","link":"./EN/applications/run-loop.html","spaLink":"#/EN/applications/run-loop","title":"WHERE CAN I FIND MORE INFORMATION?"},{"content":"<h3 id=\"-defining-services\">Defining Services</h3><p>Services can be generated using Ember CLI’s <code>service</code> generator.\nFor example, the following command will create the <code>ShoppingCart</code> service:</p><p>Services must extend the <a href=\"http://emberjs.com/api/classes/Ember.Service.html\"><code>Ember.Service</code></a> base class:</p><p>Like any Ember object, a service is initialized and can have properties and methods of its own.\nBelow the shopping cart service manages an items array that represents the items currently in the shopping cart.</p>","link":"./EN/applications/services.html","spaLink":"#/EN/applications/services","title":"Defining Services"},{"content":"<h3 id=\"-accessing-services\">Accessing Services</h3><p>To access a service,\nyou can inject it in any container-resolved object such as a component or another service using the <code>Ember.inject.service</code> function.\nThere are 2 ways to use this function.\nYou can either invoke it with no arguments, or you can pass it the registered name of the service.\nWhen no arguments are passed the services is loaded based in the name of the variable key.\nYou can load the shopping cart service with no arguments like below.</p><p>The other way to inject a service is to provide the name of the service as the argument.</p><p>This injects the shopping cart service into the component and makes it available as the <code>cart</code> property.</p><p>Injected properties are lazy loaded; meaning the service will not be instantiated until the property is explicitly called.\nTherefore you need to access services in your component using the <code>get</code> function otherwise you might get an undefined.</p><p>Once loaded, a service will persist until the application exits.</p><p>Below we add a remove action to the <code>cart-contents</code> component.\nNotice that below we access the <code>cart</code> service with a call to<code>this.get</code>.</p><p>Once injected into a component, a service can also be used in the template.\nNote <code>cart</code> being used below to get data from the cart.</p>","link":"./EN/applications/services.html","spaLink":"#/EN/applications/services","title":"Accessing Services"},{"content":"<h3 id=\"-customizing-the-element\">Customizing the Element</h3><p>To use a tag other than <code>div</code>, subclass <code>Ember.Component</code> and assign it\na <code>tagName</code> property. This property can be any valid HTML5 tag name as a\nstring.</p>","link":"./EN/components/customizing-a-components-element.html","spaLink":"#/EN/components/customizing-a-components-element","title":"Customizing the Element"},{"content":"<h3 id=\"-customizing-class-names\">Customizing Class Names</h3><p>You can also specify which class names are applied to the component’s\nelement by setting its <code>classNames</code> property to an array of strings:</p><p>If you want class names to be determined by properties of the component,\nyou can use class name bindings. If you bind to a Boolean property, the\nclass name will be added or removed depending on the value:</p><p>This component would render the following:</p><p>If <code>isUrgent</code> is changed to <code>false</code>, then the <code>is-urgent</code> class name will be removed.</p><p>By default, the name of the Boolean property is dasherized. You can customize the class name\napplied by delimiting it with a colon:</p><p>This would render this HTML:</p><p>Besides the custom class name for the value being <code>true</code>, you can also specify a class name which is used when the value is <code>false</code>:</p><p>This would render this HTML:</p><p>You can also specify a class which should only be added when the property is\n<code>false</code> by declaring <code>classNameBindings</code> like this:</p><p>This would render this HTML:</p><p>If the <code>isEnabled</code> property is set to <code>true</code>, no class name is added:</p><p>If the bound property’s value is a string, that value will be added as a class name without\nmodification:</p><p>This would render this HTML:</p>","link":"./EN/components/customizing-a-components-element.html","spaLink":"#/EN/components/customizing-a-components-element","title":"Customizing Class Names"},{"content":"<h3 id=\"-customizing-attributes\">Customizing Attributes</h3><p>You can bind attributes to the DOM element that represents a component\nby using <code>attributeBindings</code>:</p><p>You can also bind these attributes to differently named properties:</p><p>If the attribute is null, it won’t be rendered:</p><p>This would render this HTML when no title is passed to the component:</p><p>…and this HTML when a title of “Ember JS” is passed to the component:</p>","link":"./EN/components/customizing-a-components-element.html","spaLink":"#/EN/components/customizing-a-components-element","title":"Customizing Attributes"},{"content":"<h2 id=\"-defining-a-component-subclass\">Defining a Component Subclass</h2><p>Often times, your components will just encapsulate certain snippets of\nHandlebars templates that you find yourself using over and over. In\nthose cases, you do not need to write any JavaScript at all. Define\nthe Handlebars template as described above and use the component that is\ncreated.</p><p>If you need to customize the behavior of the component you’ll\nneed to define a subclass of <a href=\"http://emberjs.com/api/classes/Ember.Component.html\"><code>Ember.Component</code></a>. For example, you would\nneed a custom subclass if you wanted to change a component’s element,\nrespond to actions from the component’s template, or manually make\nchanges to the component’s element using JavaScript.</p><p>Ember knows which subclass powers a component based on its filename. For\nexample, if you have a component called <code>blog-post</code>, you would create a\nfile at <code>app/components/blog-post.js</code>. If your component was called\n<code>audio-player-controls</code>, the file name would be at\n<code>app/components/audio-player-controls.js</code>.</p>","link":"./EN/components/defining-a-component.html","spaLink":"#/EN/components/defining-a-component","title":"DEFINING A COMPONENT SUBCLASS"},{"content":"<h2 id=\"-dynamically-rendering-a-component\">Dynamically rendering a component</h2><p>The <a href=\"http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component\"><code>{{component}}</code></a> helper can be used to defer the selection of a component to\nrun time. The <code>{{my-component}}</code> syntax always renders the same component,\nwhile using the <code>{{component}}</code> helper allows choosing a component to render on\nthe fly. This is useful in cases where you want to interact with different\nexternal libraries depending on the data. Using the <code>{{component}}</code> helper would\nallow you to keep different logic well separated.</p><p>The first parameter of the helper is the name of a component to render, as a\nstring. So <code>{{component 'blog-post'}}</code> is the same as using <code>{{blog-post}}</code>.</p><p>The real value of <a href=\"http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component\"><code>{{component}}</code></a> comes from being able to dynamically pick\nthe component being rendered. Below is an example of using the helper as a\nmeans of choosing different components for displaying different kinds of posts:</p><p>When the parameter passed to <code>{{component}}</code> evaluates to <code>null</code> or <code>undefined</code>,\nthe helper renders nothing. When the parameter changes, the currently rendered\ncomponent is destroyed and the new component is created and brought in.</p><p>Picking different components to render in response to the data allows you to\nhave different template and behavior for each case. The <code>{{component}}</code> helper\nis a powerful tool for improving code modularity.</p>","link":"./EN/components/defining-a-component.html","spaLink":"#/EN/components/defining-a-component","title":"DYNAMICALLY RENDERING A COMPONENT"},{"content":"<h2 id=\"-sending-actions\">Sending Actions</h2><p>In some cases your component needs to define event handlers, perhaps to support\nvarious draggable behaviors. For example, a component may need to send an <code>id</code>\nwhen it receives a drop event:</p><p>You can define the component’s event handlers to manage the drop event.\nAnd if you need to, you may also stop events from bubbling, by using\n<code>return false;</code>.</p>","link":"./EN/components/handling-events.html","spaLink":"#/EN/components/handling-events","title":"SENDING ACTIONS"},{"content":"<h2 id=\"-event-names\">Event Names</h2><p>The event handling examples described above respond to one set of events.\nThe names of the built-in events are listed below. Custom events can be\nregistered by using <a href=\"http://emberjs.com/api/classes/Ember.Application.html#property_customEvents\">Ember.Application.customEvents</a>.</p><p>Touch events:</p><ul>\n<li><code>touchStart</code></li>\n<li><code>touchMove</code></li>\n<li><code>touchEnd</code></li>\n<li><code>touchCancel</code></li>\n</ul><p>Keyboard events</p><ul>\n<li><code>keyDown</code></li>\n<li><code>keyUp</code></li>\n<li><code>keyPress</code></li>\n</ul><p>Mouse events</p><ul>\n<li><code>mouseDown</code></li>\n<li><code>mouseUp</code></li>\n<li><code>contextMenu</code></li>\n<li><code>click</code></li>\n<li><code>doubleClick</code></li>\n<li><code>mouseMove</code></li>\n<li><code>focusIn</code></li>\n<li><code>focusOut</code></li>\n<li><code>mouseEnter</code></li>\n<li><code>mouseLeave</code></li>\n</ul><p>Form events:</p><ul>\n<li><code>submit</code></li>\n<li><code>change</code></li>\n<li><code>focusIn</code></li>\n<li><code>focusOut</code></li>\n<li><code>input</code></li>\n</ul><p>HTML5 drag and drop events:</p><ul>\n<li><code>dragStart</code></li>\n<li><code>drag</code></li>\n<li><code>dragEnter</code></li>\n<li><code>dragLeave</code></li>\n<li><code>dragOver</code></li>\n<li><code>dragEnd</code></li>\n<li><code>drop</code></li>\n</ul>","link":"./EN/components/handling-events.html","spaLink":"#/EN/components/handling-events","title":"EVENT NAMES"},{"content":"<h2 id=\"-positional-params\">Positional Params</h2><p>In addition to passing parameters in by name, you can pass them in by position.\nIn other words, you can invoke the above component example like this:</p><p>To set the component up to receive parameters this way, you need\nset the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams\"><code>positionalParams</code></a> attribute in your component class.</p><p>Then you can use the attributes in the component exactly as if they had been\npassed in like <code>{{blog-post title=post.title body=post.body}}</code>.</p><p>Notice that the <code>positionalParams</code> property is added to the class as a\nstatic variable via <code>reopenClass</code>. Positional params are always declared on\nthe component class and cannot be changed while an application runs.</p><p>Alternatively, you can accept an arbitrary number of parameters by\nsetting <code>positionalParams</code> to a string, e.g. <code>positionalParams: 'params'</code>. This\nwill allow you to access those params as an array like so:</p>","link":"./EN/components/passing-properties-to-a-component.html","spaLink":"#/EN/components/passing-properties-to-a-component","title":"POSITIONAL PARAMS"},{"content":"<h2 id=\"-order-of-lifecycle-hooks-called\">Order of Lifecycle Hooks Called</h2><p>Listed below are the component lifecycle hooks in order of execution according to render scenario.</p>","link":"./EN/components/the-component-lifecycle.html","spaLink":"#/EN/components/the-component-lifecycle","title":"ORDER OF LIFECYCLE HOOKS CALLED"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-initial-render\">On Initial Render</h3>","link":"./EN/components/the-component-lifecycle.html","spaLink":"#/EN/components/the-component-lifecycle","title":"On Initial Render"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-re-render\">On Re-Render</h3>","link":"./EN/components/the-component-lifecycle.html","spaLink":"#/EN/components/the-component-lifecycle","title":"On Re-Render"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-component-destroy\">On Component Destroy</h3>","link":"./EN/components/the-component-lifecycle.html","spaLink":"#/EN/components/the-component-lifecycle","title":"On Component Destroy"},{"content":"<h2 id=\"-lifecycle-hook-examples\">Lifecycle Hook Examples</h2><p>Below are some samples of ways to use lifecycle hooks within your components.</p>","link":"./EN/components/the-component-lifecycle.html","spaLink":"#/EN/components/the-component-lifecycle","title":"LIFECYCLE HOOK EXAMPLES"},{"content":"<h3 id=\"-lifecycle-hook-examples-resetting-presentation-state-on-attribute-change-with-didupdateattrs\">Resetting Presentation State on Attribute Change with <code>didUpdateAttrs</code></h3><p><code>didUpdateAttrs</code> runs when the attributes of a component have changed, but not when the component is re-rendered, via <code>component.rerender</code>,\n<code>component.set</code>, or changes in models or services used by the template.</p><p>A <code>didUpdateAttrs</code> is called prior to rerender, you can use this hook to execute code when specific attributes are changed.\nThis hook can be an effective alternative to an observer, as it will run prior to a re-render, but after an attribute has changed.</p><p>An example of this scenario in action is a profile editor component.  As you are editing one user, and the user attribute is changed,\nyou can use <code>didUpdateAttrs</code> to clear any error state that was built up from editing the previous user.</p><p><code>/app/templates/components/profile-editor.hbs</code></p><p><code>/app/components/profile-editor.js</code></p>","link":"./EN/components/the-component-lifecycle.html","spaLink":"#/EN/components/the-component-lifecycle","title":"Resetting Presentation State on Attribute Change with didUpdateAttrs"},{"content":"<h3 id=\"-lifecycle-hook-examples-formatting-component-attributes-with-didreceiveattrs\">Formatting Component Attributes with <code>didReceiveAttrs</code></h3><p><code>didReceiveAttrs</code> runs after <code>init</code>, and it also runs on subsequent re-renders, which is useful for logic that is the same on all renders.\nIt does not run when the re-rendered has been initiated internally.</p><p>Since the <code>didReceiveAttrs</code> hook is called every time a component’s attributes are updated whether on render or re-render,\nyou can use the hook to effectively act as an observer, ensuring code is executed every time an attribute changes.</p><p>For example, if you have a component that renders based on a json configuration, but you want to provide your component with the option of taking the config as a string,\nyou can leverage <code>didReceiveAttrs</code> to ensure the incoming config is always parsed.</p>","link":"./EN/components/the-component-lifecycle.html","spaLink":"#/EN/components/the-component-lifecycle","title":"Formatting Component Attributes with didReceiveAttrs"},{"content":"<h3 id=\"-lifecycle-hook-examples-integrating-with-third-party-libraries-with-didinsertelement\">Integrating with Third-Party Libraries with <code>didInsertElement</code></h3><p>Suppose you want to integrate your favorite date picker library into an Ember project.\nTypically, 3rd party JS/jQuery libraries require a DOM element to bind to.\nSo, where is the best place to initialize and attach the library?</p><p>After a component successfully renders its backing HTML element into the DOM, it will trigger its <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> hook.</p><p>Ember guarantees that, by the time <code>didInsertElement()</code> is called:</p><p>A component’s <a href=\"http://emberjs.com/api/classes/Ember.Component.html#method__\"><code>$()</code></a> method allows you to access the component’s DOM element by returning a JQuery element.\nFor example, you can set an attribute using jQuery’s <code>attr()</code> method:</p><p><a href=\"http://emberjs.com/api/classes/Ember.Component.html#method__\"><code>$()</code></a> will, by default, return a jQuery object for the component’s root element, but you can also target child elements within the component’s template by passing a selector:</p><p>Let’s initialize our date picker by overriding the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> method.</p><p>Date picker libraries usually attach to an <code>&lt;input&gt;</code> element, so we will use jQuery to find an appropriate input within our component’s template.</p><p><a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> is also a good place to\nattach event listeners. This is particularly useful for custom events or\nother browser events which do not have a <a href=\"http://guides.emberjs.com/v2.1.0/components/handling-events/#toc_event-names\">built-in event\nhandler</a>.</p><p>For example, perhaps you have some custom CSS animations trigger when the component\nis rendered and you want to handle some cleanup when it ends:</p><p>There are a few things to note about the <code>didInsertElement()</code> hook:</p><ul>\n<li>It is only triggered once when the component element is first rendered.</li>\n<li>In cases where you have components nested inside other components, the child component will always receive the <code>didInsertElement()</code> call before its parent does.</li>\n<li>Setting properties on the component in <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> triggers a re-render, and  for performance reasons,\nis not allowed.</li>\n<li>While <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> is technically an event that can be listened for using <a href=\"http://emberjs.com/api/classes/Ember.Component.html#method_on\"><code>on()</code></a>, it is encouraged to override the default method itself,\nparticularly when order of execution is important.</li>\n</ul>","link":"./EN/components/the-component-lifecycle.html","spaLink":"#/EN/components/the-component-lifecycle","title":"Integrating with Third-Party Libraries with didInsertElement"},{"content":"<h3 id=\"-lifecycle-hook-examples-making-updates-to-the-rendered-dom-with-didrender\">Making Updates to the Rendered DOM with <code>didRender</code></h3><p>The <code>didRender</code> hook is called during both render and re-render after the template has rendered and the DOM updated.\nYou can leverage this hook to perform post-processing on the DOM of a component after its been updated.</p><p>In this example, there is a list component that needs to scroll to a selected item when rendered.\nSince scrolling to a specific spot is based on positions within the DOM, we need to ensure that the list has been rendered before scrolling.\nWe can first render this list, and then set the scroll.</p><p>The component below takes a list of items and displays them on the screen.\nAdditionally, it takes an object representing which item is selected and will select and set the scroll top to that item.</p><p>When rendered the component will iterate through the given list and apply a class to the one that is selected.</p><p><code>/app/templates/components/selected-item-list.hbs</code></p><p>The scroll happens on <code>didRender</code>, where it will scroll the component’s container to the element with the selected class name.</p><p><code>/app/components/selected-item-list.js</code></p>","link":"./EN/components/the-component-lifecycle.html","spaLink":"#/EN/components/the-component-lifecycle","title":"Making Updates to the Rendered DOM with didRender"},{"content":"<h3 id=\"-lifecycle-hook-examples-detaching-and-tearing-down-component-elements-with-willdestroyelement\">Detaching and Tearing Down Component Elements with <code>willDestroyElement</code></h3><p>When a component detects that it is time to remove itself from the DOM, Ember will trigger the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_willDestroyElement\"><code>willDestroyElement()</code></a> method,\nallowing for any teardown logic to be performed.</p><p>Component teardown can be triggered by a number of different conditions.\nFor instance, the user may navigate to a different route, or a conditional Handlebars block surrounding your component may change:</p><p>Let’s use this hook to cleanup our date picker and event listener from above:</p>","link":"./EN/components/the-component-lifecycle.html","spaLink":"#/EN/components/the-component-lifecycle","title":"Detaching and Tearing Down Component Elements with willDestroyElement"},{"content":"<h2 id=\"-creating-the-component\">Creating the Component</h2><p>Let’s call our component <code>button-with-confirmation</code>. We can create it by\ntyping:</p><p>We’ll plan to use the component in a template something like this:</p><p>We’ll also want to use the component elsewhere, perhaps like this:</p>","link":"./EN/components/triggering-changes-with-actions.html","spaLink":"#/EN/components/triggering-changes-with-actions","title":"CREATING THE COMPONENT"},{"content":"<h2 id=\"-designing-the-action\">Designing the Action</h2><p>When implementing an action on a component, you need to break it down into two steps:</p><p>Let’s take it step by step.</p>","link":"./EN/components/triggering-changes-with-actions.html","spaLink":"#/EN/components/triggering-changes-with-actions","title":"DESIGNING THE ACTION"},{"content":"<h2 id=\"-implementing-the-action\">Implementing the Action</h2><p>In the parent component, let’s first define what we want to happen when the\nuser clicks the button and then confirms. In this case, we’ll find the user’s\naccount and delete it.</p><p>In Ember, each component can\nhave a property called <code>actions</code>, where you put functions that can be\n<a href=\"../../templates/actions/\">invoked by the user interacting with the component\nitself</a>, or by child components.</p><p>Let’s look at the parent component’s JavaScript file. In this example,\nimagine we have a parent component called <code>user-profile</code> that shows the\nuser’s profile to them.</p><p>We’ll implement an action on the parent component called\n<code>userDidDeleteAccount()</code> that, when called, gets a hypothetical <code>login</code>\n<a href=\"../../applications/services/\">service</a> and calls the service’s\n<code>deleteUser()</code> method.</p><p>Now we’ve implemented our action, but we have not told Ember when we\nwant this action to be triggered, which is the next step.</p>","link":"./EN/components/triggering-changes-with-actions.html","spaLink":"#/EN/components/triggering-changes-with-actions","title":"IMPLEMENTING THE ACTION"},{"content":"<h2 id=\"-designing-the-child-component\">Designing the Child Component</h2><p>Next, let’s implement the logic to confirm that the user wants to take\nthe action from the component:</p><p>The component template will have a button and a div that shows the confirmation dialog\nbased on the value of <code>confirmShown</code>.</p>","link":"./EN/components/triggering-changes-with-actions.html","spaLink":"#/EN/components/triggering-changes-with-actions","title":"DESIGNING THE CHILD COMPONENT"},{"content":"<h2 id=\"-passing-the-action-to-the-component\">Passing the Action to the Component</h2><p>Now we need to make it so that the <code>onConfirm()</code> event in the\n<code>button-with-confirmation()</code> component triggers the\n<code>userDidDeleteAccount()</code> action in the <code>user-profile</code> component.\nOne important thing to know about actions is that they’re functions\nyou can call, like any other method on your component.\nSo they can be passed from one component to another like this:</p><p>This snippet says “take the <code>userDidDeleteAccount</code> action from the\nparent and make it available on the child component as\n<code>onConfirm</code>.”</p><p>We can do a similar thing for our <code>send-message</code> component:</p><p>Now, we can use <code>onConfirm</code> in the child component to invoke the action on the\nparent:</p><p><code>this.get('onConfirm')</code> will return the function passed from the parent as the\nvalue of <code>onConfirm</code>, and the following <code>()</code> will invoke the function.</p><p>Like normal attributes, actions can be a property on the component; the\nonly difference is that the property is set to a function that knows how\nto trigger behavior.</p><p>That makes it easy to remember how to add an action to a component. It’s\nlike passing an attribute, but you use the <code>action</code> helper to pass\na function instead.</p><p>Actions in components allow you to\ndecouple an event happening from how it’s handled, leading to modular,\nmore reusable components.</p>","link":"./EN/components/triggering-changes-with-actions.html","spaLink":"#/EN/components/triggering-changes-with-actions","title":"PASSING THE ACTION TO THE COMPONENT"},{"content":"<h2 id=\"-handling-action-completion\">Handling Action Completion</h2><p>Often actions perform asynchronous tasks, such as making an ajax request to a server.\nSince actions are functions that can be passed in by a parent component, they are able to return values when called.\nThe most common scenario is for an action to return a promise so that the component can handle the action’s completion.</p><p>In our user <code>button-with-confirmation</code> component we want to leave the confirmation modal open until we know that the\noperation has completed successfully.\nThis is accomplished by expecting a promise to be returned from <code>onConfirm</code>.\nUpon resolution of the promise, we set a property used to indicate the visibility of the confirmation modal.</p>","link":"./EN/components/triggering-changes-with-actions.html","spaLink":"#/EN/components/triggering-changes-with-actions","title":"HANDLING ACTION COMPLETION"},{"content":"<h2 id=\"-passing-arguments\">Passing Arguments</h2><p>Sometimes the parent component invoking an action has some context needed for the action that the child component\ndoesn’t.\nFor these cases, actions passed to a component via the action helper may be invoked with arguments.\nFor example, we’ll update the <code>send-message</code> action to take a message type in addition to the message itself.\nSince the <code>button-with-confirmation</code> component doesn’t know or care about what type of message its collecting, we want\nto provide a message type from <code>send-message</code> when we define the action.</p><p>In this case, the code in <code>button-with-confirmation</code> does not change.\nIt will still invoke <code>onConfirm</code> with no arguments.\nThe action helper will add the arguments provided in the template to the call.</p><p>Action arguments curry, meaning that you can provide partial arguments to the action helper and provide the rest of the\narguments when you call the function within the component javascript file.\nFor example, our <code>button-with-confirmation</code> component will now <a href=\"../wrapping-content-in-a-component/\">yield</a> the content\nof the confirmation dialog to collect extra information to be sent along with the <code>onConfirm</code> action:</p><p>The <code>send-message</code> component provides an input as block content to the <code>button-with-confirmation</code> component, setting\n<code>confirmValue</code>.</p><p>Now when the <code>submitConfirm</code> action is invoked, we call it with the value provided by our yielded input.</p><p>This action will call our bound <code>sendMessage</code> function with both the message type we provided earlier, and the template\nand the message value provided in the component JavaScript.</p>","link":"./EN/components/triggering-changes-with-actions.html","spaLink":"#/EN/components/triggering-changes-with-actions","title":"PASSING ARGUMENTS"},{"content":"<h2 id=\"-invoking-actions-directly-on-component-collaborators\">Invoking Actions Directly on Component Collaborators</h2><p>Actions can be invoked on objects other than the component directly from the template.  For example, in our\n<code>send-message</code> component we might include a service that processes the <code>sendMessage</code> logic.</p><p>We can tell the action to invoke the <code>sendMessage</code> action directly on the messaging service with the <code>target</code> attribute.</p><p>By supplying the <code>target</code> attribute, the action helper will look to invoke the <code>sendMessage</code> action directly on the messaging\nservice, saving us from writing code on the component that just passes the action along to the service.</p>","link":"./EN/components/triggering-changes-with-actions.html","spaLink":"#/EN/components/triggering-changes-with-actions","title":"INVOKING ACTIONS DIRECTLY ON COMPONENT COLLABORATORS"},{"content":"<h2 id=\"-destructuring-objects-passed-as-action-arguments\">Destructuring Objects Passed as Action Arguments</h2><p>A component will often not know what information a parent needs to process an action, and will just pass all the\ninformation it has.\nFor example, our <code>user-profile</code> component is going to notify its parent, <code>system-preferences-editor</code>, that a\nuser’s account was deleted, and passes along with it the full user profile object.</p><p>All our <code>system-preferences-editor</code> component really needs to process a user deletion is an account ID.\nFor this case, the action helper provides the <code>value</code> attribute to allow a parent component to dig into the passed\nobject to pull out only what it needs.</p><p>Now when the <code>system-preferences-editor</code> handles the delete action, it receives only the user’s account <code>id</code> string.</p>","link":"./EN/components/triggering-changes-with-actions.html","spaLink":"#/EN/components/triggering-changes-with-actions","title":"DESTRUCTURING OBJECTS PASSED AS ACTION ARGUMENTS"},{"content":"<h2 id=\"-calling-actions-up-multiple-component-layers\">Calling Actions Up Multiple Component Layers</h2><p>When your components go multiple template layers deep, its common to need to handle an action several layers up the tree.\nUsing the action helper, it is possible to make actions defined in parent components available at the bottom layers of\nyour component tree without adding JavaScript code to the components in between.</p><p>For example, we want to take account deletion out of the <code>user-profile</code> component and handle deletion in its parent.\nIn our template in <code>user-profile.hbs</code>, we can change our action to call <code>deleteCurrentUser</code>,\nwhich will be defined on <code>system-preferences-editor</code>.</p><p>Note that <code>deleteCurrentUser</code> is not in quotes as was the case <a href=\"#toc_passing-the-action-to-the-component\">previously</a>\nwhen the action was local to <code>user-profile</code>.  When you pass an actual function reference (without quotes) to the action\nhelper, it will call the function from the component’s local context.</p><p>Alternately, when you pass a string to the action helper, Ember will attempt to call that function from the\ncomponent’s local <code>actions</code> object.</p><p>Here our <code>system-preferences-editor</code> template passes its <code>deleteUser</code> action into the <code>user-profile</code>\ncomponent’s local <code>deleteCurrentUser</code> property.</p><p>Now when you confirm deletion, the action goes straight to the <code>system-preferences-editor</code> to handle.</p>","link":"./EN/components/triggering-changes-with-actions.html","spaLink":"#/EN/components/triggering-changes-with-actions","title":"CALLING ACTIONS UP MULTIPLE COMPONENT LAYERS"},{"content":"<h2 id=\"-routing\">Routing</h2>","link":"./EN/configuring-ember/debugging.html","spaLink":"#/EN/configuring-ember/debugging","title":"ROUTING"},{"content":"<h2 id=\"-views-templates\">Views / Templates</h2>","link":"./EN/configuring-ember/debugging.html","spaLink":"#/EN/configuring-ember/debugging","title":"VIEWS / TEMPLATES"},{"content":"<h2 id=\"-controllers\">Controllers</h2>","link":"./EN/configuring-ember/debugging.html","spaLink":"#/EN/configuring-ember/debugging","title":"CONTROLLERS"},{"content":"<h2 id=\"-observers-binding\">Observers / Binding</h2>","link":"./EN/configuring-ember/debugging.html","spaLink":"#/EN/configuring-ember/debugging","title":"OBSERVERS / BINDING"},{"content":"<h2 id=\"-miscellaneous\">Miscellaneous</h2><p>This option logs all the lookups that are done to the console. Custom objects\nyou’ve created yourself have a tick, and Ember generated ones don’t.</p><p>It’s useful for understanding which objects Ember is finding when it does a lookup\nand which it is generating automatically for you.</p><p>If you are using imports with Ember, be sure to import the console:</p><p>There are times when dealing with promises that it seems like any errors\nare being ‘swallowed’, and not properly raised. This makes it extremely\ndifficult to track down where a given issue is coming from. Thankfully,\n<code>RSVP</code> has a solution for this problem built in.</p><p>You can provide an <code>onerror</code> function that will be called with the error\ndetails if any errors occur within your promise. This function can be anything,\nbut a common practice is to call <code>console.assert</code> to dump the error to the\nconsole.</p><p>Backburner has support for stitching the stacktraces together so that you can\ntrack down where an erroring <code>Ember.run.later</code> is being initiated from. Unfortunately,\nthis is quite slow and is not appropriate for production or even normal development.</p><p>To enable this mode you can set:</p>","link":"./EN/configuring-ember/debugging.html","spaLink":"#/EN/configuring-ember/debugging","title":"MISCELLANEOUS"},{"content":"<h2 id=\"-life-without-prototype-extension\">Life Without Prototype Extension</h2><p>In order for your application to behave correctly, you will need to\nmanually extend or create the objects that the native objects were\ncreating before.</p>","link":"./EN/configuring-ember/disabling-prototype-extensions.html","spaLink":"#/EN/configuring-ember/disabling-prototype-extensions","title":"LIFE WITHOUT PROTOTYPE EXTENSION"},{"content":"<h3 id=\"-life-without-prototype-extension-arrays\">Arrays</h3><p>Native arrays will no longer implement the functionality needed to\nobserve them. If you disable prototype extension and attempt to use\nnative arrays with things like a template’s <code>{{#each}}</code> helper, Ember.js\nwill have no way to detect changes to the array and the template will\nnot update as the underlying array changes.</p><p>Additionally, if you try to set the model of an\n<code>Ember.ArrayController</code> to a plain native array, it will raise an\nexception since it no longer implements the <code>Ember.Array</code> interface.</p><p>You can manually coerce a native array into an array that implements the\nrequired interfaces using the convenience method <code>Ember.A</code>:</p>","link":"./EN/configuring-ember/disabling-prototype-extensions.html","spaLink":"#/EN/configuring-ember/disabling-prototype-extensions","title":"Arrays"},{"content":"<h3 id=\"-life-without-prototype-extension-strings\">Strings</h3><p>Strings will no longer have the convenience methods described in the\n<a href=\"http://emberjs.com/api/classes/Ember.String.html\">Ember.String API reference.</a>. Instead,\nyou can use the similarly-named methods of the <code>Ember.String</code> object and\npass the string to use as the first parameter:</p>","link":"./EN/configuring-ember/disabling-prototype-extensions.html","spaLink":"#/EN/configuring-ember/disabling-prototype-extensions","title":"Strings"},{"content":"<h3 id=\"-life-without-prototype-extension-functions\">Functions</h3><p>The <a href=\"../../object-model/\">Object Model</a> section of the Guides describes\nhow to write computed properties, observers, and bindings without\nprototype extensions. Below you can learn about how to convert existing\ncode to the format now encouraged.</p><p>To annotate computed properties, use the <code>Ember.computed()</code> method to\nwrap the function:</p><p>Observers are annotated using <code>Ember.observer()</code>:</p><p>Evented functions are annotated using <code>Ember.on()</code>:</p>","link":"./EN/configuring-ember/disabling-prototype-extensions.html","spaLink":"#/EN/configuring-ember/disabling-prototype-extensions","title":"Functions"},{"content":"<h3 id=\"-changing-the-root-element\">Changing the Root Element</h3><p>By default, your application will render the <a href=\"../../routing/defining-your-routes/#toc_the-application-route\">application template</a>\nand attach it to the document’s <code>body</code> element.</p><p>You can tell the application to append the application template to a\ndifferent element by specifying its <code>rootElement</code> property:</p><p>This property can be specified as either an element or a\n<a href=\"http://api.jquery.com/category/selectors/\">jQuery-compatible selector\nstring</a>.</p>","link":"./EN/configuring-ember/embedding-applications.html","spaLink":"#/EN/configuring-ember/embedding-applications","title":"Changing the Root Element"},{"content":"<h3 id=\"-disabling-url-management\">Disabling URL Management</h3><p>You can prevent Ember from making changes to the URL by <a href=\"../specifying-url-type\">changing the\nrouter’s <code>location</code></a> to\n<code>none</code>:</p>","link":"./EN/configuring-ember/embedding-applications.html","spaLink":"#/EN/configuring-ember/embedding-applications","title":"Disabling URL Management"},{"content":"<h3 id=\"-specifying-a-root-url\">Specifying a Root URL</h3><p>If your Ember application is one of multiple web applications served from the same domain, it may be necessary to indicate to the router what the root URL for your Ember application is. By default, Ember will assume it is served from the root of your domain.</p><p>For example, if you wanted to serve your blogging application from <code>http://emberjs.com/blog/</code>, it would be necessary to specify a root URL of <code>/blog/</code>.</p><p>This can be achieved by setting the <code>rootURL</code> on the router:</p>","link":"./EN/configuring-ember/embedding-applications.html","spaLink":"#/EN/configuring-ember/embedding-applications","title":"Specifying a Root URL"},{"content":"<h2 id=\"-feature-life-cycle\">Feature Life-Cycle</h2><p>A newly-flagged feature is only available in canary builds and can be enabled\nat runtime through your project’s configuration file.</p><p>At the start of a beta cycle the Ember core team evaluates each new feature.\nFeatures deemed stable are made available in the next beta and enabled by default.</p><p>Beta features that receive negative feedback from the community are disabled in the next beta point\nrelease, and are not included in the next stable release. They may still be included\nin the next beta cycle if the issues/concerns are resolved.</p><p>Once the beta cycle has completed, the next stable release will include any features that\nwere enabled during the beta cycle. At this point the feature flags will be removed from\nthe canary and future beta branches, and the feature becomes part of the framework.</p>","link":"./EN/configuring-ember/feature-flags.html","spaLink":"#/EN/configuring-ember/feature-flags","title":"FEATURE LIFE-CYCLE"},{"content":"<h2 id=\"-flagging-details\">Flagging Details</h2><p>The flag status in the generated build is controlled by the <a href=\"https://github.com/emberjs/ember.js/blob/master/features.json\"><code>features.json</code></a>\nfile in the root of the Ember.js project. This file lists all new features and their current status.</p><p>A feature can have one of a three flags:</p><ul>\n<li><code>true</code> - The feature is <strong>present</strong> and <strong>enabled</strong>: the code behind the flag is always enabled in\nthe generated build.</li>\n<li><code>null</code> - The feature is <strong>present</strong> but <strong>disabled</strong> in the build output. It must be enabled at\nruntime.</li>\n<li><code>false</code> - The feature is entirely <strong>disabled</strong>: the code behind the flag is not present in\nthe generated build.</li>\n</ul><p>The process of removing the feature flags from the resulting build output is\nhandled by <a href=\"https://github.com/thomasboyt/defeatureify\"><code>defeatureify</code></a>.</p>","link":"./EN/configuring-ember/feature-flags.html","spaLink":"#/EN/configuring-ember/feature-flags","title":"FLAGGING DETAILS"},{"content":"<h2 id=\"-feature-listing-featuresmd\">Feature Listing (<a href=\"https://github.com/emberjs/ember.js/blob/master/FEATURES.md\"><code>FEATURES.md</code></a>)</h2><p>When a developer adds a new feature to the <code>canary</code> channel (i.e. the <code>master</code> branch on github), they\nalso add an entry to <a href=\"https://github.com/emberjs/ember.js/blob/master/FEATURES.md\"><code>FEATURES.md</code></a>\nexplaining what the feature does, and linking to their originating pull request.\nThis list is kept current, and reflects what is available in each channel\n(<code>release</code>, <code>beta</code>, and <code>canary</code>).</p>","link":"./EN/configuring-ember/feature-flags.html","spaLink":"#/EN/configuring-ember/feature-flags","title":"FEATURE LISTING (FEATURES.MD)"},{"content":"<h2 id=\"-enabling-at-runtime\">Enabling At Runtime</h2><p>When using the Ember.js canary or beta builds you can enable a “<strong>present</strong> but <strong>disabled</strong>“\nfeature by setting its flag value to <code>true</code> before your application boots:</p><p>For the truly ambitious developer, setting <code>ENV.EmberENV.ENABLE_ALL_FEATURES</code> to <code>true</code> will enable all\nexperimental features.</p>","link":"./EN/configuring-ember/feature-flags.html","spaLink":"#/EN/configuring-ember/feature-flags","title":"ENABLING AT RUNTIME"},{"content":"<h2 id=\"-filtering-deprecations\">Filtering Deprecations</h2><p>When your project has a lot of deprecations, you can start by filtering out deprecations that do not have to be addressed right away.  You\ncan use the <a href=\"http://emberjs.com/api/classes/Ember.Debug.html#method_registerDeprecationHandler\">deprecation handlers</a> API to check for what\nrelease a deprecated feature will be removed.  An example handler is shown below that filters out all deprecations that are not going away\nin release 2.0.0.</p><p>The deprecation handler API was released in Ember 2.1.  If you would like to leverage this API in a prior release of Ember you can install\nthe <a href=\"http://emberobserver.com/addons/ember-debug-handlers-polyfill\">ember-debug-handlers-polyfill</a> addon into your project.</p>","link":"./EN/configuring-ember/handling-deprecations.html","spaLink":"#/EN/configuring-ember/handling-deprecations","title":"FILTERING DEPRECATIONS"},{"content":"<h2 id=\"-deprecation-workflow\">Deprecation Workflow</h2><p>Once you’ve removed deprecations that you may not need to immediately address, you may still be left with many deprecations.  Also, your remaining\ndeprecations may only occur in very specific scenarios that are not obvious.  How then should you go about finding and fixing these?  This\nis where the <a href=\"http://emberobserver.com/addons/ember-cli-deprecation-workflow\">ember-cli-deprecation-workflow</a> addon can be extremely helpful.</p><p>Once installed, the addon works in 3 steps:</p>","link":"./EN/configuring-ember/handling-deprecations.html","spaLink":"#/EN/configuring-ember/handling-deprecations","title":"DEPRECATION WORKFLOW"},{"content":"<h3 id=\"-deprecation-workflow-1-gather-deprecations-into-one-source\">1. Gather deprecations into one source</h3><p>The ember-cli-deprecation-workflow addon provides a command that will collect deprecations from your console and generate JavaScript code listing\nits findings.</p><p>To collect deprecations, first run your in-browser test suite by starting your development server and navigating to <code>http://localhost:4200/tests</code>.  If your test suite isn’t fully covering your app’s functionality, you may also\nmanually exercise functionality within your app where needed.  Once you’ve exercised the app to your satisfaction, run the following command within\nyour browser console: <code>deprecationWorkflow.flushDeprecations()</code>.  This will print to the console JavaScript code, which you should then copy to a\nnew file in your project called <code>/config/deprecation-workflow.js</code></p><p><img width=\"675px\" title=\"Generated Deprecation Code from Browser Console\" src=\"../../images/guides/configuring-ember/handling-deprecations/generate-deprecation-code.png\"></p><p>Here’s an example of a deprecation-workflow file after generated from the console:</p><p>You might notice that you have a lot of duplicated messages in your workflow file, like the 3 messages in the above example that start with\n<code>Accessing 'template' in...</code>.  This is because some of the deprecation messages provide context to the specific deprecation, making them\ndifferent than the same deprecation in other parts of the app.  If you want to consolidate the\nduplication, you can use a simple regular expression with a wildcard (<code>.*</code>) for the part of the message that varies per instance.</p><p>Below is the same deprecation-workflow file as above, now with a regular expression on line 7 to remove some redundant messages. Note that the double quotes around <code>matchMessage</code> have also been replaced with forward slashes.</p><p>Rerun your test suite as you make updates to your workflow file and you should validate that your deprecations are gone. Once that is completed,\nyou can proceed with enhancing your application without the sea of deprecation warnings clouding your log.</p>","link":"./EN/configuring-ember/handling-deprecations.html","spaLink":"#/EN/configuring-ember/handling-deprecations","title":"1. Gather deprecations into one source"},{"content":"<h3 id=\"-deprecation-workflow-2-turn-on-a-deprecation\">2. “Turn on” a deprecation</h3><p>Once you have built your <code>deprecation-workflow.js</code> file and your deprecations are silenced, you can begin to work on deprecations one by one\nat your own leisure.  To find deprecations, you can change the handler value of that message to either <code>throw</code> or <code>log</code>.  Throw will\nthrow an actual exception when the deprecation is encountered, so that tests that use the deprecated feature will fail.  Choosing to log will\nsimply log a warning to the console as before.  These settings give you some flexibility on how you want to go about fixing the\ndeprecations.</p><p>The code below is the deprecation-workflow file with the first deprecation set to throw an exception on occurrence.  The image demonstrates what\nthat deprecation looks like when you run your tests.</p><p><img width=\"675px\" src=\"../../images/guides/configuring-ember/handling-deprecations/failed-test-from-deprecation.png\"></p>","link":"./EN/configuring-ember/handling-deprecations.html","spaLink":"#/EN/configuring-ember/handling-deprecations","title":"2. “Turn on” a deprecation"},{"content":"<h3 id=\"-deprecation-workflow-3-fix-and-repeat\">3. Fix and Repeat</h3><p>After fixing a deprecation and getting your scenarios working again, you might want to leave the deprecation message in the workflow file with the\nthrow handler enabled.  This will ensure you haven’t missed anything, and ensure no new deprecated calls of that type are introduced to your project.\nNext, it’s just a matter of going down the list, updating the handler, and fixing each remaining deprecation.</p><p>In the end, your deprecations can be fully turned on as “throw” and you should be able to use your application without error.  At this point, you can\ngo ahead and update your Ember version!  When you upgrade, be sure you remove the deprecations you’ve fixed from the deprecation workflow file,\nso that you can start the process over for the next release.</p>","link":"./EN/configuring-ember/handling-deprecations.html","spaLink":"#/EN/configuring-ember/handling-deprecations","title":"3. Fix and Repeat"},{"content":"<h2 id=\"-silencing-deprecation-warnings-during-compile\">Silencing Deprecation Warnings During Compile</h2><p>As you upgrade between releases, you might also notice that your terminal log begins to stream template-related deprecation warnings during the compile process, making\nit difficult to review your compilation logs.</p><p><img width=\"675px\" src=\"../../images/guides/configuring-ember/handling-deprecations/compile-deprecations.png\" title=\"Compile Deprecations Clouding Log\"></p><p>If you are using the deprecation workflow process above, you will likely prefer to gather these warnings during runtime execution instead.  The way to hide these\nwarnings during compile is to install the <a href=\"http://emberobserver.com/addons/ember-cli-template-lint\">ember-cli-template-lint</a> addon.  It suppresses\ntemplate deprecation warnings during compile in favor of showing them in the browser console during test suite execution or application usage.</p>","link":"./EN/configuring-ember/handling-deprecations.html","spaLink":"#/EN/configuring-ember/handling-deprecations","title":"SILENCING DEPRECATION WARNINGS DURING COMPILE"},{"content":"<h2 id=\"-deprecation-handling-in-ember-inspector\">Deprecation Handling in Ember Inspector</h2><p>Ember Inspector also provides deprecation handling capability.  It can work complimentary to ember-cli-deprecation-workflow.  As you unsilence deprecations to\nfix them, the inspector can allow you to more quickly find where in your code a deprecation occurs when you run into it at runtime, reducing the amount of\nstack trace browsing you have to do.  For more information on using deprecation handling in Ember Inspector, see its <a href=\"../../ember-inspector/deprecations/\">guides section</a>.</p>","link":"./EN/configuring-ember/handling-deprecations.html","spaLink":"#/EN/configuring-ember/handling-deprecations","title":"DEPRECATION HANDLING IN EMBER INSPECTOR"},{"content":"<h2 id=\"-history\">history</h2><p>When using <code>history</code>, Ember uses the browser’s\n<a href=\"http://caniuse.com/history\">history</a> API to produce URLs with a structure like\n<code>/posts/new</code>.</p><p>Given the following router, entering <code>/posts/new</code> will take you to the <code>posts.new</code>\nroute.</p><p>Keep in mind that your server must serve the Ember app from all the URLs defined in your\n<code>Router.map</code> function. In other words, if your user directly navigates to\n<code>/posts/new</code>, your server must be configured to serve your Ember app in\nresponse.</p>","link":"./EN/configuring-ember/specifying-url-type.html","spaLink":"#/EN/configuring-ember/specifying-url-type","title":"HISTORY"},{"content":"<h2 id=\"-hash\">hash</h2><p>The <code>hash</code> option uses the URL’s anchor to load the starting state of your\napplication and will keep it in sync as you move around. At present, this relies\non a <a href=\"http://caniuse.com/hashchange\">hashchange</a> event existing in the browser.</p><p>In the router example above, entering <code>/#/posts/new</code> will take you to the <code>posts.new</code>\nroute.</p>","link":"./EN/configuring-ember/specifying-url-type.html","spaLink":"#/EN/configuring-ember/specifying-url-type","title":"HASH"},{"content":"<h2 id=\"-none\">none</h2><p>Finally, if you don’t want the browser’s URL to interact with your application\nat all, you can disable the location API entirely by setting <code>ENV.locationType</code>\nto <code>none</code>. This is useful for\ntesting, or when you don’t want Ember to muck with the URL (for example when you embed your\napplication in a larger page).</p>","link":"./EN/configuring-ember/specifying-url-type.html","spaLink":"#/EN/configuring-ember/specifying-url-type","title":"NONE"},{"content":"<h3 id=\"-bug-fixes\">Bug Fixes</h3><p>Urgent bugfixes are bugfixes that need to be applied to the existing\nrelease branch. If possible, they should be made on master and prefixed\nwith [BUGFIX release].</p><p>Beta bugfixes are bugfixes that need to be applied to the beta branch.\nIf possible, they should be made on master and tagged with [BUGFIX\nbeta].</p><p>Security fixes need to be applied to the beta branch, the current\nrelease branch, and the previous tag. If possible, they should be made\non master and tagged with [SECURITY].</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Bug Fixes"},{"content":"<h3 id=\"-features\">Features</h3><p>Features must always be wrapped in a feature flag. Tests for the feature\nmust also be wrapped in a feature flag.</p><p>Because the build-tools will process feature-flags, flags must use\nprecisely this format. We are choosing conditionals rather than a block\nform because functions change the surrounding scope and may introduce\nproblems with early return.</p><p>Tests will always run with all features on, so make sure that any tests\nfor the feature are passing against the current state of the feature.</p><p>Commits related to a specific feature should include  a prefix like\n[FEATURE htmlbars]. This will allow us to quickly identify all commits\nfor a specific feature in the future. Features will never be applied to\nbeta or release branches. Once a beta or release branch has been cut, it\ncontains all of the new features it will ever have.</p><p>If a feature has made it into beta or release, and you make a commit to\nmaster that fixes a bug in the feature, treat it like a bugfix as\ndescribed above.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Features"},{"content":"<h3 id=\"-builds\">Builds</h3><p>The Canary build, which is based off master, will include all features,\nguarded by the conditionals in the original source. This means that\nusers of the canary build can enable whatever features they want by\nenabling them before creating their Ember.Application.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Builds"},{"content":"<h3 id=\"-featuresjson\"><code>features.json</code></h3><p>The root of the repository will contain a features.json file, which will\ncontain a list of features that should be enabled for beta or release\nbuilds.</p><p>This file is populated when branching, and may not gain additional\nfeatures after the original branch. It may remove features.</p><p>The build process will remove any features not included in the list, and\nremove the conditionals for features in the list.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"features.json"},{"content":"<h3 id=\"-travis-testing\">Travis Testing</h3><p>For a new PR:</p><p>For a new commit to master:</p><p>The idea is that new commits should be submitted as PRs to ensure they\napply cleanly, and once the merge button is pressed, Travis will apply\nthem to the right branches.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Travis Testing"},{"content":"<h3 id=\"-gono-go-process\">Go/No-Go Process</h3><p>Every six weeks, the core team goes through the following process.</p><p>All remaining features on the beta branch are vetted for readiness. If\nany feature isn’t ready, it is removed from features.json.</p><p>Once this is done, the beta branch is tagged and merged into release.</p><p>All features on the master branch are vetted for readiness. In order for\na feature to be considered “ready” at this stage, it must be ready as-is\nwith no blockers. Features are a no-go even if they are close and\nadditional work on the beta branch would make it ready.</p><p>Because this process happens every six weeks, there will be another\nopportunity for a feature to make it soon enough.</p><p>Once this is done, the master branch is merged into beta. A\n<code>features.json</code> file is added with the features that are ready.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Go/No-Go Process"},{"content":"<h3 id=\"-beta-releases\">Beta Releases</h3><p>Every week, we repeat the Go/No-Go process for the features that remain\non the beta branch. Any feature that has become unready is removed from\nthe features.json.</p><p>Once this is done, a Beta release is tagged and pushed.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Beta Releases"},{"content":"<h1 id=\"main-repositories\">Main Repositories</h1><p><strong>Ember.js</strong> - The main repository for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/ember.js\"></a><a href=\"https://github.com/emberjs/ember.js\">https://github.com/emberjs/ember.js</a></li>\n</ul><p><strong>Ember Data</strong> - A data persistence library for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/data\"></a><a href=\"https://github.com/emberjs/data\">https://github.com/emberjs/data</a></li>\n</ul><p><strong>Ember Website</strong> - Source for <a href=\"http://emberjs.com\"></a><a href=\"http://emberjs.com\">http://emberjs.com</a></p><ul>\n<li><a href=\"https://github.com/emberjs/website\"></a><a href=\"https://github.com/emberjs/website\">https://github.com/emberjs/website</a></li>\n</ul><p><strong>Ember Guides</strong> - Source for <a href=\"http://guides.emberjs.com\"></a><a href=\"http://guides.emberjs.com\">http://guides.emberjs.com</a> which you are currently reading.</p><ul>\n<li><a href=\"https://github.com/emberjs/guides\"></a><a href=\"https://github.com/emberjs/guides\">https://github.com/emberjs/guides</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"MAIN REPOSITORIES"},{"content":"<h1 id=\"libraries-used-by-ember\">Libraries Used By Ember</h1><p>These libraries are part of the Ember.js source, but development of them takes place in a separate repository.</p>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"LIBRARIES USED BY EMBER"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-metallibvendorbackburnerjs\"><code>packages/ember-metal/lib/vendor/backburner.js</code></h2><ul>\n<li><strong>backburner.js</strong> - Implements the Ember run loop.</li>\n<li><a href=\"https://github.com/ebryn/backburner.js\"></a><a href=\"https://github.com/ebryn/backburner.js\">https://github.com/ebryn/backburner.js</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"PACKAGES/EMBER-METAL/LIB/VENDOR/BACKBURNER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorroute-recognizerjs\"><code>packages/ember-routing/lib/vendor/route-recognizer.js</code></h2><ul>\n<li><strong>route-recognizer.js</strong> - A lightweight JavaScript library that matches paths against registered routes.</li>\n<li><a href=\"https://github.com/tildeio/route-recognizer\"></a><a href=\"https://github.com/tildeio/route-recognizer\">https://github.com/tildeio/route-recognizer</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTE-RECOGNIZER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorrouterjs\"><code>packages/ember-routing/lib/vendor/router.js</code></h2><ul>\n<li><strong>router.js</strong> - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.</li>\n<li><a href=\"https://github.com/tildeio/router.js\"></a><a href=\"https://github.com/tildeio/router.js\">https://github.com/tildeio/router.js</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesmetamorph\"><code>packages/metamorph</code></h2><ul>\n<li><strong>Metamorph.js</strong> - Used by Ember for databinding handlebars templates</li>\n<li><a href=\"https://github.com/tomhuda/metamorph.js\"></a><a href=\"https://github.com/tomhuda/metamorph.js\">https://github.com/tomhuda/metamorph.js</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"PACKAGES/METAMORPH"},{"content":"<h2 id=\"libraries-used-by-ember-packagesrsvp\"><code>packages/rsvp</code></h2><ul>\n<li><strong>RSVP.js</strong> - Implementation of the of Promises/A+ spec used by Ember.</li>\n<li><a href=\"https://github.com/tildeio/rsvp.js\"></a><a href=\"https://github.com/tildeio/rsvp.js\">https://github.com/tildeio/rsvp.js</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"PACKAGES/RSVP"},{"content":"<h2 id=\"-addons\">Addons</h2><p>Ember Addons are installed using NPM (e.g. <code>npm install --save-dev ember-cli-sass</code>). Addons may bring in other dependencies by modifying your project’s <code>bower.json</code> file automatically.</p><p>You can find listings of addons on <a href=\"http://emberobserver.com\">Ember Observer</a>.</p>","link":"./JP/addons-and-dependencies/managing-dependencies.ja-JP.html","spaLink":"#/JP/addons-and-dependencies/managing-dependencies.ja-JP","title":"ADDONS"},{"content":"<h2 id=\"-bower\">Bower</h2><p>Ember CLI uses the <a href=\"http://bower.io\">Bower</a> package manager, making it easy to keep your front-end dependencies up to date. The Bower configuration file, <code>bower.json</code>, is located at the root of your Ember CLI project, and lists the dependencies for your project. Executing <code>bower install</code> will install all of the dependencies listed in <code>bower.json</code> in one step.</p><p>Ember CLI watches <code>bower.json</code> for changes. Thus it reloads your app if you install new dependencies via <code>bower install &lt;dependencies&gt; --save</code>.</p>","link":"./JP/addons-and-dependencies/managing-dependencies.ja-JP.html","spaLink":"#/JP/addons-and-dependencies/managing-dependencies.ja-JP","title":"BOWER"},{"content":"<h2 id=\"-other-assets\">Other assets</h2><p>Assets not available as an addon or Bower package should be placed in the <code>vendor</code> folder in your project.</p>","link":"./JP/addons-and-dependencies/managing-dependencies.ja-JP.html","spaLink":"#/JP/addons-and-dependencies/managing-dependencies.ja-JP","title":"OTHER ASSETS"},{"content":"<h2 id=\"-compiling-assets\">Compiling Assets</h2><p>When you’re using dependencies that are not included in an addon, you will have to instruct Ember CLI to include your assets in the build. This is done using the asset manifest file <code>ember-cli-build.js</code>. You should only try to import assets located in the <code>bower_components</code> and <code>vendor</code> folders.</p>","link":"./JP/addons-and-dependencies/managing-dependencies.ja-JP.html","spaLink":"#/JP/addons-and-dependencies/managing-dependencies.ja-JP","title":"COMPILING ASSETS"},{"content":"<h3 id=\"-compiling-assets-globals-provided-by-javascript-assets\">Globals provided by Javascript assets</h3><p>The globals provided by some assets (like <code>moment</code> in the below example) can be used in your application without the need to <code>import</code> them. Provide the asset path as the first and only argument.</p><p>```ember-cli-build.js app.import(‘bower_components/moment/moment.js’);</p><p>You can now <code>import</code> them in your app. (e.g. <code>import { raw as icAjaxRaw } from 'ic-ajax';</code>)</p>","link":"./JP/addons-and-dependencies/managing-dependencies.ja-JP.html","spaLink":"#/JP/addons-and-dependencies/managing-dependencies.ja-JP","title":"Globals provided by Javascript assets"},{"content":"<h3 id=\"-compiling-assets-environment-specific-assets\">Environment Specific Assets</h3><p>If you need to use different assets in different environments, specify an object as the first parameter. That object’s key should be the environment name, and the value should be the asset to use in that environment.</p><p>```ember-cli-build.js app.import({ development: ‘bower_components/ember/ember.js’, production: ‘bower_components/ember/ember.prod.js’ });</p>","link":"./JP/addons-and-dependencies/managing-dependencies.ja-JP.html","spaLink":"#/JP/addons-and-dependencies/managing-dependencies.ja-JP","title":"Environment Specific Assets"},{"content":"<h3 id=\"-compiling-assets-css\">CSS</h3><p>Provide the asset path as the first argument:</p><p>```ember-cli-build.js app.import(‘bower_components/foundation/css/foundation.css’);</p><p>This example would create the font file in <code>dist/font-awesome/fonts/fontawesome-webfont.ttf</code>.</p><p>You can also optionally tell <code>import()</code> to place the file at a different path. The following example will copy the file to <code>dist/assets/fontawesome-webfont.ttf</code>.</p><p>```ember-cli-build.js app.import(‘bower_components/font-awesome/fonts/fontawesome-webfont.ttf’, { destDir: ‘assets’ });</p>","link":"./JP/addons-and-dependencies/managing-dependencies.ja-JP.html","spaLink":"#/JP/addons-and-dependencies/managing-dependencies.ja-JP","title":"CSS"},{"content":"<h2 id=\"-factory-registrations\">Factory Registrations</h2><p>A factory can represent any part of your application, like a <em>route</em>, <em>template</em>, or custom class. Every factory is registered with a particular key. For example, the index template is registered with the key <code>template:index</code>, and the application route is registered with the key <code>route:application</code>.</p><p>Registration keys have two segments split by a colon (<code>:</code>). The first segment is the framework factory type, and the second is the name of the particular factory. Hence, the <code>index</code> template has the key <code>template:index</code>. Ember has several built-in factory types, such as <code>service</code>, <code>route</code>, <code>template</code>, and <code>component</code>.</p><p>You can create your own factory type by simply registering a factory with the new type. For example, to create a <code>user</code> type, you’d simply register your factory with <code>application.register('user:user-to-register')</code>.</p><p>Factory registrations must be performed either in application or application instance initializers (with the former being much more common).</p><p>For example, an application initializer could register a <code>Logger</code> factory with the key <code>logger:main</code>:</p><p>```app/initializers/logger.js export function initialize(application) { var Logger = Ember.Object.extend({ log(m) { console.log(m); } });</p><p>application.register(‘logger:main’, Logger); }</p><p>export default { name: ‘logger’, initialize: initialize };</p>","link":"./JP/applications/dependency-injection.ja-JP.html","spaLink":"#/JP/applications/dependency-injection.ja-JP","title":"FACTORY REGISTRATIONS"},{"content":"<h3 id=\"-factory-registrations-registering-singletons-vs-non-singletons\">Registering Singletons vs. Non-Singletons</h3><p>By default, registrations are treated as “singletons”. This simply means that an instance will be created when it is first looked up, and this same instance will be cached and returned from subsequent lookups.</p><p>When you want fresh objects to be created for every lookup, register your factories as non-singletons using the <code>singleton: false</code> option.</p><p>In the following example, the <code>Message</code> class is registered as a non-singleton:</p><p>```app/initializers/notification.js export function initialize(application) { var Message = Ember.Object.extend({ text: ‘’ });</p><p>application.register(‘notification:message’, Message, { singleton: false }); }</p><p>export default { name: ‘notification’, initialize: initialize };</p><p>As a result of this type injection, all factories of the type <code>route</code> will be instantiated with the property <code>logger</code> injected. The value of <code>logger</code> will come from the factory named <code>logger:main</code>.</p><p>Routes in this example application can now access the injected logger:</p><p>```app/routes/index.js export default Ember.Route.extend({ activate() { // The logger property is injected into all routes this.get(‘logger’).log(‘Entered the index route!’); } });</p><p>In this case, the logger will only be injected on the index route.</p><p>Injections can be made onto any class that requires instantiation. This includes all of Ember’s major framework classes, such as components, helpers, routes, and the router.</p>","link":"./JP/applications/dependency-injection.ja-JP.html","spaLink":"#/JP/applications/dependency-injection.ja-JP","title":"Registering Singletons vs. Non-Singletons"},{"content":"<h3 id=\"-factory-registrations-ad-hoc-injections\">Ad Hoc Injections</h3><p>Dependency injections can also be declared directly on Ember classes using <code>Ember.inject</code>. Currently, <code>Ember.inject</code> supports injecting controllers (via <code>Ember.inject.controller</code>) and services (via <code>Ember.inject.service</code>).</p><p>The following code injects the <code>shopping-cart</code> service on the <code>cart-contents</code> component as the property <code>cart</code>:</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ cart: Ember.inject.service(‘shopping-cart’) });</p>","link":"./JP/applications/dependency-injection.ja-JP.html","spaLink":"#/JP/applications/dependency-injection.ja-JP","title":"Ad Hoc Injections"},{"content":"<h2 id=\"-factory-instance-lookups\">Factory Instance Lookups</h2><p>To fetch an instantiated factory from the running application you can call the <a href=\"http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup\"><code>lookup</code></a> method on an application instance. This method takes a string to identify a factory and returns the appropriate object.</p><p>The application instance is passed to Ember’s instance initializer hooks and it is added as the “owner” of each object that was instantiated by the application instance.</p>","link":"./JP/applications/dependency-injection.ja-JP.html","spaLink":"#/JP/applications/dependency-injection.ja-JP","title":"FACTORY INSTANCE LOOKUPS"},{"content":"<h3 id=\"-factory-instance-lookups-using-an-application-instance-within-an-instance-initializer\">Using an Application Instance Within an Instance Initializer</h3><p>Instance initializers receive an application instance as an argument, providing an opportunity to look up an instance of a registered factory.</p><p>```app/instance-initializers/logger.js export function initialize(applicationInstance) { let logger = applicationInstance.lookup(‘logger:main’);</p><p>logger.log(‘Hello from the instance initializer!’); }</p><p>export default { name: ‘logger’, initialize: initialize };</p>","link":"./JP/applications/dependency-injection.ja-JP.html","spaLink":"#/JP/applications/dependency-injection.ja-JP","title":"Using an Application Instance Within an Instance Initializer"},{"content":"<h2 id=\"-application-initializers\">Application Initializers</h2><p>Application initializers can be created with Ember CLI’s <code>initializer</code> generator:</p><p>Let’s customize the <code>shopping-cart</code> initializer to inject a <code>cart</code> property into all the routes in your application:</p><p>```app/initializers/shopping-cart.js export function initialize(application) { application.inject(‘route’, ‘cart’, ‘service:shopping-cart’); };</p><p>export default { name: ‘shopping-cart’, initialize: initialize };</p><p>Let’s add some simple logging to indicate that the instance has booted:</p><p>```app/instance-initializers/logger.js export function initialize(applicationInstance) { var logger = applicationInstance.lookup(‘logger:main’); logger.log(‘Hello from the instance initializer!’); }</p><p>export default { name: ‘logger’, initialize: initialize };</p><p>```app/initializers/websocket-init.js export function initialize(application) { // … your code … };</p><p>export default { name: ‘websocketInit’, after: ‘configReader’, initialize: initialize }; ```</p><p>Note that ordering only applies to initializers of the same type (i.e. application or application instance). Application initializers will always run before application instance initializers.</p>","link":"./JP/applications/initializers.ja-JP.html","spaLink":"#/JP/applications/initializers.ja-JP","title":"APPLICATION INITIALIZERS"},{"content":"<h2 id=\"-why-is-the-run-loop-useful\">Why is the run loop useful?</h2><p>Very often, batching similar work has benefits. Web browsers do something quite similar by batching changes to the DOM.</p><p>Consider the following HTML snippet:</p><p>and executing the following code:</p><p>In this example, the sequence of code forced the browser to recalculate style, and relayout after each step. However, if we were able to batch similar jobs together, the browser would have only needed to recalculate the style and layout once.</p><p>Interestingly, this pattern holds true for many other types of work. Essentially, batching similar work allows for better pipelining, and further optimization.</p><p>Let’s look at a similar example that is optimized in Ember, starting with a <code>User</code> object:</p><p>and a template to display its attributes:</p><p>If we execute the following code without the run loop:</p><p>We see that the browser will rerender the template twice.</p><p>However, if we have the run loop in the above code, the browser will only rerender the template once the attributes have all been set.</p><p>In the above example with the run loop, since the user’s attributes end up at the same values as before execution, the template will not even rerender!</p><p>It is of course possible to optimize these scenarios on a case-by-case basis, but getting them for free is much nicer. Using the run loop, we can apply these classes of optimizations not only for each scenario, but holistically app-wide.</p>","link":"./JP/applications/run-loop.ja-JP.html","spaLink":"#/JP/applications/run-loop.ja-JP","title":"WHY IS THE RUN LOOP USEFUL?"},{"content":"<h2 id=\"-how-does-the-run-loop-work-in-ember\">How does the Run Loop work in Ember?</h2><p>As mentioned earlier, we schedule work (in the form of function invocations) on queues, and these queues are processed to completion in priority order.</p><p>What are the queues, and what is their priority order?</p><p>Because the priority is first to last, the “sync” queue has higher priority than the “render” or “destroy” queue.</p>","link":"./JP/applications/run-loop.ja-JP.html","spaLink":"#/JP/applications/run-loop.ja-JP","title":"HOW DOES THE RUN LOOP WORK IN EMBER?"},{"content":"<h2 id=\"-what-happens-in-these-queues\">What happens in these queues?</h2><ul>\n<li>The <code>sync</code> queue contains binding synchronization jobs.</li>\n<li>The <code>actions</code> queue is the general work queue and will typically contain scheduled tasks e.g. promises.</li>\n<li>The <code>routerTransitions</code> queue contains transition jobs in the router.</li>\n<li>The <code>render</code> queue contains jobs meant for rendering, these will typically update the DOM.</li>\n<li>The <code>afterRender</code> queue contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated.</li>\n<li>The <code>destroy</code> queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.</li>\n</ul>","link":"./JP/applications/run-loop.ja-JP.html","spaLink":"#/JP/applications/run-loop.ja-JP","title":"WHAT HAPPENS IN THESE QUEUES?"},{"content":"<h2 id=\"-in-what-order-are-jobs-executed-on-the-queues\">In what order are jobs executed on the queues?</h2><p>The algorithm works this way:</p>","link":"./JP/applications/run-loop.ja-JP.html","spaLink":"#/JP/applications/run-loop.ja-JP","title":"IN WHAT ORDER ARE JOBS EXECUTED ON THE QUEUES?"},{"content":"<h2 id=\"-an-example-of-the-internals\">An example of the internals</h2><p>Rather than writing the higher level app code that internally invokes the various run loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.</p><p>Working with this API directly is not common in most Ember apps, but understanding this example will help you to understand the run-loops algorithm, which will make you a better Ember developer. <iframe src=\"https://s3.amazonaws.com/emberjs.com/run-loop-guide/index.html\" width=\"678\" height=\"410\" style=\"border:1px solid rgb(170, 170, 170);margin-bottom:1.5em;\"></iframe></p>","link":"./JP/applications/run-loop.ja-JP.html","spaLink":"#/JP/applications/run-loop.ja-JP","title":"AN EXAMPLE OF THE INTERNALS"},{"content":"<h2 id=\"-how-do-i-tell-ember-to-start-a-run-loop\">How do I tell Ember to start a run loop?</h2><p>You should begin a run loop when the callback fires.</p><p>The <code>Ember.run</code> method can be used to create a runloop. In this example, jQuery and <code>Ember.run</code> are used to handle a click event and run some Ember code.</p><p>This example uses the <code>=&gt;</code> function syntax, which is a [new ES2015 syntax for callback functions] (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>) that provides a lexical <code>this</code>. If this syntax is new, think of it as a function that has the same <code>this</code> as the context it is defined in.</p>","link":"./JP/applications/run-loop.ja-JP.html","spaLink":"#/JP/applications/run-loop.ja-JP","title":"HOW DO I TELL EMBER TO START A RUN LOOP?"},{"content":"<h2 id=\"-what-happens-if-i-forget-to-start-a-run-loop-in-an-async-handler\">What happens if I forget to start a run loop in an async handler?</h2><p>As mentioned above, you should wrap any non-Ember async callbacks in <code>Ember.run</code>. If you don’t, Ember will try to approximate a beginning and end for you. Consider the following callback:</p><p>The runloop API calls that <em>schedule</em> work i.e. <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_schedule\"><code>run.schedule</code></a>, <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce\"><code>run.scheduleOnce</code></a>, <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_once\"><code>run.once</code></a> have the property that they will approximate a runloop for you if one does not already exist. These automatically created runloops we call <em>autoruns</em>.</p><p>Here is some pseudocode to describe what happens using the example above:</p><p>Although autoruns are convenient, they are suboptimal. The current JS frame is allowed to end before the run loop is flushed, which sometimes means the browser will take the opportunity to do other things, like garbage collection. GC running in between data changing and DOM rerendering can cause visual lag and should be minimized.</p><p>Relying on autoruns is not a rigorous or efficient way to use the runloop. Wrapping event handlers manually is preferred.</p>","link":"./JP/applications/run-loop.ja-JP.html","spaLink":"#/JP/applications/run-loop.ja-JP","title":"WHAT HAPPENS IF I FORGET TO START A RUN LOOP IN AN ASYNC HANDLER?"},{"content":"<h2 id=\"-how-is-runloop-behaviour-different-when-testing\">How is runloop behaviour different when testing?</h2><p>When your application is in <em>testing mode</em> then Ember will throw an error if you try to schedule work without an available runloop.</p><p>Autoruns are disabled in testing for several reasons:</p>","link":"./JP/applications/run-loop.ja-JP.html","spaLink":"#/JP/applications/run-loop.ja-JP","title":"HOW IS RUNLOOP BEHAVIOUR DIFFERENT WHEN TESTING?"},{"content":"<h2 id=\"-where-can-i-find-more-information\">Where can I find more information?</h2><p>Check out the <a href=\"http://emberjs.com/api/classes/Ember.run.html\">Ember.run</a> API documentation, as well as the <a href=\"https://github.com/ebryn/backburner.js/\">Backburner library</a> that powers the run loop.</p>","link":"./JP/applications/run-loop.ja-JP.html","spaLink":"#/JP/applications/run-loop.ja-JP","title":"WHERE CAN I FIND MORE INFORMATION?"},{"content":"<h3 id=\"-defining-services\">Defining Services</h3><p>Services can be generated using Ember CLI’s <code>service</code> generator. For example, the following command will create the <code>ShoppingCart</code> service:</p><p>Services must extend the <a href=\"http://emberjs.com/api/classes/Ember.Service.html\"><code>Ember.Service</code></a> base class:</p><p>```app/services/shopping-cart.js export default Ember.Service.extend({ });</p>","link":"./JP/applications/services.ja-JP.html","spaLink":"#/JP/applications/services.ja-JP","title":"Defining Services"},{"content":"<h3 id=\"-accessing-services\">Accessing Services</h3><p>To access a service, you can inject it in any container-resolved object such as a component or another service using the <code>Ember.inject.service</code> function. There are 2 ways to use this function. You can either invoke it with no arguments, or you can pass it the registered name of the service. When no arguments are passed the services is loaded based in the name of the variable key. You can load the shopping cart service with no arguments like below.</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ //will load the service in file /app/services/shopping-cart.js shoppingCart: Ember.inject.service() });</p><p>This injects the shopping cart service into the component and makes it available as the <code>cart</code> property.</p><p>Injected properties are lazy loaded; meaning the service will not be instantiated until the property is explicitly called. Therefore you need to access services in your component using the <code>get</code> function otherwise you might get an undefined.</p><p>Once loaded, a service will persist until the application exits.</p><p>Below we add a remove action to the <code>cart-contents</code> component. Notice that below we access the <code>cart</code> service with a call to<code>this.get</code>.</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ cart: Ember.inject.service(‘shopping-cart’),</p><p>actions: { remove(item) { this.get(‘cart’).remove(item); } } });</p>","link":"./JP/applications/services.ja-JP.html","spaLink":"#/JP/applications/services.ja-JP","title":"Accessing Services"},{"content":"<h3 id=\"-customizing-the-element\">Customizing the Element</h3><p>To use a tag other than <code>div</code>, subclass <code>Ember.Component</code> and assign it a <code>tagName</code> property. This property can be any valid HTML5 tag name as a string.</p><p>```app/components/navigation-bar.js export default Ember.Component.extend({ tagName: ‘nav’ });</p>","link":"./JP/components/customizing-a-components-element.ja-JP.html","spaLink":"#/JP/components/customizing-a-components-element.ja-JP","title":"Customizing the Element"},{"content":"<h3 id=\"-customizing-class-names\">Customizing Class Names</h3><p>You can also specify which class names are applied to the component’s element by setting its <code>classNames</code> property to an array of strings:</p><p>```app/components/navigation-bar.js export default Ember.Component.extend({ classNames: [‘primary’] });</p><p>This component would render the following:</p><p>If <code>isUrgent</code> is changed to <code>false</code>, then the <code>is-urgent</code> class name will be removed.</p><p>By default, the name of the Boolean property is dasherized. You can customize the class name applied by delimiting it with a colon:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isUrgent:urgent’], isUrgent: true });</p><p>Besides the custom class name for the value being <code>true</code>, you can also specify a class name which is used when the value is <code>false</code>:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isEnabled:enabled:disabled’], isEnabled: false });</p><p>You can also specify a class which should only be added when the property is <code>false</code> by declaring <code>classNameBindings</code> like this:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isEnabled::disabled’], isEnabled: false });</p><p>If the <code>isEnabled</code> property is set to <code>true</code>, no class name is added:</p><p>If the bound property’s value is a string, that value will be added as a class name without modification:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘priority’], priority: ‘highestPriority’ });</p>","link":"./JP/components/customizing-a-components-element.ja-JP.html","spaLink":"#/JP/components/customizing-a-components-element.ja-JP","title":"Customizing Class Names"},{"content":"<h3 id=\"-customizing-attributes\">Customizing Attributes</h3><p>You can bind attributes to the DOM element that represents a component by using <code>attributeBindings</code>:</p><p>```app/components/link-item.js export default Ember.Component.extend({ tagName: ‘a’, attributeBindings: [‘href’], href: ‘<a href=\"http://emberjs.com\">http://emberjs.com</a>‘ });</p><p>If the attribute is null, it won’t be rendered:</p><p>```app/components/link-item.js export default Ember.Component.extend({ tagName: ‘span’, title: null, attributeBindings: [‘title’], });</p><p>…and this HTML when a title of “Ember JS” is passed to the component:</p>","link":"./JP/components/customizing-a-components-element.ja-JP.html","spaLink":"#/JP/components/customizing-a-components-element.ja-JP","title":"Customizing Attributes"},{"content":"<h1 id=\"title\">{{title}}</h1><p>{{yield}}</p><p>Edit title: {{input type=”text” value=title}}</p><p></p><p>Its model is populated in <code>model</code> hook in the route handler:</p><p>```app/routes/index.js export default Ember.Route.extend({ model() { return this.store.findAll(‘post’); } });</p><p>```app/templates/components/bar-component.hbs </p>","link":"./JP/components/defining-a-component.ja-JP.html","spaLink":"#/JP/components/defining-a-component.ja-JP","title":"{{TITLE}}"},{"content":"<h3 id=\"title-hello-from-bar\">Hello from bar!</h3><p>When the parameter passed to <code>{{component}}</code> evaluates to <code>null</code> or <code>undefined</code>, the helper renders nothing. When the parameter changes, the currently rendered component is destroyed and the new component is created and brought in.</p><p>Picking different components to render in response to the data allows you to have different template and behavior for each case. The <code>{{component}}</code> helper is a powerful tool for improving code modularity.</p>","link":"./JP/components/defining-a-component.ja-JP.html","spaLink":"#/JP/components/defining-a-component.ja-JP","title":"Hello from bar!"},{"content":"<h2 id=\"-sending-actions\">Sending Actions</h2><p>In some cases your component needs to define event handlers, perhaps to support various draggable behaviors. For example, a component may need to send an <code>id</code> when it receives a drop event:</p><p>You can define the component’s event handlers to manage the drop event. And if you need to, you may also stop events from bubbling, by using <code>return false;</code>.</p><p>```app/components/drop-target.js export default Ember.Component.extend({ attributeBindings: [‘draggable’], draggable: ‘true’,</p><p>dragOver() { return false; },</p><p>drop(event) { let id = event.dataTransfer.getData(‘text/data’); this.sendAction(‘action’, id); } }); ```</p>","link":"./JP/components/handling-events.ja-JP.html","spaLink":"#/JP/components/handling-events.ja-JP","title":"SENDING ACTIONS"},{"content":"<h2 id=\"-event-names\">Event Names</h2><p>The event handling examples described above respond to one set of events. The names of the built-in events are listed below. Custom events can be registered by using <a href=\"http://emberjs.com/api/classes/Ember.Application.html#property_customEvents\">Ember.Application.customEvents</a>.</p><p>Touch events:</p><ul>\n<li><code>touchStart</code></li>\n<li><code>touchMove</code></li>\n<li><code>touchEnd</code></li>\n<li><code>touchCancel</code></li>\n</ul><p>Keyboard events</p><ul>\n<li><code>keyDown</code></li>\n<li><code>keyUp</code></li>\n<li><code>keyPress</code></li>\n</ul><p>Mouse events</p><ul>\n<li><code>mouseDown</code></li>\n<li><code>mouseUp</code></li>\n<li><code>contextMenu</code></li>\n<li><code>click</code></li>\n<li><code>doubleClick</code></li>\n<li><code>mouseMove</code></li>\n<li><code>focusIn</code></li>\n<li><code>focusOut</code></li>\n<li><code>mouseEnter</code></li>\n<li><code>mouseLeave</code></li>\n</ul><p>Form events:</p><ul>\n<li><code>submit</code></li>\n<li><code>change</code></li>\n<li><code>focusIn</code></li>\n<li><code>focusOut</code></li>\n<li><code>input</code></li>\n</ul><p>HTML5 drag and drop events:</p><ul>\n<li><code>dragStart</code></li>\n<li><code>drag</code></li>\n<li><code>dragEnter</code></li>\n<li><code>dragLeave</code></li>\n<li><code>dragOver</code></li>\n<li><code>dragEnd</code></li>\n<li><code>drop</code></li>\n</ul>","link":"./JP/components/handling-events.ja-JP.html","spaLink":"#/JP/components/handling-events.ja-JP","title":"EVENT NAMES"},{"content":"<h1 id=\"title\">{{title}}</h1><p>{{body}}</p><p></p><p>If we tried to use the component like this:</p><p>```app/templates/index.hbs {{#each model as |post|}} {{blog-post}} {{/each}}</p><p>In order to make a property available to a component, you must pass it in like this:</p><p>```app/templates/index.hbs {{#each model as |post|}} {{blog-post title=post.title body=post.body}} {{/each}}</p><p>To set the component up to receive parameters this way, you need set the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams\"><code>positionalParams</code></a> attribute in your component class.</p><p>```app/components/blog-post.js const BlogPostComponent = Ember.Component.extend({});</p><p>BlogPostComponent.reopenClass({ positionalParams: [‘title’, ‘body’] });</p><p>export default BlogPostComponent;</p>","link":"./JP/components/passing-properties-to-a-component.ja-JP.html","spaLink":"#/JP/components/passing-properties-to-a-component.ja-JP","title":"{{TITLE}}"},{"content":"<h2 id=\"-order-of-lifecycle-hooks-called\">Order of Lifecycle Hooks Called</h2><p>Listed below are the component lifecycle hooks in order of execution according to render scenario.</p>","link":"./JP/components/the-component-lifecycle.ja-JP.html","spaLink":"#/JP/components/the-component-lifecycle.ja-JP","title":"ORDER OF LIFECYCLE HOOKS CALLED"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-initial-render\">On Initial Render</h3>","link":"./JP/components/the-component-lifecycle.ja-JP.html","spaLink":"#/JP/components/the-component-lifecycle.ja-JP","title":"On Initial Render"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-re-render\">On Re-Render</h3>","link":"./JP/components/the-component-lifecycle.ja-JP.html","spaLink":"#/JP/components/the-component-lifecycle.ja-JP","title":"On Re-Render"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-component-destroy\">On Component Destroy</h3>","link":"./JP/components/the-component-lifecycle.ja-JP.html","spaLink":"#/JP/components/the-component-lifecycle.ja-JP","title":"On Component Destroy"},{"content":"<h2 id=\"-lifecycle-hook-examples\">Lifecycle Hook Examples</h2><p>Below are some samples of ways to use lifecycle hooks within your components.</p>","link":"./JP/components/the-component-lifecycle.ja-JP.html","spaLink":"#/JP/components/the-component-lifecycle.ja-JP","title":"LIFECYCLE HOOK EXAMPLES"},{"content":"<h3 id=\"-lifecycle-hook-examples-resetting-presentation-state-on-attribute-change-with-didupdateattrs\">Resetting Presentation State on Attribute Change with <code>didUpdateAttrs</code></h3><p><code>didUpdateAttrs</code> runs when the attributes of a component have changed, but not when the component is re-rendered, via <code>component.rerender</code>, <code>component.set</code>, or changes in models or services used by the template.</p><p>A <code>didUpdateAttrs</code> is called prior to rerender, you can use this hook to execute code when specific attributes are changed. This hook can be an effective alternative to an observer, as it will run prior to a re-render, but after an attribute has changed.</p><p>An example of this scenario in action is a profile editor component. As you are editing one user, and the user attribute is changed, you can use <code>didUpdateAttrs</code> to clear any error state that was built up from editing the previous user.</p><p><code>/app/templates/components/profile-editor.hbs</code></p><p><code>/app/components/profile-editor.js</code></p>","link":"./JP/components/the-component-lifecycle.ja-JP.html","spaLink":"#/JP/components/the-component-lifecycle.ja-JP","title":"Resetting Presentation State on Attribute Change with didUpdateAttrs"},{"content":"<h3 id=\"-lifecycle-hook-examples-formatting-component-attributes-with-didreceiveattrs\">Formatting Component Attributes with <code>didReceiveAttrs</code></h3><p><code>didReceiveAttrs</code> runs after <code>init</code>, and it also runs on subsequent re-renders, which is useful for logic that is the same on all renders. It does not run when the re-rendered has been initiated internally.</p><p>Since the <code>didReceiveAttrs</code> hook is called every time a component’s attributes are updated whether on render or re-render, you can use the hook to effectively act as an observer, ensuring code is executed every time an attribute changes.</p><p>For example, if you have a component that renders based on a json configuration, but you want to provide your component with the option of taking the config as a string, you can leverage <code>didReceiveAttrs</code> to ensure the incoming config is always parsed.</p>","link":"./JP/components/the-component-lifecycle.ja-JP.html","spaLink":"#/JP/components/the-component-lifecycle.ja-JP","title":"Formatting Component Attributes with didReceiveAttrs"},{"content":"<h3 id=\"-lifecycle-hook-examples-integrating-with-third-party-libraries-with-didinsertelement\">Integrating with Third-Party Libraries with <code>didInsertElement</code></h3><p>Suppose you want to integrate your favorite date picker library into an Ember project. Typically, 3rd party JS/jQuery libraries require a DOM element to bind to. So, where is the best place to initialize and attach the library?</p><p>After a component successfully renders its backing HTML element into the DOM, it will trigger its <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> hook.</p><p>Ember guarantees that, by the time <code>didInsertElement()</code> is called:</p><p>A component’s <a href=\"http://emberjs.com/api/classes/Ember.Component.html#method__\"><code>$()</code></a> method allows you to access the component’s DOM element by returning a JQuery element. For example, you can set an attribute using jQuery’s <code>attr()</code> method:</p><p><a href=\"http://emberjs.com/api/classes/Ember.Component.html#method__\"><code>$()</code></a> will, by default, return a jQuery object for the component’s root element, but you can also target child elements within the component’s template by passing a selector:</p><p>Let’s initialize our date picker by overriding the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> method.</p><p>Date picker libraries usually attach to an <code>&lt;input&gt;</code> element, so we will use jQuery to find an appropriate input within our component’s template.</p><p><a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> is also a good place to attach event listeners. This is particularly useful for custom events or other browser events which do not have a <a href=\"http://guides.emberjs.com/v2.1.0/components/handling-events/#toc_event-names\">built-in event handler</a>.</p><p>For example, perhaps you have some custom CSS animations trigger when the component is rendered and you want to handle some cleanup when it ends:</p><p>There are a few things to note about the <code>didInsertElement()</code> hook:</p><ul>\n<li>It is only triggered once when the component element is first rendered.</li>\n<li>In cases where you have components nested inside other components, the child component will always receive the <code>didInsertElement()</code> call before its parent does.</li>\n<li>Setting properties on the component in <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> triggers a re-render, and for performance reasons, is not allowed.</li>\n<li>While <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> is technically an event that can be listened for using <a href=\"http://emberjs.com/api/classes/Ember.Component.html#method_on\"><code>on()</code></a>, it is encouraged to override the default method itself, particularly when order of execution is important.</li>\n</ul>","link":"./JP/components/the-component-lifecycle.ja-JP.html","spaLink":"#/JP/components/the-component-lifecycle.ja-JP","title":"Integrating with Third-Party Libraries with didInsertElement"},{"content":"<h3 id=\"-lifecycle-hook-examples-making-updates-to-the-rendered-dom-with-didrender\">Making Updates to the Rendered DOM with <code>didRender</code></h3><p>The <code>didRender</code> hook is called during both render and re-render after the template has rendered and the DOM updated. You can leverage this hook to perform post-processing on the DOM of a component after its been updated.</p><p>In this example, there is a list component that needs to scroll to a selected item when rendered. Since scrolling to a specific spot is based on positions within the DOM, we need to ensure that the list has been rendered before scrolling. We can first render this list, and then set the scroll.</p><p>The component below takes a list of items and displays them on the screen. Additionally, it takes an object representing which item is selected and will select and set the scroll top to that item.</p><p>When rendered the component will iterate through the given list and apply a class to the one that is selected.</p><p><code>/app/templates/components/selected-item-list.hbs</code></p><p>The scroll happens on <code>didRender</code>, where it will scroll the component’s container to the element with the selected class name.</p><p><code>/app/components/selected-item-list.js</code></p>","link":"./JP/components/the-component-lifecycle.ja-JP.html","spaLink":"#/JP/components/the-component-lifecycle.ja-JP","title":"Making Updates to the Rendered DOM with didRender"},{"content":"<h3 id=\"-lifecycle-hook-examples-detaching-and-tearing-down-component-elements-with-willdestroyelement\">Detaching and Tearing Down Component Elements with <code>willDestroyElement</code></h3><p>When a component detects that it is time to remove itself from the DOM, Ember will trigger the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_willDestroyElement\"><code>willDestroyElement()</code></a> method, allowing for any teardown logic to be performed.</p><p>Component teardown can be triggered by a number of different conditions. For instance, the user may navigate to a different route, or a conditional Handlebars block surrounding your component may change:</p><p>Let’s use this hook to cleanup our date picker and event listener from above:</p>","link":"./JP/components/the-component-lifecycle.ja-JP.html","spaLink":"#/JP/components/the-component-lifecycle.ja-JP","title":"Detaching and Tearing Down Component Elements with willDestroyElement"},{"content":"<h2 id=\"-creating-the-component\">Creating the Component</h2><p>Let’s call our component <code>button-with-confirmation</code>. We can create it by typing:</p><p>We’ll plan to use the component in a template something like this:</p><p>```app/templates/components/user-profile.hbs {{button-with-confirmation text=”Click OK to delete your account.”}}</p>","link":"./JP/components/triggering-changes-with-actions.ja-JP.html","spaLink":"#/JP/components/triggering-changes-with-actions.ja-JP","title":"CREATING THE COMPONENT"},{"content":"<h2 id=\"-designing-the-action\">Designing the Action</h2><p>When implementing an action on a component, you need to break it down into two steps:</p><p>Let’s take it step by step.</p>","link":"./JP/components/triggering-changes-with-actions.ja-JP.html","spaLink":"#/JP/components/triggering-changes-with-actions.ja-JP","title":"DESIGNING THE ACTION"},{"content":"<h2 id=\"-implementing-the-action\">Implementing the Action</h2><p>In the parent component, let’s first define what we want to happen when the user clicks the button and then confirms. In this case, we’ll find the user’s account and delete it.</p><p>In Ember, each component can have a property called <code>actions</code>, where you put functions that can be <a href=\"../../templates/actions/\">invoked by the user interacting with the component itself</a>, or by child components.</p><p>Let’s look at the parent component’s JavaScript file. In this example, imagine we have a parent component called <code>user-profile</code> that shows the user’s profile to them.</p><p>We’ll implement an action on the parent component called <code>userDidDeleteAccount()</code> that, when called, gets a hypothetical <code>login</code> <a href=\"../../applications/services/\">service</a> and calls the service’s <code>deleteUser()</code> method.</p><p>```app/components/user-profile.js export default Ember.Component.extend({ login: Ember.inject.service(),</p><p>actions: { userDidDeleteAccount() { this.get(‘login’).deleteUser(); } } });</p><p>The component template will have a button and a div that shows the confirmation dialog based on the value of <code>confirmShown</code>.</p><p>```app/templates/components/button-with-confirmation.hbs <button {{action=\"\" \"launchconfirmdialog\"}}=\"\">{{text}}</button> {{#if confirmShown}} </p><p></p><p></p><p>This snippet says “take the <code>userDidDeleteAccount</code> action from the parent and make it available on the child component as <code>onConfirm</code>.”</p><p>We can do a similar thing for our <code>send-message</code> component:</p><p>```app/templates/components/send-message.hbs {{button-with-confirmation text=”Click to send your message.” onConfirm=(action “sendMessage”)}}</p><p><code>this.get('onConfirm')</code> will return the function passed from the parent as the value of <code>onConfirm</code>, and the following <code>()</code> will invoke the function.</p><p>Like normal attributes, actions can be a property on the component; the only difference is that the property is set to a function that knows how to trigger behavior.</p><p>That makes it easy to remember how to add an action to a component. It’s like passing an attribute, but you use the <code>action</code> helper to pass a function instead.</p><p>Actions in components allow you to decouple an event happening from how it’s handled, leading to modular, more reusable components.</p>","link":"./JP/components/triggering-changes-with-actions.ja-JP.html","spaLink":"#/JP/components/triggering-changes-with-actions.ja-JP","title":"IMPLEMENTING THE ACTION"},{"content":"<h2 id=\"-handling-action-completion\">Handling Action Completion</h2><p>Often actions perform asynchronous tasks, such as making an ajax request to a server. Since actions are functions that can be passed in by a parent component, they are able to return values when called. The most common scenario is for an action to return a promise so that the component can handle the action’s completion.</p><p>In our user <code>button-with-confirmation</code> component we want to leave the confirmation modal open until we know that the operation has completed successfully. This is accomplished by expecting a promise to be returned from <code>onConfirm</code>. Upon resolution of the promise, we set a property used to indicate the visibility of the confirmation modal.</p><p>```app/components/button-with-confirmation.js export default Ember.Component.extend({ actions: { launchConfirmDialog() { this.set(‘confirmShown’, true); },</p><p>} });</p><p>In this case, the code in <code>button-with-confirmation</code> does not change. It will still invoke <code>onConfirm</code> with no arguments. The action helper will add the arguments provided in the template to the call.</p><p>Action arguments curry, meaning that you can provide partial arguments to the action helper and provide the rest of the arguments when you call the function within the component javascript file. For example, our <code>button-with-confirmation</code> component will now <a href=\"../wrapping-content-in-a-component/\">yield</a> the content of the confirmation dialog to collect extra information to be sent along with the <code>onConfirm</code> action:</p><p>```app/templates/components/button-with-confirmation.hbs <button {{action=\"\" \"launchconfirmdialog\"}}=\"\">{{text}}</button> {{#if confirmShown}} </p><p></p><p></p><p>Now when the <code>submitConfirm</code> action is invoked, we call it with the value provided by our yielded input.</p><p>```app/components/button-with-confirmation.js export default Ember.Component.extend({ actions: { launchConfirmDialog() { this.set(“confirmShown”, true); },</p><p>} });</p>","link":"./JP/components/triggering-changes-with-actions.ja-JP.html","spaLink":"#/JP/components/triggering-changes-with-actions.ja-JP","title":"HANDLING ACTION COMPLETION"},{"content":"<h2 id=\"-invoking-actions-directly-on-component-collaborators\">Invoking Actions Directly on Component Collaborators</h2><p>Actions can be invoked on objects other than the component directly from the template. For example, in our <code>send-message</code> component we might include a service that processes the <code>sendMessage</code> logic.</p><p>```app/components/send-message.js export default Ember.Component.extend({ messaging: Ember.inject.service(),</p><p>// component implementation });</p><p>By supplying the <code>target</code> attribute, the action helper will look to invoke the <code>sendMessage</code> action directly on the messaging service, saving us from writing code on the component that just passes the action along to the service.</p><p>```app/services/messaging.js export default Ember.Service.extend({ actions: { sendMessage(messageType, text) { //handle message send and return a promise } } });</p><p>All our <code>system-preferences-editor</code> component really needs to process a user deletion is an account ID. For this case, the action helper provides the <code>value</code> attribute to allow a parent component to dig into the passed object to pull out only what it needs.</p><p>```app/templates/components/system-preferences-editor.hbs {{user-profile didDelete=(action “userDeleted” value=”account.id”)}}</p>","link":"./JP/components/triggering-changes-with-actions.ja-JP.html","spaLink":"#/JP/components/triggering-changes-with-actions.ja-JP","title":"INVOKING ACTIONS DIRECTLY ON COMPONENT COLLABORATORS"},{"content":"<h2 id=\"-calling-actions-up-multiple-component-layers\">Calling Actions Up Multiple Component Layers</h2><p>When your components go multiple template layers deep, its common to need to handle an action several layers up the tree. Using the action helper, it is possible to make actions defined in parent components available at the bottom layers of your component tree without adding JavaScript code to the components in between.</p><p>For example, we want to take account deletion out of the <code>user-profile</code> component and handle deletion in its parent. In our template in <code>user-profile.hbs</code>, we can change our action to call <code>deleteCurrentUser</code>, which will be defined on <code>system-preferences-editor</code>.</p><p>```app/templates/components/user-profile.hbs {{button-with-confirmation onConfirm=(action deleteCurrentUser) text=”Click OK to delete your account.”}}</p><p>Now when you confirm deletion, the action goes straight to the <code>system-preferences-editor</code> to handle.</p><p>```app/components/system-preferences-editor.js import Ember from ‘ember’;</p><p>export default Ember.Component.extend({ login: Ember.inject.service(), actions: { deleteUser(idStr) { return this.get(‘login’).deleteUserAccount(idStr); } } }); ```</p>","link":"./JP/components/triggering-changes-with-actions.ja-JP.html","spaLink":"#/JP/components/triggering-changes-with-actions.ja-JP","title":"CALLING ACTIONS UP MULTIPLE COMPONENT LAYERS"},{"content":"<h1 id=\"title\">{{title}}</h1><p>(See <a href=\"../passing-properties-to-a-component/\">Passing Properties to a Component</a> for more.)</p><p>In this case, the content we wanted to display came from the model. But what if we want the developer using our component to be able to provide custom HTML content?</p><p>In addition to the simple form you’ve learned so far, components also support being used in <strong>block form</strong>. In block form, components can be passed a Handlebars template that is rendered inside the component’s template wherever the <code>{{yield}}</code> expression appears.</p><p>To use the block form, add a <code>#</code> character to the beginning of the component name, then make sure to add a closing tag. (See the Handlebars documentation on <a href=\"http://handlebarsjs.com/#block-expressions\">block expressions</a> for more.)</p><p>In that case, we can use the <code>{{blog-post}}</code> component in <strong>block form</strong> and tell Ember where the block content should be rendered using the <code>{{yield}}</code> helper. To update the example above, we’ll first change the component’s template:</p><p>```app/templates/components/blog-post.hbs </p>","link":"./JP/components/wrapping-content-in-a-component.ja-JP.html","spaLink":"#/JP/components/wrapping-content-in-a-component.ja-JP","title":"{{TITLE}}"},{"content":"<h2 id=\"-routing\">Routing</h2><p>```app/app.js export default Ember.Application.extend({ // Basic logging, e.g. “Transitioned into ‘post’” LOG_TRANSITIONS: true,</p><p>// Extremely detailed logging, highlighting every internal // step made while transitioning into a route, including // <code>beforeModel</code>, <code>model</code>, and <code>afterModel</code> hooks, and // information about redirects and aborted transitions LOG_TRANSITIONS_INTERNAL: true });</p>","link":"./JP/configuring-ember/debugging.ja-JP.html","spaLink":"#/JP/configuring-ember/debugging.ja-JP","title":"ROUTING"},{"content":"<h2 id=\"-controllers\">Controllers</h2><p>```config/environment.js ENV.APP.LOG_ACTIVE_GENERATION = true;</p><p>```config/environments.js ENV.APP.LOG_BINDINGS = true</p><p>If you are using imports with Ember, be sure to import the console:</p><p>There are times when dealing with promises that it seems like any errors are being ‘swallowed’, and not properly raised. This makes it extremely difficult to track down where a given issue is coming from. Thankfully, <code>RSVP</code> has a solution for this problem built in.</p><p>You can provide an <code>onerror</code> function that will be called with the error details if any errors occur within your promise. This function can be anything, but a common practice is to call <code>console.assert</code> to dump the error to the console.</p><p>```app/app.js Ember.RSVP.on(‘error’, function(error) { Ember.Logger.assert(false, error); });</p>","link":"./JP/configuring-ember/debugging.ja-JP.html","spaLink":"#/JP/configuring-ember/debugging.ja-JP","title":"CONTROLLERS"},{"content":"<h2 id=\"-life-without-prototype-extension\">Life Without Prototype Extension</h2><p>In order for your application to behave correctly, you will need to manually extend or create the objects that the native objects were creating before.</p>","link":"./JP/configuring-ember/disabling-prototype-extensions.ja-JP.html","spaLink":"#/JP/configuring-ember/disabling-prototype-extensions.ja-JP","title":"LIFE WITHOUT PROTOTYPE EXTENSION"},{"content":"<h3 id=\"-life-without-prototype-extension-arrays\">Arrays</h3><p>Native arrays will no longer implement the functionality needed to observe them. If you disable prototype extension and attempt to use native arrays with things like a template’s <code>{{#each}}</code> helper, Ember.js will have no way to detect changes to the array and the template will not update as the underlying array changes.</p><p>Additionally, if you try to set the model of an <code>Ember.ArrayController</code> to a plain native array, it will raise an exception since it no longer implements the <code>Ember.Array</code> interface.</p><p>You can manually coerce a native array into an array that implements the required interfaces using the convenience method <code>Ember.A</code>:</p>","link":"./JP/configuring-ember/disabling-prototype-extensions.ja-JP.html","spaLink":"#/JP/configuring-ember/disabling-prototype-extensions.ja-JP","title":"Arrays"},{"content":"<h3 id=\"-life-without-prototype-extension-strings\">Strings</h3><p>Strings will no longer have the convenience methods described in the <a href=\"http://emberjs.com/api/classes/Ember.String.html\">Ember.String API reference.</a>. Instead, you can use the similarly-named methods of the <code>Ember.String</code> object and pass the string to use as the first parameter:</p>","link":"./JP/configuring-ember/disabling-prototype-extensions.ja-JP.html","spaLink":"#/JP/configuring-ember/disabling-prototype-extensions.ja-JP","title":"Strings"},{"content":"<h3 id=\"-life-without-prototype-extension-functions\">Functions</h3><p>The <a href=\"../../object-model/\">Object Model</a> section of the Guides describes how to write computed properties, observers, and bindings without prototype extensions. Below you can learn about how to convert existing code to the format now encouraged.</p><p>To annotate computed properties, use the <code>Ember.computed()</code> method to wrap the function:</p><p>Observers are annotated using <code>Ember.observer()</code>:</p><p>Evented functions are annotated using <code>Ember.on()</code>:</p>","link":"./JP/configuring-ember/disabling-prototype-extensions.ja-JP.html","spaLink":"#/JP/configuring-ember/disabling-prototype-extensions.ja-JP","title":"Functions"},{"content":"<h3 id=\"-changing-the-root-element\">Changing the Root Element</h3><p>By default, your application will render the <a href=\"../../routing/defining-your-routes/#toc_the-application-route\">application template</a> and attach it to the document’s <code>body</code> element.</p><p>You can tell the application to append the application template to a different element by specifying its <code>rootElement</code> property:</p><p>```app/app.js export default Ember.Application.extend({ rootElement: ‘#app’ });</p>","link":"./JP/configuring-ember/embedding-applications.ja-JP.html","spaLink":"#/JP/configuring-ember/embedding-applications.ja-JP","title":"Changing the Root Element"},{"content":"<h3 id=\"-specifying-a-root-url\">Specifying a Root URL</h3><p>If your Ember application is one of multiple web applications served from the same domain, it may be necessary to indicate to the router what the root URL for your Ember application is. By default, Ember will assume it is served from the root of your domain.</p><p>For example, if you wanted to serve your blogging application from <code>http://emberjs.com/blog/</code>, it would be necessary to specify a root URL of <code>/blog/</code>.</p><p>This can be achieved by setting the <code>rootURL</code> on the router:</p>","link":"./JP/configuring-ember/embedding-applications.ja-JP.html","spaLink":"#/JP/configuring-ember/embedding-applications.ja-JP","title":"Specifying a Root URL"},{"content":"<h2 id=\"-feature-life-cycle\">Feature Life-Cycle</h2><p>A newly-flagged feature is only available in canary builds and can be enabled at runtime through your project’s configuration file.</p><p>At the start of a beta cycle the Ember core team evaluates each new feature. Features deemed stable are made available in the next beta and enabled by default.</p><p>Beta features that receive negative feedback from the community are disabled in the next beta point release, and are not included in the next stable release. They may still be included in the next beta cycle if the issues/concerns are resolved.</p><p>Once the beta cycle has completed, the next stable release will include any features that were enabled during the beta cycle. At this point the feature flags will be removed from the canary and future beta branches, and the feature becomes part of the framework.</p>","link":"./JP/configuring-ember/feature-flags.ja-JP.html","spaLink":"#/JP/configuring-ember/feature-flags.ja-JP","title":"FEATURE LIFE-CYCLE"},{"content":"<h2 id=\"-flagging-details\">Flagging Details</h2><p>The flag status in the generated build is controlled by the <a href=\"https://github.com/emberjs/ember.js/blob/master/features.json\"><code>features.json</code></a> file in the root of the Ember.js project. This file lists all new features and their current status.</p><p>A feature can have one of a three flags:</p><ul>\n<li><code>true</code> - The feature is <strong>present</strong> and <strong>enabled</strong>: the code behind the flag is always enabled in the generated build.</li>\n<li><code>null</code> - The feature is <strong>present</strong> but <strong>disabled</strong> in the build output. It must be enabled at runtime.</li>\n<li><code>false</code> - The feature is entirely <strong>disabled</strong>: the code behind the flag is not present in the generated build.</li>\n</ul><p>The process of removing the feature flags from the resulting build output is handled by <a href=\"https://github.com/thomasboyt/defeatureify\"><code>defeatureify</code></a>.</p>","link":"./JP/configuring-ember/feature-flags.ja-JP.html","spaLink":"#/JP/configuring-ember/feature-flags.ja-JP","title":"FLAGGING DETAILS"},{"content":"<h2 id=\"-feature-listing-featuresmd\">Feature Listing (<a href=\"https://github.com/emberjs/ember.js/blob/master/FEATURES.md\"><code>FEATURES.md</code></a>)</h2><p>When a developer adds a new feature to the <code>canary</code> channel (i.e. the <code>master</code> branch on github), they also add an entry to <a href=\"https://github.com/emberjs/ember.js/blob/master/FEATURES.md\"><code>FEATURES.md</code></a> explaining what the feature does, and linking to their originating pull request. This list is kept current, and reflects what is available in each channel (<code>release</code>, <code>beta</code>, and <code>canary</code>).</p>","link":"./JP/configuring-ember/feature-flags.ja-JP.html","spaLink":"#/JP/configuring-ember/feature-flags.ja-JP","title":"FEATURE LISTING (FEATURES.MD)"},{"content":"<h2 id=\"-enabling-at-runtime\">Enabling At Runtime</h2><p>When using the Ember.js canary or beta builds you can enable a “<strong>present</strong> but <strong>disabled</strong>“ feature by setting its flag value to <code>true</code> before your application boots:</p><p>For the truly ambitious developer, setting <code>ENV.EmberENV.ENABLE_ALL_FEATURES</code> to <code>true</code> will enable all experimental features.</p>","link":"./JP/configuring-ember/feature-flags.ja-JP.html","spaLink":"#/JP/configuring-ember/feature-flags.ja-JP","title":"ENABLING AT RUNTIME"},{"content":"<h2 id=\"-filtering-deprecations\">Filtering Deprecations</h2><p>When your project has a lot of deprecations, you can start by filtering out deprecations that do not have to be addressed right away. You can use the <a href=\"http://emberjs.com/api/classes/Ember.Debug.html#method_registerDeprecationHandler\">deprecation handlers</a> API to check for what release a deprecated feature will be removed. An example handler is shown below that filters out all deprecations that are not going away in release 2.0.0.</p><p>``` app/initializers/main.js if (Ember.Debug &amp;&amp; typeof Ember.Debug.registerDeprecationHandler === ‘function’) { Ember.Debug.registerDeprecationHandler((message, options, next) =&gt; { if (options &amp;&amp; options.until &amp;&amp; options.until !== ‘2.0.0’) { return; } next(message, options); }); }</p><p>You might notice that you have a lot of duplicated messages in your workflow file, like the 3 messages in the above example that start with <code>Accessing 'template' in...</code>. This is because some of the deprecation messages provide context to the specific deprecation, making them different than the same deprecation in other parts of the app. If you want to consolidate the duplication, you can use a simple regular expression with a wildcard (<code>.*</code>) for the part of the message that varies per instance.</p><p>Below is the same deprecation-workflow file as above, now with a regular expression on line 7 to remove some redundant messages. Note that the double quotes around <code>matchMessage</code> have also been replaced with forward slashes.</p><p><code>`` /config/deprecation-workflow.js window.deprecationWorkflow = window.deprecationWorkflow || {}; window.deprecationWorkflow.config = { workflow: [ { handler: \"silence\", matchMessage: \"Ember.Handlebars.registerHelper is deprecated, please refactor to Ember.Helper.helper.\" }, { handler: \"silence\", matchMessage: \"</code>lookup<code>was called on a Registry. The</code>initializer<code>API no longer receives a container, and you should use an</code>instanceInitializer<code>to look up objects from the container.\" }, { handler: \"silence\", matchMessage: \"Using</code>Ember.HTMLBars.makeBoundHelper<code>is deprecated. Please refactor to using</code>Ember.Helper<code>or</code>Ember.Helper.helper`.” }, { handler: “silence”, matchMessage: /Accessing ‘template’ in .<em> is deprecated. To determine if a block was specified to .</em> please use ‘{{#if hasBlock}}’ in the components layout./ } ] };</p><p><img width=\"675px\" src=\"../../images/guides/configuring-ember/handling-deprecations/failed-test-from-deprecation.png\"></p>","link":"./JP/configuring-ember/handling-deprecations.ja-JP.html","spaLink":"#/JP/configuring-ember/handling-deprecations.ja-JP","title":"FILTERING DEPRECATIONS"},{"content":"<h3 id=\"-filtering-deprecations-3-fix-and-repeat\">3. Fix and Repeat</h3><p>After fixing a deprecation and getting your scenarios working again, you might want to leave the deprecation message in the workflow file with the throw handler enabled. This will ensure you haven’t missed anything, and ensure no new deprecated calls of that type are introduced to your project. Next, it’s just a matter of going down the list, updating the handler, and fixing each remaining deprecation.</p><p>In the end, your deprecations can be fully turned on as “throw” and you should be able to use your application without error. At this point, you can go ahead and update your Ember version! When you upgrade, be sure you remove the deprecations you’ve fixed from the deprecation workflow file, so that you can start the process over for the next release.</p>","link":"./JP/configuring-ember/handling-deprecations.ja-JP.html","spaLink":"#/JP/configuring-ember/handling-deprecations.ja-JP","title":"3. Fix and Repeat"},{"content":"<h2 id=\"-silencing-deprecation-warnings-during-compile\">Silencing Deprecation Warnings During Compile</h2><p>As you upgrade between releases, you might also notice that your terminal log begins to stream template-related deprecation warnings during the compile process, making it difficult to review your compilation logs.</p><p><img width=\"675px\" src=\"../../images/guides/configuring-ember/handling-deprecations/compile-deprecations.png\" title=\"Compile Deprecations Clouding Log\"></p><p>If you are using the deprecation workflow process above, you will likely prefer to gather these warnings during runtime execution instead. The way to hide these warnings during compile is to install the <a href=\"http://emberobserver.com/addons/ember-cli-template-lint\">ember-cli-template-lint</a> addon. It suppresses template deprecation warnings during compile in favor of showing them in the browser console during test suite execution or application usage.</p>","link":"./JP/configuring-ember/handling-deprecations.ja-JP.html","spaLink":"#/JP/configuring-ember/handling-deprecations.ja-JP","title":"SILENCING DEPRECATION WARNINGS DURING COMPILE"},{"content":"<h2 id=\"-deprecation-handling-in-ember-inspector\">Deprecation Handling in Ember Inspector</h2><p>Ember Inspector also provides deprecation handling capability. It can work complimentary to ember-cli-deprecation-workflow. As you unsilence deprecations to fix them, the inspector can allow you to more quickly find where in your code a deprecation occurs when you run into it at runtime, reducing the amount of stack trace browsing you have to do. For more information on using deprecation handling in Ember Inspector, see its <a href=\"../../ember-inspector/deprecations/\">guides section</a>.</p>","link":"./JP/configuring-ember/handling-deprecations.ja-JP.html","spaLink":"#/JP/configuring-ember/handling-deprecations.ja-JP","title":"DEPRECATION HANDLING IN EMBER INSPECTOR"},{"content":"<h2 id=\"-history\">history</h2><p>When using <code>history</code>, Ember uses the browser’s <a href=\"http://caniuse.com/history\">history</a> API to produce URLs with a structure like <code>/posts/new</code>.</p><p>Given the following router, entering <code>/posts/new</code> will take you to the <code>posts.new</code> route.</p><p>Keep in mind that your server must serve the Ember app from all the URLs defined in your <code>Router.map</code> function. In other words, if your user directly navigates to <code>/posts/new</code>, your server must be configured to serve your Ember app in response.</p>","link":"./JP/configuring-ember/specifying-url-type.ja-JP.html","spaLink":"#/JP/configuring-ember/specifying-url-type.ja-JP","title":"HISTORY"},{"content":"<h2 id=\"-hash\">hash</h2><p>The <code>hash</code> option uses the URL’s anchor to load the starting state of your application and will keep it in sync as you move around. At present, this relies on a <a href=\"http://caniuse.com/hashchange\">hashchange</a> event existing in the browser.</p><p>In the router example above, entering <code>/#/posts/new</code> will take you to the <code>posts.new</code> route.</p>","link":"./JP/configuring-ember/specifying-url-type.ja-JP.html","spaLink":"#/JP/configuring-ember/specifying-url-type.ja-JP","title":"HASH"},{"content":"<h2 id=\"-none\">none</h2><p>Finally, if you don’t want the browser’s URL to interact with your application at all, you can disable the location API entirely by setting <code>ENV.locationType</code> to <code>none</code>. This is useful for testing, or when you don’t want Ember to muck with the URL (for example when you embed your application in a larger page).</p>","link":"./JP/configuring-ember/specifying-url-type.ja-JP.html","spaLink":"#/JP/configuring-ember/specifying-url-type.ja-JP","title":"NONE"},{"content":"<h3 id=\"-bug-fixes\">Bug Fixes</h3><p>緊急のバグ修正は、既存のリリースブランチに対して適用されるものです。可能であれば、マスターに対して行われ、[BUGFIX release] がつけられるべきです。</p><p>ベータ版バグ修正はベータ版に適用されるべき、バグ修正です。可能であれば、マスターで作成され、 [BUGFIX beta] のタグがつけられるべきです。</p><p>セキュリティ修正はベータブランチ、カレントブランチと前のタグに対して行われるべきで、可能であれば、 [SECURITY] とタグを付けマスターにも適用するべきです。</p>","link":"./JP/contributing/adding-new-features.ja-JP.html","spaLink":"#/JP/contributing/adding-new-features.ja-JP","title":"Bug Fixes"},{"content":"<h3 id=\"-\">機能:</h3><p>新機能は、必ず、機能フラグでラップする必要があります。新機能のテストもまた、機能フラグでラップする必要があります。</p><p>ビルドツールが、機能フラグほ処理するため、機能フラグのフォーマットは正確に次の形式にする必要があります。 ファンクションは、ファンクションはスコープを変えて、早期にreturnしてしまわないように、私たちはブロックではなく、コンディショナルを利用しています。</p><p>テストは必ず全ての機能を有効にして、行われますので、現状のテストに対して、機能テストが引き渡されていることを確認してください。</p><p>特定の機能に対するコミットは、次のようなプレフィックスを含める必要があります。 [FEATURE htmlbars] こうすることで、この先、特定の機能を素早く特定することことができるようになります。 機能は決して、ベータやリリースブランチに対しては適用されません。 ベータやリリースブランチが切られたら、そのブランチが持つ機能の全てをすでに含んでいるということになります。</p><p> もし機能がベータやリリースにたどり着いて、もしマスターにその機能のバグを修正するコミットをしたら、上記のようにコミットを行ってください。</p><p>```config/environment.js Ember.FEATURES[‘<packagename>-<feature>‘] // if package specific Ember.FEATURES[‘container-factory-injections’] Ember.FEATURES[‘htmlbars’]</feature></packagename></p>","link":"./JP/contributing/adding-new-features.ja-JP.html","spaLink":"#/JP/contributing/adding-new-features.ja-JP","title":"機能:"},{"content":"<h3 id=\"-featuresjson\"><code>features.json</code></h3><p>リポジトリのルートにはfeatures.jsonがあり、ベータやリリースをビルドする際に機能のを有効化することができます。</p><p>このファイルはブランチを切る際に作成されて、その後、機能の追加は行われませんが削除される可能があります。</p><p>ビルドプロセスはリストにない機能を取り除き、リストから該当の機能の条件を取り除きます。</p>","link":"./JP/contributing/adding-new-features.ja-JP.html","spaLink":"#/JP/contributing/adding-new-features.ja-JP","title":"features.json"},{"content":"<h3 id=\"-gono-go\">Go/No-Go プロセス</h3><p>6 週間ごとにコア チームは、次のプロセスを行います。</p><p>ベーラブランチに残った機能は準備が整っているか、厳密に精査されます。機能がもし準備が不十分ならfeatures.jsonから取り除かれます。</p><p>これが完了すると、ベータブランチはタグ付けされ、リリースにマージされます。</p><p>マスターランチに残った機能は準備が整っているか、厳密に精査されます。 この段階で機能が「準備完了」とされるのは、文字通り全く障害がないという意味になります。 準備が整っていないと判断された機能はベータブランチに留まり、準備が整えられます。</p><p>この工程は６週おきに行われるので、新規機能が「準備が整っている」とされる機会はすぐにまた来ます。</p><p>この工程が完了したら、マスターブランチはベータブランチにマージされます。<code>features.json</code>ファイルに準備ができた機能が追加されます。</p>","link":"./JP/contributing/adding-new-features.ja-JP.html","spaLink":"#/JP/contributing/adding-new-features.ja-JP","title":"Go/No-Go プロセス"},{"content":"<h1 id=\"\">メイン リポジトリ</h1><p><strong>Ember.js</strong> - Emberのメインリポジトリ</p><ul>\n<li><a href=\"https://github.com/emberjs/ember.js\">https://github.com/emberjs/ember.js</a></li>\n</ul><p><strong>Ember Data</strong> - Emberのための、データ永続化ライブラリ</p><ul>\n<li><a href=\"https://github.com/emberjs/data\">https://github.com/emberjs/data</a></li>\n</ul><p><strong>Ember Website</strong> - <a href=\"http://emberjs.com\">http://emberjs.com</a> のソース</p><ul>\n<li><a href=\"https://github.com/emberjs/website\">https://github.com/emberjs/website</a></li>\n</ul><p><strong>Ember Guides</strong> - <a href=\"http://guides.emberjs.com\">http://guides.emberjs.com</a> のソース。今現在読んでいるものです。</p><ul>\n<li><a href=\"https://github.com/emberjs/guides\">https://github.com/emberjs/guides</a></li>\n</ul>","link":"./JP/contributing/repositories.ja-JP.html","spaLink":"#/JP/contributing/repositories.ja-JP","title":"メイン リポジトリ"},{"content":"<h1 id=\"ember\">Ember が利用しているライブラリ</h1><p>次のライブラリは Ember.js のソースコードの一部ですが、開発は別リポジドリで行われています。</p>","link":"./JP/contributing/repositories.ja-JP.html","spaLink":"#/JP/contributing/repositories.ja-JP","title":"EMBER が利用しているライブラリ"},{"content":"<h2 id=\"ember-packagesember-metallibvendorbackburnerjs\"><code>packages/ember-metal/lib/vendor/backburner.js</code></h2><ul>\n<li><strong>backburner.js</strong> - Ember ランループの実装</li>\n<li><a href=\"https://github.com/ebryn/backburner.js\">https://github.com/ebryn/backburner.js</a></li>\n</ul>","link":"./JP/contributing/repositories.ja-JP.html","spaLink":"#/JP/contributing/repositories.ja-JP","title":"PACKAGES/EMBER-METAL/LIB/VENDOR/BACKBURNER.JS"},{"content":"<h2 id=\"ember-packagesember-routinglibvendorroute-recognizerjs\"><code>packages/ember-routing/lib/vendor/route-recognizer.js</code></h2><ul>\n<li><strong>route-recognizer.js</strong> - JavaScript の軽量なライブラリ、登録されたルートと、パスを一致させます。</li>\n<li><a href=\"https://github.com/tildeio/route-recognizer\">https://github.com/tildeio/route-recognizer</a></li>\n</ul>","link":"./JP/contributing/repositories.ja-JP.html","spaLink":"#/JP/contributing/repositories.ja-JP","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTE-RECOGNIZER.JS"},{"content":"<h2 id=\"ember-packagesember-routinglibvendorrouterjs\"><code>packages/ember-routing/lib/vendor/router.js</code></h2><ul>\n<li><strong>router.js</strong> - JavaScript の軽量なライブラリ、route-recognizerと rsvp の上で構築され、ルートを処理するためのAPIを提供しています。</li>\n<li><a href=\"https://github.com/tildeio/router.js\">https://github.com/tildeio/router.js</a></li>\n</ul>","link":"./JP/contributing/repositories.ja-JP.html","spaLink":"#/JP/contributing/repositories.ja-JP","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTER.JS"},{"content":"<h2 id=\"ember-packagesmetamorph\"><code>packages/metamorph</code></h2><ul>\n<li><strong>Metamorph.js</strong> - Emberがhandlebars テンプレートのデータバインドのために利用しています。</li>\n<li><a href=\"https://github.com/tomhuda/metamorph.js\">https://github.com/tomhuda/metamorph.js</a></li>\n</ul>","link":"./JP/contributing/repositories.ja-JP.html","spaLink":"#/JP/contributing/repositories.ja-JP","title":"PACKAGES/METAMORPH"},{"content":"<h2 id=\"ember-packagesrsvp\"><code>packages/rsvp</code></h2><ul>\n<li><strong>RSVP.js</strong> - Emberによる、Promises/A+ の実装。</li>\n<li><a href=\"https://github.com/tildeio/rsvp.js\">https://github.com/tildeio/rsvp.js</a></li>\n</ul>","link":"./JP/contributing/repositories.ja-JP.html","spaLink":"#/JP/contributing/repositories.ja-JP","title":"PACKAGES/RSVP"}]