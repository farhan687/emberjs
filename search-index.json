[{"content":"<h2 id=\"-factory-registrations\">Factory Registrations</h2><p>A factory can represent any part of your application, like a <em>route</em>, <em>template</em>, or custom class. Every factory is registered with a particular key. For example, the index template is registered with the key <code>template:index</code>, and the application route is registered with the key <code>route:application</code>.</p><p>Registration keys have two segments split by a colon (<code>:</code>). The first segment is the framework factory type, and the second is the name of the particular factory. Hence, the <code>index</code> template has the key <code>template:index</code>. Ember has several built-in factory types, such as <code>service</code>, <code>route</code>, <code>template</code>, and <code>component</code>.</p><p>You can create your own factory type by simply registering a factory with the new type. For example, to create a <code>user</code> type, you’d simply register your factory with <code>application.register('user:user-to-register')</code>.</p><p>Factory registrations must be performed either in application or application instance initializers (with the former being much more common).</p><p>For example, an application initializer could register a <code>Logger</code> factory with the key <code>logger:main</code>:</p><p>```app/initializers/logger.js export function initialize(application) { var Logger = Ember.Object.extend({ log(m) { console.log(m); } });</p><p>application.register(‘logger:main’, Logger); }</p><p>export default { name: ‘logger’, initialize: initialize };</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"FACTORY REGISTRATIONS"},{"content":"<h3 id=\"-factory-registrations-registering-singletons-vs-non-singletons\">Registering Singletons vs. Non-Singletons</h3><p>By default, registrations are treated as “singletons”. This simply means that an instance will be created when it is first looked up, and this same instance will be cached and returned from subsequent lookups.</p><p>When you want fresh objects to be created for every lookup, register your factories as non-singletons using the <code>singleton: false</code> option.</p><p>In the following example, the <code>Message</code> class is registered as a non-singleton:</p><p>```app/initializers/notification.js export function initialize(application) { var Message = Ember.Object.extend({ text: ‘’ });</p><p>application.register(‘notification:message’, Message, { singleton: false }); }</p><p>export default { name: ‘notification’, initialize: initialize };</p><p>As a result of this type injection, all factories of the type <code>route</code> will be instantiated with the property <code>logger</code> injected. The value of <code>logger</code> will come from the factory named <code>logger:main</code>.</p><p>Routes in this example application can now access the injected logger:</p><p>```app/routes/index.js export default Ember.Route.extend({ activate() { // The logger property is injected into all routes this.get(‘logger’).log(‘Entered the index route!’); } });</p><p>In this case, the logger will only be injected on the index route.</p><p>Injections can be made onto any class that requires instantiation. This includes all of Ember’s major framework classes, such as components, helpers, routes, and the router.</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"Registering Singletons vs. Non-Singletons"},{"content":"<h3 id=\"-factory-registrations-ad-hoc-injections\">Ad Hoc Injections</h3><p>Dependency injections can also be declared directly on Ember classes using <code>Ember.inject</code>. Currently, <code>Ember.inject</code> supports injecting controllers (via <code>Ember.inject.controller</code>) and services (via <code>Ember.inject.service</code>).</p><p>The following code injects the <code>shopping-cart</code> service on the <code>cart-contents</code> component as the property <code>cart</code>:</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ cart: Ember.inject.service(‘shopping-cart’) });</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"Ad Hoc Injections"},{"content":"<h2 id=\"-factory-instance-lookups\">Factory Instance Lookups</h2><p>To fetch an instantiated factory from the running application you can call the <a href=\"http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup\"><code>lookup</code></a> method on an application instance. This method takes a string to identify a factory and returns the appropriate object.</p><p>The application instance is passed to Ember’s instance initializer hooks and it is added as the “owner” of each object that was instantiated by the application instance.</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"FACTORY INSTANCE LOOKUPS"},{"content":"<h3 id=\"-factory-instance-lookups-using-an-application-instance-within-an-instance-initializer\">Using an Application Instance Within an Instance Initializer</h3><p>Instance initializers receive an application instance as an argument, providing an opportunity to look up an instance of a registered factory.</p><p>```app/instance-initializers/logger.js export function initialize(applicationInstance) { let logger = applicationInstance.lookup(‘logger:main’);</p><p>logger.log(‘Hello from the instance initializer!’); }</p><p>export default { name: ‘logger’, initialize: initialize };</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"Using an Application Instance Within an Instance Initializer"},{"content":"<h3 id=\"-customizing-the-element\">Customizing the Element</h3><p>To use a tag other than <code>div</code>, subclass <code>Ember.Component</code> and assign it a <code>tagName</code> property. This property can be any valid HTML5 tag name as a string.</p><p>```app/components/navigation-bar.js export default Ember.Component.extend({ tagName: ‘nav’ });</p>","link":"./BR/components/customizing-a-components-element.pt-BR.html","spaLink":"#/BR/components/customizing-a-components-element.pt-BR","title":"Customizing the Element"},{"content":"<h3 id=\"-customizing-class-names\">Customizing Class Names</h3><p>You can also specify which class names are applied to the component’s element by setting its <code>classNames</code> property to an array of strings:</p><p>```app/components/navigation-bar.js export default Ember.Component.extend({ classNames: [‘primary’] });</p><p>This component would render the following:</p><p>If <code>isUrgent</code> is changed to <code>false</code>, then the <code>is-urgent</code> class name will be removed.</p><p>By default, the name of the Boolean property is dasherized. You can customize the class name applied by delimiting it with a colon:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isUrgent:urgent’], isUrgent: true });</p><p>Besides the custom class name for the value being <code>true</code>, you can also specify a class name which is used when the value is <code>false</code>:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isEnabled:enabled:disabled’], isEnabled: false });</p><p>You can also specify a class which should only be added when the property is <code>false</code> by declaring <code>classNameBindings</code> like this:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘isEnabled::disabled’], isEnabled: false });</p><p>If the <code>isEnabled</code> property is set to <code>true</code>, no class name is added:</p><p>If the bound property’s value is a string, that value will be added as a class name without modification:</p><p>```app/components/todo-item.js export default Ember.Component.extend({ classNameBindings: [‘priority’], priority: ‘highestPriority’ });</p>","link":"./BR/components/customizing-a-components-element.pt-BR.html","spaLink":"#/BR/components/customizing-a-components-element.pt-BR","title":"Customizing Class Names"},{"content":"<h3 id=\"-customizing-attributes\">Customizing Attributes</h3><p>You can bind attributes to the DOM element that represents a component by using <code>attributeBindings</code>:</p><p>```app/components/link-item.js export default Ember.Component.extend({ tagName: ‘a’, attributeBindings: [‘href’], href: ‘<a href=\"http://emberjs.com\">http://emberjs.com</a>‘ });</p><p>If the attribute is null, it won’t be rendered:</p><p>```app/components/link-item.js export default Ember.Component.extend({ tagName: ‘span’, title: null, attributeBindings: [‘title’], });</p><p>…and this HTML when a title of “Ember JS” is passed to the component:</p>","link":"./BR/components/customizing-a-components-element.pt-BR.html","spaLink":"#/BR/components/customizing-a-components-element.pt-BR","title":"Customizing Attributes"},{"content":"<h1 id=\"title\">{{title}}</h1><p>{{yield}}</p><p>Edit title: {{input type=”text” value=title}}</p><p></p><p>Its model is populated in <code>model</code> hook in the route handler:</p><p>```app/routes/index.js export default Ember.Route.extend({ model() { return this.store.findAll(‘post’); } });</p><p>```app/templates/components/bar-component.hbs </p>","link":"./BR/components/defining-a-component.pt-BR.html","spaLink":"#/BR/components/defining-a-component.pt-BR","title":"{{TITLE}}"},{"content":"<h3 id=\"title-hello-from-bar\">Hello from bar!</h3><p>When the parameter passed to <code>{{component}}</code> evaluates to <code>null</code> or <code>undefined</code>, the helper renders nothing. When the parameter changes, the currently rendered component is destroyed and the new component is created and brought in.</p><p>Picking different components to render in response to the data allows you to have different template and behavior for each case. The <code>{{component}}</code> helper is a powerful tool for improving code modularity.</p>","link":"./BR/components/defining-a-component.pt-BR.html","spaLink":"#/BR/components/defining-a-component.pt-BR","title":"Hello from bar!"},{"content":"<h2 id=\"-routing\">Routing</h2><p>```app/app.js export default Ember.Application.extend({ // Basic logging, e.g. “Transitioned into ‘post’” LOG_TRANSITIONS: true,</p><p>// Extremely detailed logging, highlighting every internal // step made while transitioning into a route, including // <code>beforeModel</code>, <code>model</code>, and <code>afterModel</code> hooks, and // information about redirects and aborted transitions LOG_TRANSITIONS_INTERNAL: true });</p>","link":"./BR/configuring-ember/debugging.pt-BR.html","spaLink":"#/BR/configuring-ember/debugging.pt-BR","title":"ROUTING"},{"content":"<h2 id=\"-controllers\">Controllers</h2><p>```config/environment.js ENV.APP.LOG_ACTIVE_GENERATION = true;</p><p>```config/environments.js ENV.APP.LOG_BINDINGS = true</p><p>If you are using imports with Ember, be sure to import the console:</p><p>There are times when dealing with promises that it seems like any errors are being ‘swallowed’, and not properly raised. This makes it extremely difficult to track down where a given issue is coming from. Thankfully, <code>RSVP</code> has a solution for this problem built in.</p><p>You can provide an <code>onerror</code> function that will be called with the error details if any errors occur within your promise. This function can be anything, but a common practice is to call <code>console.assert</code> to dump the error to the console.</p><p>```app/app.js Ember.RSVP.on(‘error’, function(error) { Ember.Logger.assert(false, error); });</p>","link":"./BR/configuring-ember/debugging.pt-BR.html","spaLink":"#/BR/configuring-ember/debugging.pt-BR","title":"CONTROLLERS"},{"content":"<h3 id=\"-bug-fixes\">Bug Fixes</h3><p>Urgent bugfixes are bugfixes that need to be applied to the existing release branch. If possible, they should be made on master and prefixed with [BUGFIX release].</p><p>Beta bugfixes are bugfixes that need to be applied to the beta branch. If possible, they should be made on master and tagged with [BUGFIX beta].</p><p>Security fixes need to be applied to the beta branch, the current release branch, and the previous tag. If possible, they should be made on master and tagged with [SECURITY].</p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"Bug Fixes"},{"content":"<h3 id=\"-features\">Features</h3><p>Features must always be wrapped in a feature flag. Tests for the feature must also be wrapped in a feature flag.</p><p>Because the build-tools will process feature-flags, flags must use precisely this format. We are choosing conditionals rather than a block form because functions change the surrounding scope and may introduce problems with early return.</p><p>Tests will always run with all features on, so make sure that any tests for the feature are passing against the current state of the feature.</p><p>Commits related to a specific feature should include a prefix like [FEATURE htmlbars]. This will allow us to quickly identify all commits for a specific feature in the future. Features will never be applied to beta or release branches. Once a beta or release branch has been cut, it contains all of the new features it will ever have.</p><p>If a feature has made it into beta or release, and you make a commit to master that fixes a bug in the feature, treat it like a bugfix as described above.</p><p>```config/environment.js Ember.FEATURES[‘<packagename>-<feature>‘] // if package specific Ember.FEATURES[‘container-factory-injections’] Ember.FEATURES[‘htmlbars’]</feature></packagename></p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"Features"},{"content":"<h3 id=\"-featuresjson\"><code>features.json</code></h3><p>The root of the repository will contain a features.json file, which will contain a list of features that should be enabled for beta or release builds.</p><p>This file is populated when branching, and may not gain additional features after the original branch. It may remove features.</p><p>The build process will remove any features not included in the list, and remove the conditionals for features in the list.</p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"features.json"},{"content":"<h3 id=\"-travis-testing\">Travis Testing</h3><p>For a new PR:</p><p>For a new commit to master:</p><p>The idea is that new commits should be submitted as PRs to ensure they apply cleanly, and once the merge button is pressed, Travis will apply them to the right branches.</p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"Travis Testing"},{"content":"<h3 id=\"-gono-go-process\">Go/No-Go Process</h3><p>Every six weeks, the core team goes through the following process.</p><p>All remaining features on the beta branch are vetted for readiness. If any feature isn’t ready, it is removed from features.json.</p><p>Once this is done, the beta branch is tagged and merged into release.</p><p>All features on the master branch are vetted for readiness. In order for a feature to be considered “ready” at this stage, it must be ready as-is with no blockers. Features are a no-go even if they are close and additional work on the beta branch would make it ready.</p><p>Because this process happens every six weeks, there will be another opportunity for a feature to make it soon enough.</p><p>Once this is done, the master branch is merged into beta. A <code>features.json</code> file is added with the features that are ready.</p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"Go/No-Go Process"},{"content":"<h3 id=\"-beta-releases\">Beta Releases</h3><p>Every week, we repeat the Go/No-Go process for the features that remain on the beta branch. Any feature that has become unready is removed from the features.json.</p><p>Once this is done, a Beta release is tagged and pushed.</p>","link":"./BR/contributing/adding-new-features.pt-BR.html","spaLink":"#/BR/contributing/adding-new-features.pt-BR","title":"Beta Releases"},{"content":"<h1 id=\"main-repositories\">Main Repositories</h1><p><strong>Ember.js</strong> - The main repository for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/ember.js\">https://github.com/emberjs/ember.js</a></li>\n</ul><p><strong>Ember Data</strong> - A data persistence library for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/data\">https://github.com/emberjs/data</a></li>\n</ul><p><strong>Ember Website</strong> - Source for <a href=\"http://emberjs.com\">http://emberjs.com</a></p><ul>\n<li><a href=\"https://github.com/emberjs/website\">https://github.com/emberjs/website</a></li>\n</ul><p><strong>Ember Guides</strong> - Source for <a href=\"http://guides.emberjs.com\">http://guides.emberjs.com</a> which you are currently reading.</p><ul>\n<li><a href=\"https://github.com/emberjs/guides\">https://github.com/emberjs/guides</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"MAIN REPOSITORIES"},{"content":"<h1 id=\"libraries-used-by-ember\">Libraries Used By Ember</h1><p>These libraries are part of the Ember.js source, but development of them takes place in a separate repository.</p>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"LIBRARIES USED BY EMBER"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-metallibvendorbackburnerjs\"><code>packages/ember-metal/lib/vendor/backburner.js</code></h2><ul>\n<li><strong>backburner.js</strong> - Implements the Ember run loop.</li>\n<li><a href=\"https://github.com/ebryn/backburner.js\">https://github.com/ebryn/backburner.js</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"PACKAGES/EMBER-METAL/LIB/VENDOR/BACKBURNER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorroute-recognizerjs\"><code>packages/ember-routing/lib/vendor/route-recognizer.js</code></h2><ul>\n<li><strong>route-recognizer.js</strong> - A lightweight JavaScript library that matches paths against registered routes.</li>\n<li><a href=\"https://github.com/tildeio/route-recognizer\">https://github.com/tildeio/route-recognizer</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTE-RECOGNIZER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorrouterjs\"><code>packages/ember-routing/lib/vendor/router.js</code></h2><ul>\n<li><strong>router.js</strong> - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.</li>\n<li><a href=\"https://github.com/tildeio/router.js\">https://github.com/tildeio/router.js</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesmetamorph\"><code>packages/metamorph</code></h2><ul>\n<li><strong>Metamorph.js</strong> - Used by Ember for databinding handlebars templates</li>\n<li><a href=\"https://github.com/tomhuda/metamorph.js\">https://github.com/tomhuda/metamorph.js</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"PACKAGES/METAMORPH"},{"content":"<h2 id=\"libraries-used-by-ember-packagesrsvp\"><code>packages/rsvp</code></h2><ul>\n<li><strong>RSVP.js</strong> - Implementation of the of Promises/A+ spec used by Ember.</li>\n<li><a href=\"https://github.com/tildeio/rsvp.js\">https://github.com/tildeio/rsvp.js</a></li>\n</ul>","link":"./BR/contributing/repositories.pt-BR.html","spaLink":"#/BR/contributing/repositories.pt-BR","title":"PACKAGES/RSVP"},{"content":"<h2 id=\"-factory-registrations\">Factory Registrations</h2><p>A factory can represent any part of your application, like a <em>route</em>, <em>template</em>, or custom class.\nEvery factory is registered with a particular key.\nFor example, the index template is registered with the key <code>template:index</code>,\nand the application route is registered with the key <code>route:application</code>.</p><p>Registration keys have two segments split by a colon (<code>:</code>).\nThe first segment is the framework factory type, and the second is the name of the particular factory.\nHence, the <code>index</code> template has the key <code>template:index</code>.\nEmber has several built-in factory types, such as <code>service</code>, <code>route</code>, <code>template</code>, and <code>component</code>.</p><p>You can create your own factory type by simply registering a factory with the new type.\nFor example, to create a <code>user</code> type,\nyou’d simply register your factory with <code>application.register('user:user-to-register')</code>.</p><p>Factory registrations must be performed either in application\nor application instance initializers (with the former being much more common).</p><p>For example, an application initializer could register a <code>Logger</code> factory with the key <code>logger:main</code>:</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"FACTORY REGISTRATIONS"},{"content":"<h3 id=\"-factory-registrations-registering-already-instantiated-objects\">Registering Already Instantiated Objects</h3><p>By default, Ember will attempt to instantiate a registered factory when it is looked up.\nWhen registering an already instantiated object instead of a class,\nuse the <code>instantiate: false</code> option to avoid attempts to re-instantiate it during lookups.</p><p>In the following example, the <code>logger</code> is a plain JavaScript object that should\nbe returned “as is” when it’s looked up:</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"Registering Already Instantiated Objects"},{"content":"<h3 id=\"-factory-registrations-registering-singletons-vs-non-singletons\">Registering Singletons vs. Non-Singletons</h3><p>By default, registrations are treated as “singletons”.\nThis simply means that an instance will be created when it is first looked up,\nand this same instance will be cached and returned from subsequent lookups.</p><p>When you want fresh objects to be created for every lookup,\nregister your factories as non-singletons using the <code>singleton: false</code> option.</p><p>In the following example, the <code>Message</code> class is registered as a non-singleton:</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"Registering Singletons vs. Non-Singletons"},{"content":"<h2 id=\"-factory-injections\">Factory Injections</h2><p>Once a factory is registered, it can be “injected” where it is needed.</p><p>Factories can be injected into whole “types” of factories with <em>type injections</em>. For example:</p><p>As a result of this type injection,\nall factories of the type <code>route</code> will be instantiated with the property <code>logger</code> injected.\nThe value of <code>logger</code> will come from the factory named <code>logger:main</code>.</p><p>Routes in this example application can now access the injected logger:</p><p>Injections can also be made on a specific factory by using its full key:</p><p>In this case, the logger will only be injected on the index route.</p><p>Injections can be made onto any class that requires instantiation.\nThis includes all of Ember’s major framework classes, such as components, helpers, routes, and the router.</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"FACTORY INJECTIONS"},{"content":"<h3 id=\"-factory-injections-ad-hoc-injections\">Ad Hoc Injections</h3><p>Dependency injections can also be declared directly on Ember classes using <code>Ember.inject</code>.\nCurrently, <code>Ember.inject</code> supports injecting controllers (via <code>Ember.inject.controller</code>)\nand services (via <code>Ember.inject.service</code>).</p><p>The following code injects the <code>shopping-cart</code> service on the <code>cart-contents</code> component as the property <code>cart</code>:</p><p>If you’d like to inject a service with the same name as the property,\nsimply leave off the service name (the dasherized version of the name will be used):</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"Ad Hoc Injections"},{"content":"<h2 id=\"-factory-instance-lookups\">Factory Instance Lookups</h2><p>To fetch an instantiated factory from the running application you can call the\n<a href=\"http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup\"><code>lookup</code></a> method on an application instance. This method takes a string\nto identify a factory and returns the appropriate object.</p><p>The application instance is passed to Ember’s instance initializer hooks and it\nis added as the “owner” of each object that was instantiated by the application\ninstance.</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"FACTORY INSTANCE LOOKUPS"},{"content":"<h3 id=\"-factory-instance-lookups-using-an-application-instance-within-an-instance-initializer\">Using an Application Instance Within an Instance Initializer</h3><p>Instance initializers receive an application instance as an argument, providing\nan opportunity to look up an instance of a registered factory.</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"Using an Application Instance Within an Instance Initializer"},{"content":"<h3 id=\"-factory-instance-lookups-getting-an-application-instance-from-a-factory-instance\">Getting an Application Instance from a Factory Instance</h3><p><a href=\"http://emberjs.com/api/#method_getOwner\"><code>Ember.getOwner</code></a> will retrieve the application instance that “owns” an\nobject. This means that framework objects like components, helpers, and routes\ncan use <a href=\"http://emberjs.com/api/#method_getOwner\"><code>Ember.getOwner</code></a> to perform lookups through their application\ninstance at runtime.</p><p>For example, this component plays songs with different audio services based\non a song’s <code>audioType</code>.</p>","link":"./EN/applications/dependency-injection.html","spaLink":"#/EN/applications/dependency-injection","title":"Getting an Application Instance from a Factory Instance"},{"content":"<h3 id=\"-customizing-the-element\">Customizing the Element</h3><p>To use a tag other than <code>div</code>, subclass <code>Ember.Component</code> and assign it\na <code>tagName</code> property. This property can be any valid HTML5 tag name as a\nstring.</p>","link":"./EN/components/customizing-a-components-element.html","spaLink":"#/EN/components/customizing-a-components-element","title":"Customizing the Element"},{"content":"<h3 id=\"-customizing-class-names\">Customizing Class Names</h3><p>You can also specify which class names are applied to the component’s\nelement by setting its <code>classNames</code> property to an array of strings:</p><p>If you want class names to be determined by properties of the component,\nyou can use class name bindings. If you bind to a Boolean property, the\nclass name will be added or removed depending on the value:</p><p>This component would render the following:</p><p>If <code>isUrgent</code> is changed to <code>false</code>, then the <code>is-urgent</code> class name will be removed.</p><p>By default, the name of the Boolean property is dasherized. You can customize the class name\napplied by delimiting it with a colon:</p><p>This would render this HTML:</p><p>Besides the custom class name for the value being <code>true</code>, you can also specify a class name which is used when the value is <code>false</code>:</p><p>This would render this HTML:</p><p>You can also specify a class which should only be added when the property is\n<code>false</code> by declaring <code>classNameBindings</code> like this:</p><p>This would render this HTML:</p><p>If the <code>isEnabled</code> property is set to <code>true</code>, no class name is added:</p><p>If the bound property’s value is a string, that value will be added as a class name without\nmodification:</p><p>This would render this HTML:</p>","link":"./EN/components/customizing-a-components-element.html","spaLink":"#/EN/components/customizing-a-components-element","title":"Customizing Class Names"},{"content":"<h3 id=\"-customizing-attributes\">Customizing Attributes</h3><p>You can bind attributes to the DOM element that represents a component\nby using <code>attributeBindings</code>:</p><p>You can also bind these attributes to differently named properties:</p><p>If the attribute is null, it won’t be rendered:</p><p>This would render this HTML when no title is passed to the component:</p><p>…and this HTML when a title of “Ember JS” is passed to the component:</p>","link":"./EN/components/customizing-a-components-element.html","spaLink":"#/EN/components/customizing-a-components-element","title":"Customizing Attributes"},{"content":"<h2 id=\"-defining-a-component-subclass\">Defining a Component Subclass</h2><p>Often times, your components will just encapsulate certain snippets of\nHandlebars templates that you find yourself using over and over. In\nthose cases, you do not need to write any JavaScript at all. Define\nthe Handlebars template as described above and use the component that is\ncreated.</p><p>If you need to customize the behavior of the component you’ll\nneed to define a subclass of <a href=\"http://emberjs.com/api/classes/Ember.Component.html\"><code>Ember.Component</code></a>. For example, you would\nneed a custom subclass if you wanted to change a component’s element,\nrespond to actions from the component’s template, or manually make\nchanges to the component’s element using JavaScript.</p><p>Ember knows which subclass powers a component based on its filename. For\nexample, if you have a component called <code>blog-post</code>, you would create a\nfile at <code>app/components/blog-post.js</code>. If your component was called\n<code>audio-player-controls</code>, the file name would be at\n<code>app/components/audio-player-controls.js</code>.</p>","link":"./EN/components/defining-a-component.html","spaLink":"#/EN/components/defining-a-component","title":"DEFINING A COMPONENT SUBCLASS"},{"content":"<h2 id=\"-dynamically-rendering-a-component\">Dynamically rendering a component</h2><p>The <a href=\"http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component\"><code>{{component}}</code></a> helper can be used to defer the selection of a component to\nrun time. The <code>{{my-component}}</code> syntax always renders the same component,\nwhile using the <code>{{component}}</code> helper allows choosing a component to render on\nthe fly. This is useful in cases where you want to interact with different\nexternal libraries depending on the data. Using the <code>{{component}}</code> helper would\nallow you to keep different logic well separated.</p><p>The first parameter of the helper is the name of a component to render, as a\nstring. So <code>{{component 'blog-post'}}</code> is the same as using <code>{{blog-post}}</code>.</p><p>The real value of <a href=\"http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component\"><code>{{component}}</code></a> comes from being able to dynamically pick\nthe component being rendered. Below is an example of using the helper as a\nmeans of choosing different components for displaying different kinds of posts:</p><p>When the parameter passed to <code>{{component}}</code> evaluates to <code>null</code> or <code>undefined</code>,\nthe helper renders nothing. When the parameter changes, the currently rendered\ncomponent is destroyed and the new component is created and brought in.</p><p>Picking different components to render in response to the data allows you to\nhave different template and behavior for each case. The <code>{{component}}</code> helper\nis a powerful tool for improving code modularity.</p>","link":"./EN/components/defining-a-component.html","spaLink":"#/EN/components/defining-a-component","title":"DYNAMICALLY RENDERING A COMPONENT"},{"content":"<h2 id=\"-routing\">Routing</h2>","link":"./EN/configuring-ember/debugging.html","spaLink":"#/EN/configuring-ember/debugging","title":"ROUTING"},{"content":"<h2 id=\"-views-templates\">Views / Templates</h2>","link":"./EN/configuring-ember/debugging.html","spaLink":"#/EN/configuring-ember/debugging","title":"VIEWS / TEMPLATES"},{"content":"<h2 id=\"-controllers\">Controllers</h2>","link":"./EN/configuring-ember/debugging.html","spaLink":"#/EN/configuring-ember/debugging","title":"CONTROLLERS"},{"content":"<h2 id=\"-observers-binding\">Observers / Binding</h2>","link":"./EN/configuring-ember/debugging.html","spaLink":"#/EN/configuring-ember/debugging","title":"OBSERVERS / BINDING"},{"content":"<h2 id=\"-miscellaneous\">Miscellaneous</h2><p>This option logs all the lookups that are done to the console. Custom objects\nyou’ve created yourself have a tick, and Ember generated ones don’t.</p><p>It’s useful for understanding which objects Ember is finding when it does a lookup\nand which it is generating automatically for you.</p><p>If you are using imports with Ember, be sure to import the console:</p><p>There are times when dealing with promises that it seems like any errors\nare being ‘swallowed’, and not properly raised. This makes it extremely\ndifficult to track down where a given issue is coming from. Thankfully,\n<code>RSVP</code> has a solution for this problem built in.</p><p>You can provide an <code>onerror</code> function that will be called with the error\ndetails if any errors occur within your promise. This function can be anything,\nbut a common practice is to call <code>console.assert</code> to dump the error to the\nconsole.</p><p>Backburner has support for stitching the stacktraces together so that you can\ntrack down where an erroring <code>Ember.run.later</code> is being initiated from. Unfortunately,\nthis is quite slow and is not appropriate for production or even normal development.</p><p>To enable this mode you can set:</p>","link":"./EN/configuring-ember/debugging.html","spaLink":"#/EN/configuring-ember/debugging","title":"MISCELLANEOUS"},{"content":"<h3 id=\"-bug-fixes\">Bug Fixes</h3><p>Urgent bugfixes are bugfixes that need to be applied to the existing\nrelease branch. If possible, they should be made on master and prefixed\nwith [BUGFIX release].</p><p>Beta bugfixes are bugfixes that need to be applied to the beta branch.\nIf possible, they should be made on master and tagged with [BUGFIX\nbeta].</p><p>Security fixes need to be applied to the beta branch, the current\nrelease branch, and the previous tag. If possible, they should be made\non master and tagged with [SECURITY].</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Bug Fixes"},{"content":"<h3 id=\"-features\">Features</h3><p>Features must always be wrapped in a feature flag. Tests for the feature\nmust also be wrapped in a feature flag.</p><p>Because the build-tools will process feature-flags, flags must use\nprecisely this format. We are choosing conditionals rather than a block\nform because functions change the surrounding scope and may introduce\nproblems with early return.</p><p>Tests will always run with all features on, so make sure that any tests\nfor the feature are passing against the current state of the feature.</p><p>Commits related to a specific feature should include  a prefix like\n[FEATURE htmlbars]. This will allow us to quickly identify all commits\nfor a specific feature in the future. Features will never be applied to\nbeta or release branches. Once a beta or release branch has been cut, it\ncontains all of the new features it will ever have.</p><p>If a feature has made it into beta or release, and you make a commit to\nmaster that fixes a bug in the feature, treat it like a bugfix as\ndescribed above.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Features"},{"content":"<h3 id=\"-builds\">Builds</h3><p>The Canary build, which is based off master, will include all features,\nguarded by the conditionals in the original source. This means that\nusers of the canary build can enable whatever features they want by\nenabling them before creating their Ember.Application.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Builds"},{"content":"<h3 id=\"-featuresjson\"><code>features.json</code></h3><p>The root of the repository will contain a features.json file, which will\ncontain a list of features that should be enabled for beta or release\nbuilds.</p><p>This file is populated when branching, and may not gain additional\nfeatures after the original branch. It may remove features.</p><p>The build process will remove any features not included in the list, and\nremove the conditionals for features in the list.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"features.json"},{"content":"<h3 id=\"-travis-testing\">Travis Testing</h3><p>For a new PR:</p><p>For a new commit to master:</p><p>The idea is that new commits should be submitted as PRs to ensure they\napply cleanly, and once the merge button is pressed, Travis will apply\nthem to the right branches.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Travis Testing"},{"content":"<h3 id=\"-gono-go-process\">Go/No-Go Process</h3><p>Every six weeks, the core team goes through the following process.</p><p>All remaining features on the beta branch are vetted for readiness. If\nany feature isn’t ready, it is removed from features.json.</p><p>Once this is done, the beta branch is tagged and merged into release.</p><p>All features on the master branch are vetted for readiness. In order for\na feature to be considered “ready” at this stage, it must be ready as-is\nwith no blockers. Features are a no-go even if they are close and\nadditional work on the beta branch would make it ready.</p><p>Because this process happens every six weeks, there will be another\nopportunity for a feature to make it soon enough.</p><p>Once this is done, the master branch is merged into beta. A\n<code>features.json</code> file is added with the features that are ready.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Go/No-Go Process"},{"content":"<h3 id=\"-beta-releases\">Beta Releases</h3><p>Every week, we repeat the Go/No-Go process for the features that remain\non the beta branch. Any feature that has become unready is removed from\nthe features.json.</p><p>Once this is done, a Beta release is tagged and pushed.</p>","link":"./EN/contributing/adding-new-features.html","spaLink":"#/EN/contributing/adding-new-features","title":"Beta Releases"},{"content":"<h1 id=\"main-repositories\">Main Repositories</h1><p><strong>Ember.js</strong> - The main repository for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/ember.js\"></a><a href=\"https://github.com/emberjs/ember.js\">https://github.com/emberjs/ember.js</a></li>\n</ul><p><strong>Ember Data</strong> - A data persistence library for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/data\"></a><a href=\"https://github.com/emberjs/data\">https://github.com/emberjs/data</a></li>\n</ul><p><strong>Ember Website</strong> - Source for <a href=\"http://emberjs.com\"></a><a href=\"http://emberjs.com\">http://emberjs.com</a></p><ul>\n<li><a href=\"https://github.com/emberjs/website\"></a><a href=\"https://github.com/emberjs/website\">https://github.com/emberjs/website</a></li>\n</ul><p><strong>Ember Guides</strong> - Source for <a href=\"http://guides.emberjs.com\"></a><a href=\"http://guides.emberjs.com\">http://guides.emberjs.com</a> which you are currently reading.</p><ul>\n<li><a href=\"https://github.com/emberjs/guides\"></a><a href=\"https://github.com/emberjs/guides\">https://github.com/emberjs/guides</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"MAIN REPOSITORIES"},{"content":"<h1 id=\"libraries-used-by-ember\">Libraries Used By Ember</h1><p>These libraries are part of the Ember.js source, but development of them takes place in a separate repository.</p>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"LIBRARIES USED BY EMBER"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-metallibvendorbackburnerjs\"><code>packages/ember-metal/lib/vendor/backburner.js</code></h2><ul>\n<li><strong>backburner.js</strong> - Implements the Ember run loop.</li>\n<li><a href=\"https://github.com/ebryn/backburner.js\"></a><a href=\"https://github.com/ebryn/backburner.js\">https://github.com/ebryn/backburner.js</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"PACKAGES/EMBER-METAL/LIB/VENDOR/BACKBURNER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorroute-recognizerjs\"><code>packages/ember-routing/lib/vendor/route-recognizer.js</code></h2><ul>\n<li><strong>route-recognizer.js</strong> - A lightweight JavaScript library that matches paths against registered routes.</li>\n<li><a href=\"https://github.com/tildeio/route-recognizer\"></a><a href=\"https://github.com/tildeio/route-recognizer\">https://github.com/tildeio/route-recognizer</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTE-RECOGNIZER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorrouterjs\"><code>packages/ember-routing/lib/vendor/router.js</code></h2><ul>\n<li><strong>router.js</strong> - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.</li>\n<li><a href=\"https://github.com/tildeio/router.js\"></a><a href=\"https://github.com/tildeio/router.js\">https://github.com/tildeio/router.js</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesmetamorph\"><code>packages/metamorph</code></h2><ul>\n<li><strong>Metamorph.js</strong> - Used by Ember for databinding handlebars templates</li>\n<li><a href=\"https://github.com/tomhuda/metamorph.js\"></a><a href=\"https://github.com/tomhuda/metamorph.js\">https://github.com/tomhuda/metamorph.js</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"PACKAGES/METAMORPH"},{"content":"<h2 id=\"libraries-used-by-ember-packagesrsvp\"><code>packages/rsvp</code></h2><ul>\n<li><strong>RSVP.js</strong> - Implementation of the of Promises/A+ spec used by Ember.</li>\n<li><a href=\"https://github.com/tildeio/rsvp.js\"></a><a href=\"https://github.com/tildeio/rsvp.js\">https://github.com/tildeio/rsvp.js</a></li>\n</ul>","link":"./EN/contributing/repositories.html","spaLink":"#/EN/contributing/repositories","title":"PACKAGES/RSVP"}]