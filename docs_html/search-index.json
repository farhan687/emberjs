[{"content":"<h2 id=\"-factory-registrations\">Factory Registrations</h2><p>A factory can represent any part of your application, like a <em>route</em>, <em>template</em>, or custom class.\nEvery factory is registered with a particular key.\nFor example, the index template is registered with the key <code>template:index</code>,\nand the application route is registered with the key <code>route:application</code>.</p><p>Registration keys have two segments split by a colon (<code>:</code>).\nThe first segment is the framework factory type, and the second is the name of the particular factory.\nHence, the <code>index</code> template has the key <code>template:index</code>.\nEmber has several built-in factory types, such as <code>service</code>, <code>route</code>, <code>template</code>, and <code>component</code>.</p><p>You can create your own factory type by simply registering a factory with the new type.\nFor example, to create a <code>user</code> type,\nyou’d simply register your factory with <code>application.register('user:user-to-register')</code>.</p><p>Factory registrations must be performed either in application\nor application instance initializers (with the former being much more common).</p><p>For example, an application initializer could register a <code>Logger</code> factory with the key <code>logger:main</code>:</p>","link":"./A1/applications/dependency-injection.html","spaLink":"#/A1/applications/dependency-injection","title":"FACTORY REGISTRATIONS"},{"content":"<h3 id=\"-factory-registrations-registering-already-instantiated-objects\">Registering Already Instantiated Objects</h3><p>By default, Ember will attempt to instantiate a registered factory when it is looked up.\nWhen registering an already instantiated object instead of a class,\nuse the <code>instantiate: false</code> option to avoid attempts to re-instantiate it during lookups.</p><p>In the following example, the <code>logger</code> is a plain JavaScript object that should\nbe returned “as is” when it’s looked up:</p>","link":"./A1/applications/dependency-injection.html","spaLink":"#/A1/applications/dependency-injection","title":"Registering Already Instantiated Objects"},{"content":"<h3 id=\"-factory-registrations-registering-singletons-vs-non-singletons\">Registering Singletons vs. Non-Singletons</h3><p>By default, registrations are treated as “singletons”.\nThis simply means that an instance will be created when it is first looked up,\nand this same instance will be cached and returned from subsequent lookups.</p><p>When you want fresh objects to be created for every lookup,\nregister your factories as non-singletons using the <code>singleton: false</code> option.</p><p>In the following example, the <code>Message</code> class is registered as a non-singleton:</p>","link":"./A1/applications/dependency-injection.html","spaLink":"#/A1/applications/dependency-injection","title":"Registering Singletons vs. Non-Singletons"},{"content":"<h2 id=\"-factory-injections\">Factory Injections</h2><p>Once a factory is registered, it can be “injected” where it is needed.</p><p>Factories can be injected into whole “types” of factories with <em>type injections</em>. For example:</p><p>As a result of this type injection,\nall factories of the type <code>route</code> will be instantiated with the property <code>logger</code> injected.\nThe value of <code>logger</code> will come from the factory named <code>logger:main</code>.</p><p>Routes in this example application can now access the injected logger:</p><p>Injections can also be made on a specific factory by using its full key:</p><p>In this case, the logger will only be injected on the index route.</p><p>Injections can be made onto any class that requires instantiation.\nThis includes all of Ember’s major framework classes, such as components, helpers, routes, and the router.</p>","link":"./A1/applications/dependency-injection.html","spaLink":"#/A1/applications/dependency-injection","title":"FACTORY INJECTIONS"},{"content":"<h3 id=\"-factory-injections-ad-hoc-injections\">Ad Hoc Injections</h3><p>Dependency injections can also be declared directly on Ember classes using <code>Ember.inject</code>.\nCurrently, <code>Ember.inject</code> supports injecting controllers (via <code>Ember.inject.controller</code>)\nand services (via <code>Ember.inject.service</code>).</p><p>The following code injects the <code>shopping-cart</code> service on the <code>cart-contents</code> component as the property <code>cart</code>:</p><p>If you’d like to inject a service with the same name as the property,\nsimply leave off the service name (the dasherized version of the name will be used):</p>","link":"./A1/applications/dependency-injection.html","spaLink":"#/A1/applications/dependency-injection","title":"Ad Hoc Injections"},{"content":"<h2 id=\"-factory-instance-lookups\">Factory Instance Lookups</h2><p>To fetch an instantiated factory from the running application you can call the\n<a href=\"http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup\"><code>lookup</code></a> method on an application instance. This method takes a string\nto identify a factory and returns the appropriate object.</p><p>The application instance is passed to Ember’s instance initializer hooks and it\nis added as the “owner” of each object that was instantiated by the application\ninstance.</p>","link":"./A1/applications/dependency-injection.html","spaLink":"#/A1/applications/dependency-injection","title":"FACTORY INSTANCE LOOKUPS"},{"content":"<h3 id=\"-factory-instance-lookups-using-an-application-instance-within-an-instance-initializer\">Using an Application Instance Within an Instance Initializer</h3><p>Instance initializers receive an application instance as an argument, providing\nan opportunity to look up an instance of a registered factory.</p>","link":"./A1/applications/dependency-injection.html","spaLink":"#/A1/applications/dependency-injection","title":"Using an Application Instance Within an Instance Initializer"},{"content":"<h3 id=\"-factory-instance-lookups-getting-an-application-instance-from-a-factory-instance\">Getting an Application Instance from a Factory Instance</h3><p><a href=\"http://emberjs.com/api/#method_getOwner\"><code>Ember.getOwner</code></a> will retrieve the application instance that “owns” an\nobject. This means that framework objects like components, helpers, and routes\ncan use <a href=\"http://emberjs.com/api/#method_getOwner\"><code>Ember.getOwner</code></a> to perform lookups through their application\ninstance at runtime.</p><p>For example, this component plays songs with different audio services based\non a song’s <code>audioType</code>.</p>","link":"./A1/applications/dependency-injection.html","spaLink":"#/A1/applications/dependency-injection","title":"Getting an Application Instance from a Factory Instance"},{"content":"<h2 id=\"-application-initializers\">Application Initializers</h2><p>Application initializers can be created with Ember CLI’s <code>initializer</code> generator:</p><p>Let’s customize the <code>shopping-cart</code> initializer to inject a <code>cart</code> property into all the routes in your application:</p>","link":"./A1/applications/initializers.html","spaLink":"#/A1/applications/initializers","title":"APPLICATION INITIALIZERS"},{"content":"<h2 id=\"-application-instance-initializers\">Application Instance Initializers</h2><p>Application instance initializers can be created with Ember CLI’s <code>instance-initializer</code> generator:</p><p>Let’s add some simple logging to indicate that the instance has booted:</p>","link":"./A1/applications/initializers.html","spaLink":"#/A1/applications/initializers","title":"APPLICATION INSTANCE INITIALIZERS"},{"content":"<h2 id=\"-specifying-initializer-order\">Specifying Initializer Order</h2><p>If you’d like to control the order in which initializers run, you can use the <code>before</code> and/or <code>after</code> options:</p><p>Note that ordering only applies to initializers of the same type (i.e. application or application instance).\nApplication initializers will always run before application instance initializers.</p>","link":"./A1/applications/initializers.html","spaLink":"#/A1/applications/initializers","title":"SPECIFYING INITIALIZER ORDER"},{"content":"<h2 id=\"-why-is-the-run-loop-useful\">Why is the run loop useful?</h2><p>Very often, batching similar work has benefits.\nWeb browsers do something quite similar by batching changes to the DOM.</p><p>Consider the following HTML snippet:</p><p>and executing the following code:</p><p>In this example, the sequence of code forced the browser to recalculate style, and relayout after each step.\nHowever, if we were able to batch similar jobs together,\nthe browser would have only needed to recalculate the style and layout once.</p><p>Interestingly, this pattern holds true for many other types of work.\nEssentially, batching similar work allows for better pipelining, and further optimization.</p><p>Let’s look at a similar example that is optimized in Ember, starting with a <code>User</code> object:</p><p>and a template to display its attributes:</p><p>If we execute the following code without the run loop:</p><p>We see that the browser will rerender the template twice.</p><p>However, if we have the run loop in the above code,\nthe browser will only rerender the template once the attributes have all been set.</p><p>In the above example with the run loop, since the user’s attributes end up at the same values as before execution,\nthe template will not even rerender!</p><p>It is of course possible to optimize these scenarios on a case-by-case basis,\nbut getting them for free is much nicer.\nUsing the run loop, we can apply these classes of optimizations not only for each scenario, but holistically app-wide.</p>","link":"./A1/applications/run-loop.html","spaLink":"#/A1/applications/run-loop","title":"WHY IS THE RUN LOOP USEFUL?"},{"content":"<h2 id=\"-how-does-the-run-loop-work-in-ember\">How does the Run Loop work in Ember?</h2><p>As mentioned earlier, we schedule work (in the form of function invocations) on queues,\nand these queues are processed to completion in priority order.</p><p>What are the queues, and what is their priority order?</p><p>Because the priority is first to last, the “sync” queue has higher priority than the “render” or “destroy” queue.</p>","link":"./A1/applications/run-loop.html","spaLink":"#/A1/applications/run-loop","title":"HOW DOES THE RUN LOOP WORK IN EMBER?"},{"content":"<h2 id=\"-what-happens-in-these-queues\">What happens in these queues?</h2><ul>\n<li>The <code>sync</code> queue contains binding synchronization jobs.</li>\n<li>The <code>actions</code> queue is the general work queue and will typically contain scheduled tasks e.g. promises.</li>\n<li>The <code>routerTransitions</code> queue contains transition jobs in the router.</li>\n<li>The <code>render</code> queue contains jobs meant for rendering, these will typically update the DOM.</li>\n<li>The <code>afterRender</code> queue contains jobs meant to be run after all previously scheduled render tasks are complete.\nThis is often good for 3rd-party DOM manipulation libraries,\nthat should only be run after an entire tree of DOM has been updated.</li>\n<li>The <code>destroy</code> queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.</li>\n</ul>","link":"./A1/applications/run-loop.html","spaLink":"#/A1/applications/run-loop","title":"WHAT HAPPENS IN THESE QUEUES?"},{"content":"<h2 id=\"-in-what-order-are-jobs-executed-on-the-queues\">In what order are jobs executed on the queues?</h2><p>The algorithm works this way:</p>","link":"./A1/applications/run-loop.html","spaLink":"#/A1/applications/run-loop","title":"IN WHAT ORDER ARE JOBS EXECUTED ON THE QUEUES?"},{"content":"<h2 id=\"-an-example-of-the-internals\">An example of the internals</h2><p>Rather than writing the higher level app code that internally invokes the various run loop scheduling functions,\nwe have stripped away the covers, and shown the raw run-loop interactions.</p><p>Working with this API directly is not common in most Ember apps,\nbut understanding this example will help you to understand the run-loops algorithm,\nwhich will make you a better Ember developer.</p>","link":"./A1/applications/run-loop.html","spaLink":"#/A1/applications/run-loop","title":"AN EXAMPLE OF THE INTERNALS"},{"content":"<h2 id=\"-how-do-i-tell-ember-to-start-a-run-loop\">How do I tell Ember to start a run loop?</h2><p>You should begin a run loop when the callback fires.</p><p>The <code>Ember.run</code> method can be used to create a runloop.\nIn this example, jQuery and <code>Ember.run</code> are used to handle a click event and run some Ember code.</p><p>This example uses the <code>=&gt;</code> function syntax, which is a [new ES2015 syntax for callback functions]\n(<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>)\nthat provides a lexical <code>this</code>.\nIf this syntax is new,\nthink of it as a function that has the same <code>this</code> as the context it is defined in.</p>","link":"./A1/applications/run-loop.html","spaLink":"#/A1/applications/run-loop","title":"HOW DO I TELL EMBER TO START A RUN LOOP?"},{"content":"<h2 id=\"-what-happens-if-i-forget-to-start-a-run-loop-in-an-async-handler\">What happens if I forget to start a run loop in an async handler?</h2><p>As mentioned above, you should wrap any non-Ember async callbacks in <code>Ember.run</code>.\nIf you don’t, Ember will try to approximate a beginning and end for you.\nConsider the following callback:</p><p>The runloop API calls that <em>schedule</em> work i.e. <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_schedule\"><code>run.schedule</code></a>, <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce\"><code>run.scheduleOnce</code></a>,\n<a href=\"http://emberjs.com/api/classes/Ember.run.html#method_once\"><code>run.once</code></a> have the property that they will approximate a runloop for you if one does not already exist.\nThese automatically created runloops we call <em>autoruns</em>.</p><p>Here is some pseudocode to describe what happens using the example above:</p><p>Although autoruns are convenient, they are suboptimal.\nThe current JS frame is allowed to end before the run loop is flushed,\nwhich sometimes means the browser will take the opportunity to do other things, like garbage collection.\nGC running in between data changing and DOM rerendering can cause visual lag and should be minimized.</p><p>Relying on autoruns is not a rigorous or efficient way to use the runloop.\nWrapping event handlers manually is preferred.</p>","link":"./A1/applications/run-loop.html","spaLink":"#/A1/applications/run-loop","title":"WHAT HAPPENS IF I FORGET TO START A RUN LOOP IN AN ASYNC HANDLER?"},{"content":"<h2 id=\"-how-is-runloop-behaviour-different-when-testing\">How is runloop behaviour different when testing?</h2><p>When your application is in <em>testing mode</em> then Ember will throw an error if you try to schedule work\nwithout an available runloop.</p><p>Autoruns are disabled in testing for several reasons:</p>","link":"./A1/applications/run-loop.html","spaLink":"#/A1/applications/run-loop","title":"HOW IS RUNLOOP BEHAVIOUR DIFFERENT WHEN TESTING?"},{"content":"<h2 id=\"-where-can-i-find-more-information\">Where can I find more information?</h2><p>Check out the <a href=\"http://emberjs.com/api/classes/Ember.run.html\">Ember.run</a> API documentation,\nas well as the <a href=\"https://github.com/ebryn/backburner.js/\">Backburner library</a> that powers the run loop.</p>","link":"./A1/applications/run-loop.html","spaLink":"#/A1/applications/run-loop","title":"WHERE CAN I FIND MORE INFORMATION?"},{"content":"<h3 id=\"-defining-services\">Defining Services</h3><p>Services can be generated using Ember CLI’s <code>service</code> generator.\nFor example, the following command will create the <code>ShoppingCart</code> service:</p><p>Services must extend the <a href=\"http://emberjs.com/api/classes/Ember.Service.html\"><code>Ember.Service</code></a> base class:</p><p>Like any Ember object, a service is initialized and can have properties and methods of its own.\nBelow the shopping cart service manages an items array that represents the items currently in the shopping cart.</p>","link":"./A1/applications/services.html","spaLink":"#/A1/applications/services","title":"Defining Services"},{"content":"<h3 id=\"-accessing-services\">Accessing Services</h3><p>To access a service,\nyou can inject it in any container-resolved object such as a component or another service using the <code>Ember.inject.service</code> function.\nThere are 2 ways to use this function.\nYou can either invoke it with no arguments, or you can pass it the registered name of the service.\nWhen no arguments are passed the services is loaded based in the name of the variable key.\nYou can load the shopping cart service with no arguments like below.</p><p>The other way to inject a service is to provide the name of the service as the argument.</p><p>This injects the shopping cart service into the component and makes it available as the <code>cart</code> property.</p><p>Injected properties are lazy loaded; meaning the service will not be instantiated until the property is explicitly called.\nTherefore you need to access services in your component using the <code>get</code> function otherwise you might get an undefined.</p><p>Once loaded, a service will persist until the application exits.</p><p>Below we add a remove action to the <code>cart-contents</code> component.\nNotice that below we access the <code>cart</code> service with a call to<code>this.get</code>.</p><p>Once injected into a component, a service can also be used in the template.\nNote <code>cart</code> being used below to get data from the cart.</p>","link":"./A1/applications/services.html","spaLink":"#/A1/applications/services","title":"Accessing Services"},{"content":"<h3 id=\"-customizing-the-element\">Customizing the Element</h3><p>To use a tag other than <code>div</code>, subclass <code>Ember.Component</code> and assign it\na <code>tagName</code> property. This property can be any valid HTML5 tag name as a\nstring.</p>","link":"./A1/components/customizing-a-components-element.html","spaLink":"#/A1/components/customizing-a-components-element","title":"Customizing the Element"},{"content":"<h3 id=\"-customizing-class-names\">Customizing Class Names</h3><p>You can also specify which class names are applied to the component’s\nelement by setting its <code>classNames</code> property to an array of strings:</p><p>If you want class names to be determined by properties of the component,\nyou can use class name bindings. If you bind to a Boolean property, the\nclass name will be added or removed depending on the value:</p><p>This component would render the following:</p><p>If <code>isUrgent</code> is changed to <code>false</code>, then the <code>is-urgent</code> class name will be removed.</p><p>By default, the name of the Boolean property is dasherized. You can customize the class name\napplied by delimiting it with a colon:</p><p>This would render this HTML:</p><p>Besides the custom class name for the value being <code>true</code>, you can also specify a class name which is used when the value is <code>false</code>:</p><p>This would render this HTML:</p><p>You can also specify a class which should only be added when the property is\n<code>false</code> by declaring <code>classNameBindings</code> like this:</p><p>This would render this HTML:</p><p>If the <code>isEnabled</code> property is set to <code>true</code>, no class name is added:</p><p>If the bound property’s value is a string, that value will be added as a class name without\nmodification:</p><p>This would render this HTML:</p>","link":"./A1/components/customizing-a-components-element.html","spaLink":"#/A1/components/customizing-a-components-element","title":"Customizing Class Names"},{"content":"<h3 id=\"-customizing-attributes\">Customizing Attributes</h3><p>You can bind attributes to the DOM element that represents a component\nby using <code>attributeBindings</code>:</p><p>You can also bind these attributes to differently named properties:</p><p>If the attribute is null, it won’t be rendered:</p><p>This would render this HTML when no title is passed to the component:</p><p>…and this HTML when a title of “Ember JS” is passed to the component:</p>","link":"./A1/components/customizing-a-components-element.html","spaLink":"#/A1/components/customizing-a-components-element","title":"Customizing Attributes"},{"content":"<h2 id=\"-defining-a-component-subclass\">Defining a Component Subclass</h2><p>Often times, your components will just encapsulate certain snippets of\nHandlebars templates that you find yourself using over and over. In\nthose cases, you do not need to write any JavaScript at all. Define\nthe Handlebars template as described above and use the component that is\ncreated.</p><p>If you need to customize the behavior of the component you’ll\nneed to define a subclass of <a href=\"http://emberjs.com/api/classes/Ember.Component.html\"><code>Ember.Component</code></a>. For example, you would\nneed a custom subclass if you wanted to change a component’s element,\nrespond to actions from the component’s template, or manually make\nchanges to the component’s element using JavaScript.</p><p>Ember knows which subclass powers a component based on its filename. For\nexample, if you have a component called <code>blog-post</code>, you would create a\nfile at <code>app/components/blog-post.js</code>. If your component was called\n<code>audio-player-controls</code>, the file name would be at\n<code>app/components/audio-player-controls.js</code>.</p>","link":"./A1/components/defining-a-component.html","spaLink":"#/A1/components/defining-a-component","title":"DEFINING A COMPONENT SUBCLASS"},{"content":"<h2 id=\"-dynamically-rendering-a-component\">Dynamically rendering a component</h2><p>The <a href=\"http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component\"><code>{{component}}</code></a> helper can be used to defer the selection of a component to\nrun time. The <code>{{my-component}}</code> syntax always renders the same component,\nwhile using the <code>{{component}}</code> helper allows choosing a component to render on\nthe fly. This is useful in cases where you want to interact with different\nexternal libraries depending on the data. Using the <code>{{component}}</code> helper would\nallow you to keep different logic well separated.</p><p>The first parameter of the helper is the name of a component to render, as a\nstring. So <code>{{component 'blog-post'}}</code> is the same as using <code>{{blog-post}}</code>.</p><p>The real value of <a href=\"http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component\"><code>{{component}}</code></a> comes from being able to dynamically pick\nthe component being rendered. Below is an example of using the helper as a\nmeans of choosing different components for displaying different kinds of posts:</p><p>When the parameter passed to <code>{{component}}</code> evaluates to <code>null</code> or <code>undefined</code>,\nthe helper renders nothing. When the parameter changes, the currently rendered\ncomponent is destroyed and the new component is created and brought in.</p><p>Picking different components to render in response to the data allows you to\nhave different template and behavior for each case. The <code>{{component}}</code> helper\nis a powerful tool for improving code modularity.</p>","link":"./A1/components/defining-a-component.html","spaLink":"#/A1/components/defining-a-component","title":"DYNAMICALLY RENDERING A COMPONENT"},{"content":"<h2 id=\"-sending-actions\">Sending Actions</h2><p>In some cases your component needs to define event handlers, perhaps to support\nvarious draggable behaviors. For example, a component may need to send an <code>id</code>\nwhen it receives a drop event:</p><p>You can define the component’s event handlers to manage the drop event.\nAnd if you need to, you may also stop events from bubbling, by using\n<code>return false;</code>.</p>","link":"./A1/components/handling-events.html","spaLink":"#/A1/components/handling-events","title":"SENDING ACTIONS"},{"content":"<h2 id=\"-event-names\">Event Names</h2><p>The event handling examples described above respond to one set of events.\nThe names of the built-in events are listed below. Custom events can be\nregistered by using <a href=\"http://emberjs.com/api/classes/Ember.Application.html#property_customEvents\">Ember.Application.customEvents</a>.</p><p>Touch events:</p><ul>\n<li><code>touchStart</code></li>\n<li><code>touchMove</code></li>\n<li><code>touchEnd</code></li>\n<li><code>touchCancel</code></li>\n</ul><p>Keyboard events</p><ul>\n<li><code>keyDown</code></li>\n<li><code>keyUp</code></li>\n<li><code>keyPress</code></li>\n</ul><p>Mouse events</p><ul>\n<li><code>mouseDown</code></li>\n<li><code>mouseUp</code></li>\n<li><code>contextMenu</code></li>\n<li><code>click</code></li>\n<li><code>doubleClick</code></li>\n<li><code>mouseMove</code></li>\n<li><code>focusIn</code></li>\n<li><code>focusOut</code></li>\n<li><code>mouseEnter</code></li>\n<li><code>mouseLeave</code></li>\n</ul><p>Form events:</p><ul>\n<li><code>submit</code></li>\n<li><code>change</code></li>\n<li><code>focusIn</code></li>\n<li><code>focusOut</code></li>\n<li><code>input</code></li>\n</ul><p>HTML5 drag and drop events:</p><ul>\n<li><code>dragStart</code></li>\n<li><code>drag</code></li>\n<li><code>dragEnter</code></li>\n<li><code>dragLeave</code></li>\n<li><code>dragOver</code></li>\n<li><code>dragEnd</code></li>\n<li><code>drop</code></li>\n</ul>","link":"./A1/components/handling-events.html","spaLink":"#/A1/components/handling-events","title":"EVENT NAMES"},{"content":"<h2 id=\"-positional-params\">Positional Params</h2><p>In addition to passing parameters in by name, you can pass them in by position.\nIn other words, you can invoke the above component example like this:</p><p>To set the component up to receive parameters this way, you need\nset the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams\"><code>positionalParams</code></a> attribute in your component class.</p><p>Then you can use the attributes in the component exactly as if they had been\npassed in like <code>{{blog-post title=post.title body=post.body}}</code>.</p><p>Notice that the <code>positionalParams</code> property is added to the class as a\nstatic variable via <code>reopenClass</code>. Positional params are always declared on\nthe component class and cannot be changed while an application runs.</p><p>Alternatively, you can accept an arbitrary number of parameters by\nsetting <code>positionalParams</code> to a string, e.g. <code>positionalParams: 'params'</code>. This\nwill allow you to access those params as an array like so:</p>","link":"./A1/components/passing-properties-to-a-component.html","spaLink":"#/A1/components/passing-properties-to-a-component","title":"POSITIONAL PARAMS"},{"content":"<h2 id=\"-order-of-lifecycle-hooks-called\">Order of Lifecycle Hooks Called</h2><p>Listed below are the component lifecycle hooks in order of execution according to render scenario.</p>","link":"./A1/components/the-component-lifecycle.html","spaLink":"#/A1/components/the-component-lifecycle","title":"ORDER OF LIFECYCLE HOOKS CALLED"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-initial-render\">On Initial Render</h3>","link":"./A1/components/the-component-lifecycle.html","spaLink":"#/A1/components/the-component-lifecycle","title":"On Initial Render"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-re-render\">On Re-Render</h3>","link":"./A1/components/the-component-lifecycle.html","spaLink":"#/A1/components/the-component-lifecycle","title":"On Re-Render"},{"content":"<h3 id=\"-order-of-lifecycle-hooks-called-on-component-destroy\">On Component Destroy</h3>","link":"./A1/components/the-component-lifecycle.html","spaLink":"#/A1/components/the-component-lifecycle","title":"On Component Destroy"},{"content":"<h2 id=\"-lifecycle-hook-examples\">Lifecycle Hook Examples</h2><p>Below are some samples of ways to use lifecycle hooks within your components.</p>","link":"./A1/components/the-component-lifecycle.html","spaLink":"#/A1/components/the-component-lifecycle","title":"LIFECYCLE HOOK EXAMPLES"},{"content":"<h3 id=\"-lifecycle-hook-examples-resetting-presentation-state-on-attribute-change-with-didupdateattrs\">Resetting Presentation State on Attribute Change with <code>didUpdateAttrs</code></h3><p><code>didUpdateAttrs</code> runs when the attributes of a component have changed, but not when the component is re-rendered, via <code>component.rerender</code>,\n<code>component.set</code>, or changes in models or services used by the template.</p><p>A <code>didUpdateAttrs</code> is called prior to rerender, you can use this hook to execute code when specific attributes are changed.\nThis hook can be an effective alternative to an observer, as it will run prior to a re-render, but after an attribute has changed.</p><p>An example of this scenario in action is a profile editor component.  As you are editing one user, and the user attribute is changed,\nyou can use <code>didUpdateAttrs</code> to clear any error state that was built up from editing the previous user.</p><p><code>/app/templates/components/profile-editor.hbs</code></p><p><code>/app/components/profile-editor.js</code></p>","link":"./A1/components/the-component-lifecycle.html","spaLink":"#/A1/components/the-component-lifecycle","title":"Resetting Presentation State on Attribute Change with didUpdateAttrs"},{"content":"<h3 id=\"-lifecycle-hook-examples-formatting-component-attributes-with-didreceiveattrs\">Formatting Component Attributes with <code>didReceiveAttrs</code></h3><p><code>didReceiveAttrs</code> runs after <code>init</code>, and it also runs on subsequent re-renders, which is useful for logic that is the same on all renders.\nIt does not run when the re-rendered has been initiated internally.</p><p>Since the <code>didReceiveAttrs</code> hook is called every time a component’s attributes are updated whether on render or re-render,\nyou can use the hook to effectively act as an observer, ensuring code is executed every time an attribute changes.</p><p>For example, if you have a component that renders based on a json configuration, but you want to provide your component with the option of taking the config as a string,\nyou can leverage <code>didReceiveAttrs</code> to ensure the incoming config is always parsed.</p>","link":"./A1/components/the-component-lifecycle.html","spaLink":"#/A1/components/the-component-lifecycle","title":"Formatting Component Attributes with didReceiveAttrs"},{"content":"<h3 id=\"-lifecycle-hook-examples-integrating-with-third-party-libraries-with-didinsertelement\">Integrating with Third-Party Libraries with <code>didInsertElement</code></h3><p>Suppose you want to integrate your favorite date picker library into an Ember project.\nTypically, 3rd party JS/jQuery libraries require a DOM element to bind to.\nSo, where is the best place to initialize and attach the library?</p><p>After a component successfully renders its backing HTML element into the DOM, it will trigger its <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> hook.</p><p>Ember guarantees that, by the time <code>didInsertElement()</code> is called:</p><p>A component’s <a href=\"http://emberjs.com/api/classes/Ember.Component.html#method__\"><code>$()</code></a> method allows you to access the component’s DOM element by returning a JQuery element.\nFor example, you can set an attribute using jQuery’s <code>attr()</code> method:</p><p><a href=\"http://emberjs.com/api/classes/Ember.Component.html#method__\"><code>$()</code></a> will, by default, return a jQuery object for the component’s root element, but you can also target child elements within the component’s template by passing a selector:</p><p>Let’s initialize our date picker by overriding the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> method.</p><p>Date picker libraries usually attach to an <code>&lt;input&gt;</code> element, so we will use jQuery to find an appropriate input within our component’s template.</p><p><a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> is also a good place to\nattach event listeners. This is particularly useful for custom events or\nother browser events which do not have a <a href=\"http://guides.emberjs.com/v2.1.0/components/handling-events/#toc_event-names\">built-in event\nhandler</a>.</p><p>For example, perhaps you have some custom CSS animations trigger when the component\nis rendered and you want to handle some cleanup when it ends:</p><p>There are a few things to note about the <code>didInsertElement()</code> hook:</p><ul>\n<li>It is only triggered once when the component element is first rendered.</li>\n<li>In cases where you have components nested inside other components, the child component will always receive the <code>didInsertElement()</code> call before its parent does.</li>\n<li>Setting properties on the component in <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> triggers a re-render, and  for performance reasons,\nis not allowed.</li>\n<li>While <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement\"><code>didInsertElement()</code></a> is technically an event that can be listened for using <a href=\"http://emberjs.com/api/classes/Ember.Component.html#method_on\"><code>on()</code></a>, it is encouraged to override the default method itself,\nparticularly when order of execution is important.</li>\n</ul>","link":"./A1/components/the-component-lifecycle.html","spaLink":"#/A1/components/the-component-lifecycle","title":"Integrating with Third-Party Libraries with didInsertElement"},{"content":"<h3 id=\"-lifecycle-hook-examples-making-updates-to-the-rendered-dom-with-didrender\">Making Updates to the Rendered DOM with <code>didRender</code></h3><p>The <code>didRender</code> hook is called during both render and re-render after the template has rendered and the DOM updated.\nYou can leverage this hook to perform post-processing on the DOM of a component after its been updated.</p><p>In this example, there is a list component that needs to scroll to a selected item when rendered.\nSince scrolling to a specific spot is based on positions within the DOM, we need to ensure that the list has been rendered before scrolling.\nWe can first render this list, and then set the scroll.</p><p>The component below takes a list of items and displays them on the screen.\nAdditionally, it takes an object representing which item is selected and will select and set the scroll top to that item.</p><p>When rendered the component will iterate through the given list and apply a class to the one that is selected.</p><p><code>/app/templates/components/selected-item-list.hbs</code></p><p>The scroll happens on <code>didRender</code>, where it will scroll the component’s container to the element with the selected class name.</p><p><code>/app/components/selected-item-list.js</code></p>","link":"./A1/components/the-component-lifecycle.html","spaLink":"#/A1/components/the-component-lifecycle","title":"Making Updates to the Rendered DOM with didRender"},{"content":"<h3 id=\"-lifecycle-hook-examples-detaching-and-tearing-down-component-elements-with-willdestroyelement\">Detaching and Tearing Down Component Elements with <code>willDestroyElement</code></h3><p>When a component detects that it is time to remove itself from the DOM, Ember will trigger the <a href=\"http://emberjs.com/api/classes/Ember.Component.html#event_willDestroyElement\"><code>willDestroyElement()</code></a> method,\nallowing for any teardown logic to be performed.</p><p>Component teardown can be triggered by a number of different conditions.\nFor instance, the user may navigate to a different route, or a conditional Handlebars block surrounding your component may change:</p><p>Let’s use this hook to cleanup our date picker and event listener from above:</p>","link":"./A1/components/the-component-lifecycle.html","spaLink":"#/A1/components/the-component-lifecycle","title":"Detaching and Tearing Down Component Elements with willDestroyElement"},{"content":"<h2 id=\"-creating-the-component\">Creating the Component</h2><p>Let’s call our component <code>button-with-confirmation</code>. We can create it by\ntyping:</p><p>We’ll plan to use the component in a template something like this:</p><p>We’ll also want to use the component elsewhere, perhaps like this:</p>","link":"./A1/components/triggering-changes-with-actions.html","spaLink":"#/A1/components/triggering-changes-with-actions","title":"CREATING THE COMPONENT"},{"content":"<h2 id=\"-designing-the-action\">Designing the Action</h2><p>When implementing an action on a component, you need to break it down into two steps:</p><p>Let’s take it step by step.</p>","link":"./A1/components/triggering-changes-with-actions.html","spaLink":"#/A1/components/triggering-changes-with-actions","title":"DESIGNING THE ACTION"},{"content":"<h2 id=\"-implementing-the-action\">Implementing the Action</h2><p>In the parent component, let’s first define what we want to happen when the\nuser clicks the button and then confirms. In this case, we’ll find the user’s\naccount and delete it.</p><p>In Ember, each component can\nhave a property called <code>actions</code>, where you put functions that can be\n<a href=\"../../templates/actions/\">invoked by the user interacting with the component\nitself</a>, or by child components.</p><p>Let’s look at the parent component’s JavaScript file. In this example,\nimagine we have a parent component called <code>user-profile</code> that shows the\nuser’s profile to them.</p><p>We’ll implement an action on the parent component called\n<code>userDidDeleteAccount()</code> that, when called, gets a hypothetical <code>login</code>\n<a href=\"../../applications/services/\">service</a> and calls the service’s\n<code>deleteUser()</code> method.</p><p>Now we’ve implemented our action, but we have not told Ember when we\nwant this action to be triggered, which is the next step.</p>","link":"./A1/components/triggering-changes-with-actions.html","spaLink":"#/A1/components/triggering-changes-with-actions","title":"IMPLEMENTING THE ACTION"},{"content":"<h2 id=\"-designing-the-child-component\">Designing the Child Component</h2><p>Next, let’s implement the logic to confirm that the user wants to take\nthe action from the component:</p><p>The component template will have a button and a div that shows the confirmation dialog\nbased on the value of <code>confirmShown</code>.</p>","link":"./A1/components/triggering-changes-with-actions.html","spaLink":"#/A1/components/triggering-changes-with-actions","title":"DESIGNING THE CHILD COMPONENT"},{"content":"<h2 id=\"-passing-the-action-to-the-component\">Passing the Action to the Component</h2><p>Now we need to make it so that the <code>onConfirm()</code> event in the\n<code>button-with-confirmation()</code> component triggers the\n<code>userDidDeleteAccount()</code> action in the <code>user-profile</code> component.\nOne important thing to know about actions is that they’re functions\nyou can call, like any other method on your component.\nSo they can be passed from one component to another like this:</p><p>This snippet says “take the <code>userDidDeleteAccount</code> action from the\nparent and make it available on the child component as\n<code>onConfirm</code>.”</p><p>We can do a similar thing for our <code>send-message</code> component:</p><p>Now, we can use <code>onConfirm</code> in the child component to invoke the action on the\nparent:</p><p><code>this.get('onConfirm')</code> will return the function passed from the parent as the\nvalue of <code>onConfirm</code>, and the following <code>()</code> will invoke the function.</p><p>Like normal attributes, actions can be a property on the component; the\nonly difference is that the property is set to a function that knows how\nto trigger behavior.</p><p>That makes it easy to remember how to add an action to a component. It’s\nlike passing an attribute, but you use the <code>action</code> helper to pass\na function instead.</p><p>Actions in components allow you to\ndecouple an event happening from how it’s handled, leading to modular,\nmore reusable components.</p>","link":"./A1/components/triggering-changes-with-actions.html","spaLink":"#/A1/components/triggering-changes-with-actions","title":"PASSING THE ACTION TO THE COMPONENT"},{"content":"<h2 id=\"-handling-action-completion\">Handling Action Completion</h2><p>Often actions perform asynchronous tasks, such as making an ajax request to a server.\nSince actions are functions that can be passed in by a parent component, they are able to return values when called.\nThe most common scenario is for an action to return a promise so that the component can handle the action’s completion.</p><p>In our user <code>button-with-confirmation</code> component we want to leave the confirmation modal open until we know that the\noperation has completed successfully.\nThis is accomplished by expecting a promise to be returned from <code>onConfirm</code>.\nUpon resolution of the promise, we set a property used to indicate the visibility of the confirmation modal.</p>","link":"./A1/components/triggering-changes-with-actions.html","spaLink":"#/A1/components/triggering-changes-with-actions","title":"HANDLING ACTION COMPLETION"},{"content":"<h2 id=\"-passing-arguments\">Passing Arguments</h2><p>Sometimes the parent component invoking an action has some context needed for the action that the child component\ndoesn’t.\nFor these cases, actions passed to a component via the action helper may be invoked with arguments.\nFor example, we’ll update the <code>send-message</code> action to take a message type in addition to the message itself.\nSince the <code>button-with-confirmation</code> component doesn’t know or care about what type of message its collecting, we want\nto provide a message type from <code>send-message</code> when we define the action.</p><p>In this case, the code in <code>button-with-confirmation</code> does not change.\nIt will still invoke <code>onConfirm</code> with no arguments.\nThe action helper will add the arguments provided in the template to the call.</p><p>Action arguments curry, meaning that you can provide partial arguments to the action helper and provide the rest of the\narguments when you call the function within the component javascript file.\nFor example, our <code>button-with-confirmation</code> component will now <a href=\"../wrapping-content-in-a-component/\">yield</a> the content\nof the confirmation dialog to collect extra information to be sent along with the <code>onConfirm</code> action:</p><p>The <code>send-message</code> component provides an input as block content to the <code>button-with-confirmation</code> component, setting\n<code>confirmValue</code>.</p><p>Now when the <code>submitConfirm</code> action is invoked, we call it with the value provided by our yielded input.</p><p>This action will call our bound <code>sendMessage</code> function with both the message type we provided earlier, and the template\nand the message value provided in the component JavaScript.</p>","link":"./A1/components/triggering-changes-with-actions.html","spaLink":"#/A1/components/triggering-changes-with-actions","title":"PASSING ARGUMENTS"},{"content":"<h2 id=\"-invoking-actions-directly-on-component-collaborators\">Invoking Actions Directly on Component Collaborators</h2><p>Actions can be invoked on objects other than the component directly from the template.  For example, in our\n<code>send-message</code> component we might include a service that processes the <code>sendMessage</code> logic.</p><p>We can tell the action to invoke the <code>sendMessage</code> action directly on the messaging service with the <code>target</code> attribute.</p><p>By supplying the <code>target</code> attribute, the action helper will look to invoke the <code>sendMessage</code> action directly on the messaging\nservice, saving us from writing code on the component that just passes the action along to the service.</p>","link":"./A1/components/triggering-changes-with-actions.html","spaLink":"#/A1/components/triggering-changes-with-actions","title":"INVOKING ACTIONS DIRECTLY ON COMPONENT COLLABORATORS"},{"content":"<h2 id=\"-destructuring-objects-passed-as-action-arguments\">Destructuring Objects Passed as Action Arguments</h2><p>A component will often not know what information a parent needs to process an action, and will just pass all the\ninformation it has.\nFor example, our <code>user-profile</code> component is going to notify its parent, <code>system-preferences-editor</code>, that a\nuser’s account was deleted, and passes along with it the full user profile object.</p><p>All our <code>system-preferences-editor</code> component really needs to process a user deletion is an account ID.\nFor this case, the action helper provides the <code>value</code> attribute to allow a parent component to dig into the passed\nobject to pull out only what it needs.</p><p>Now when the <code>system-preferences-editor</code> handles the delete action, it receives only the user’s account <code>id</code> string.</p>","link":"./A1/components/triggering-changes-with-actions.html","spaLink":"#/A1/components/triggering-changes-with-actions","title":"DESTRUCTURING OBJECTS PASSED AS ACTION ARGUMENTS"},{"content":"<h2 id=\"-calling-actions-up-multiple-component-layers\">Calling Actions Up Multiple Component Layers</h2><p>When your components go multiple template layers deep, its common to need to handle an action several layers up the tree.\nUsing the action helper, it is possible to make actions defined in parent components available at the bottom layers of\nyour component tree without adding JavaScript code to the components in between.</p><p>For example, we want to take account deletion out of the <code>user-profile</code> component and handle deletion in its parent.\nIn our template in <code>user-profile.hbs</code>, we can change our action to call <code>deleteCurrentUser</code>,\nwhich will be defined on <code>system-preferences-editor</code>.</p><p>Note that <code>deleteCurrentUser</code> is not in quotes as was the case <a href=\"#toc_passing-the-action-to-the-component\">previously</a>\nwhen the action was local to <code>user-profile</code>.  When you pass an actual function reference (without quotes) to the action\nhelper, it will call the function from the component’s local context.</p><p>Alternately, when you pass a string to the action helper, Ember will attempt to call that function from the\ncomponent’s local <code>actions</code> object.</p><p>Here our <code>system-preferences-editor</code> template passes its <code>deleteUser</code> action into the <code>user-profile</code>\ncomponent’s local <code>deleteCurrentUser</code> property.</p><p>Now when you confirm deletion, the action goes straight to the <code>system-preferences-editor</code> to handle.</p>","link":"./A1/components/triggering-changes-with-actions.html","spaLink":"#/A1/components/triggering-changes-with-actions","title":"CALLING ACTIONS UP MULTIPLE COMPONENT LAYERS"},{"content":"<h2 id=\"-routing\">Routing</h2>","link":"./A1/configuring-ember/debugging.html","spaLink":"#/A1/configuring-ember/debugging","title":"ROUTING"},{"content":"<h2 id=\"-views-templates\">Views / Templates</h2>","link":"./A1/configuring-ember/debugging.html","spaLink":"#/A1/configuring-ember/debugging","title":"VIEWS / TEMPLATES"},{"content":"<h2 id=\"-controllers\">Controllers</h2>","link":"./A1/configuring-ember/debugging.html","spaLink":"#/A1/configuring-ember/debugging","title":"CONTROLLERS"},{"content":"<h2 id=\"-observers-binding\">Observers / Binding</h2>","link":"./A1/configuring-ember/debugging.html","spaLink":"#/A1/configuring-ember/debugging","title":"OBSERVERS / BINDING"},{"content":"<h2 id=\"-miscellaneous\">Miscellaneous</h2><p>This option logs all the lookups that are done to the console. Custom objects\nyou’ve created yourself have a tick, and Ember generated ones don’t.</p><p>It’s useful for understanding which objects Ember is finding when it does a lookup\nand which it is generating automatically for you.</p><p>If you are using imports with Ember, be sure to import the console:</p><p>There are times when dealing with promises that it seems like any errors\nare being ‘swallowed’, and not properly raised. This makes it extremely\ndifficult to track down where a given issue is coming from. Thankfully,\n<code>RSVP</code> has a solution for this problem built in.</p><p>You can provide an <code>onerror</code> function that will be called with the error\ndetails if any errors occur within your promise. This function can be anything,\nbut a common practice is to call <code>console.assert</code> to dump the error to the\nconsole.</p><p>Backburner has support for stitching the stacktraces together so that you can\ntrack down where an erroring <code>Ember.run.later</code> is being initiated from. Unfortunately,\nthis is quite slow and is not appropriate for production or even normal development.</p><p>To enable this mode you can set:</p>","link":"./A1/configuring-ember/debugging.html","spaLink":"#/A1/configuring-ember/debugging","title":"MISCELLANEOUS"},{"content":"<h2 id=\"-life-without-prototype-extension\">Life Without Prototype Extension</h2><p>In order for your application to behave correctly, you will need to\nmanually extend or create the objects that the native objects were\ncreating before.</p>","link":"./A1/configuring-ember/disabling-prototype-extensions.html","spaLink":"#/A1/configuring-ember/disabling-prototype-extensions","title":"LIFE WITHOUT PROTOTYPE EXTENSION"},{"content":"<h3 id=\"-life-without-prototype-extension-arrays\">Arrays</h3><p>Native arrays will no longer implement the functionality needed to\nobserve them. If you disable prototype extension and attempt to use\nnative arrays with things like a template’s <code>{{#each}}</code> helper, Ember.js\nwill have no way to detect changes to the array and the template will\nnot update as the underlying array changes.</p><p>Additionally, if you try to set the model of an\n<code>Ember.ArrayController</code> to a plain native array, it will raise an\nexception since it no longer implements the <code>Ember.Array</code> interface.</p><p>You can manually coerce a native array into an array that implements the\nrequired interfaces using the convenience method <code>Ember.A</code>:</p>","link":"./A1/configuring-ember/disabling-prototype-extensions.html","spaLink":"#/A1/configuring-ember/disabling-prototype-extensions","title":"Arrays"},{"content":"<h3 id=\"-life-without-prototype-extension-strings\">Strings</h3><p>Strings will no longer have the convenience methods described in the\n<a href=\"http://emberjs.com/api/classes/Ember.String.html\">Ember.String API reference.</a>. Instead,\nyou can use the similarly-named methods of the <code>Ember.String</code> object and\npass the string to use as the first parameter:</p>","link":"./A1/configuring-ember/disabling-prototype-extensions.html","spaLink":"#/A1/configuring-ember/disabling-prototype-extensions","title":"Strings"},{"content":"<h3 id=\"-life-without-prototype-extension-functions\">Functions</h3><p>The <a href=\"../../object-model/\">Object Model</a> section of the Guides describes\nhow to write computed properties, observers, and bindings without\nprototype extensions. Below you can learn about how to convert existing\ncode to the format now encouraged.</p><p>To annotate computed properties, use the <code>Ember.computed()</code> method to\nwrap the function:</p><p>Observers are annotated using <code>Ember.observer()</code>:</p><p>Evented functions are annotated using <code>Ember.on()</code>:</p>","link":"./A1/configuring-ember/disabling-prototype-extensions.html","spaLink":"#/A1/configuring-ember/disabling-prototype-extensions","title":"Functions"},{"content":"<h3 id=\"-changing-the-root-element\">Changing the Root Element</h3><p>By default, your application will render the <a href=\"../../routing/defining-your-routes/#toc_the-application-route\">application template</a>\nand attach it to the document’s <code>body</code> element.</p><p>You can tell the application to append the application template to a\ndifferent element by specifying its <code>rootElement</code> property:</p><p>This property can be specified as either an element or a\n<a href=\"http://api.jquery.com/category/selectors/\">jQuery-compatible selector\nstring</a>.</p>","link":"./A1/configuring-ember/embedding-applications.html","spaLink":"#/A1/configuring-ember/embedding-applications","title":"Changing the Root Element"},{"content":"<h3 id=\"-disabling-url-management\">Disabling URL Management</h3><p>You can prevent Ember from making changes to the URL by <a href=\"../specifying-url-type\">changing the\nrouter’s <code>location</code></a> to\n<code>none</code>:</p>","link":"./A1/configuring-ember/embedding-applications.html","spaLink":"#/A1/configuring-ember/embedding-applications","title":"Disabling URL Management"},{"content":"<h3 id=\"-specifying-a-root-url\">Specifying a Root URL</h3><p>If your Ember application is one of multiple web applications served from the same domain, it may be necessary to indicate to the router what the root URL for your Ember application is. By default, Ember will assume it is served from the root of your domain.</p><p>For example, if you wanted to serve your blogging application from <code>http://emberjs.com/blog/</code>, it would be necessary to specify a root URL of <code>/blog/</code>.</p><p>This can be achieved by setting the <code>rootURL</code> on the router:</p>","link":"./A1/configuring-ember/embedding-applications.html","spaLink":"#/A1/configuring-ember/embedding-applications","title":"Specifying a Root URL"},{"content":"<h2 id=\"-feature-life-cycle\">Feature Life-Cycle</h2><p>A newly-flagged feature is only available in canary builds and can be enabled\nat runtime through your project’s configuration file.</p><p>At the start of a beta cycle the Ember core team evaluates each new feature.\nFeatures deemed stable are made available in the next beta and enabled by default.</p><p>Beta features that receive negative feedback from the community are disabled in the next beta point\nrelease, and are not included in the next stable release. They may still be included\nin the next beta cycle if the issues/concerns are resolved.</p><p>Once the beta cycle has completed, the next stable release will include any features that\nwere enabled during the beta cycle. At this point the feature flags will be removed from\nthe canary and future beta branches, and the feature becomes part of the framework.</p>","link":"./A1/configuring-ember/feature-flags.html","spaLink":"#/A1/configuring-ember/feature-flags","title":"FEATURE LIFE-CYCLE"},{"content":"<h2 id=\"-flagging-details\">Flagging Details</h2><p>The flag status in the generated build is controlled by the <a href=\"https://github.com/emberjs/ember.js/blob/master/features.json\"><code>features.json</code></a>\nfile in the root of the Ember.js project. This file lists all new features and their current status.</p><p>A feature can have one of a three flags:</p><ul>\n<li><code>true</code> - The feature is <strong>present</strong> and <strong>enabled</strong>: the code behind the flag is always enabled in\nthe generated build.</li>\n<li><code>null</code> - The feature is <strong>present</strong> but <strong>disabled</strong> in the build output. It must be enabled at\nruntime.</li>\n<li><code>false</code> - The feature is entirely <strong>disabled</strong>: the code behind the flag is not present in\nthe generated build.</li>\n</ul><p>The process of removing the feature flags from the resulting build output is\nhandled by <a href=\"https://github.com/thomasboyt/defeatureify\"><code>defeatureify</code></a>.</p>","link":"./A1/configuring-ember/feature-flags.html","spaLink":"#/A1/configuring-ember/feature-flags","title":"FLAGGING DETAILS"},{"content":"<h2 id=\"-feature-listing-featuresmd\">Feature Listing (<a href=\"https://github.com/emberjs/ember.js/blob/master/FEATURES.md\"><code>FEATURES.md</code></a>)</h2><p>When a developer adds a new feature to the <code>canary</code> channel (i.e. the <code>master</code> branch on github), they\nalso add an entry to <a href=\"https://github.com/emberjs/ember.js/blob/master/FEATURES.md\"><code>FEATURES.md</code></a>\nexplaining what the feature does, and linking to their originating pull request.\nThis list is kept current, and reflects what is available in each channel\n(<code>release</code>, <code>beta</code>, and <code>canary</code>).</p>","link":"./A1/configuring-ember/feature-flags.html","spaLink":"#/A1/configuring-ember/feature-flags","title":"FEATURE LISTING (FEATURES.MD)"},{"content":"<h2 id=\"-enabling-at-runtime\">Enabling At Runtime</h2><p>When using the Ember.js canary or beta builds you can enable a “<strong>present</strong> but <strong>disabled</strong>“\nfeature by setting its flag value to <code>true</code> before your application boots:</p><p>For the truly ambitious developer, setting <code>ENV.EmberENV.ENABLE_ALL_FEATURES</code> to <code>true</code> will enable all\nexperimental features.</p>","link":"./A1/configuring-ember/feature-flags.html","spaLink":"#/A1/configuring-ember/feature-flags","title":"ENABLING AT RUNTIME"},{"content":"<h2 id=\"-filtering-deprecations\">Filtering Deprecations</h2><p>When your project has a lot of deprecations, you can start by filtering out deprecations that do not have to be addressed right away.  You\ncan use the <a href=\"http://emberjs.com/api/classes/Ember.Debug.html#method_registerDeprecationHandler\">deprecation handlers</a> API to check for what\nrelease a deprecated feature will be removed.  An example handler is shown below that filters out all deprecations that are not going away\nin release 2.0.0.</p><p>The deprecation handler API was released in Ember 2.1.  If you would like to leverage this API in a prior release of Ember you can install\nthe <a href=\"http://emberobserver.com/addons/ember-debug-handlers-polyfill\">ember-debug-handlers-polyfill</a> addon into your project.</p>","link":"./A1/configuring-ember/handling-deprecations.html","spaLink":"#/A1/configuring-ember/handling-deprecations","title":"FILTERING DEPRECATIONS"},{"content":"<h2 id=\"-deprecation-workflow\">Deprecation Workflow</h2><p>Once you’ve removed deprecations that you may not need to immediately address, you may still be left with many deprecations.  Also, your remaining\ndeprecations may only occur in very specific scenarios that are not obvious.  How then should you go about finding and fixing these?  This\nis where the <a href=\"http://emberobserver.com/addons/ember-cli-deprecation-workflow\">ember-cli-deprecation-workflow</a> addon can be extremely helpful.</p><p>Once installed, the addon works in 3 steps:</p>","link":"./A1/configuring-ember/handling-deprecations.html","spaLink":"#/A1/configuring-ember/handling-deprecations","title":"DEPRECATION WORKFLOW"},{"content":"<h3 id=\"-deprecation-workflow-1-gather-deprecations-into-one-source\">1. Gather deprecations into one source</h3><p>The ember-cli-deprecation-workflow addon provides a command that will collect deprecations from your console and generate JavaScript code listing\nits findings.</p><p>To collect deprecations, first run your in-browser test suite by starting your development server and navigating to <code>http://localhost:4200/tests</code>.  If your test suite isn’t fully covering your app’s functionality, you may also\nmanually exercise functionality within your app where needed.  Once you’ve exercised the app to your satisfaction, run the following command within\nyour browser console: <code>deprecationWorkflow.flushDeprecations()</code>.  This will print to the console JavaScript code, which you should then copy to a\nnew file in your project called <code>/config/deprecation-workflow.js</code></p><p><img width=\"675px\" title=\"Generated Deprecation Code from Browser Console\" src=\"../../images/guides/configuring-ember/handling-deprecations/generate-deprecation-code.png\"></p><p>Here’s an example of a deprecation-workflow file after generated from the console:</p><p>You might notice that you have a lot of duplicated messages in your workflow file, like the 3 messages in the above example that start with\n<code>Accessing 'template' in...</code>.  This is because some of the deprecation messages provide context to the specific deprecation, making them\ndifferent than the same deprecation in other parts of the app.  If you want to consolidate the\nduplication, you can use a simple regular expression with a wildcard (<code>.*</code>) for the part of the message that varies per instance.</p><p>Below is the same deprecation-workflow file as above, now with a regular expression on line 7 to remove some redundant messages. Note that the double quotes around <code>matchMessage</code> have also been replaced with forward slashes.</p><p>Rerun your test suite as you make updates to your workflow file and you should validate that your deprecations are gone. Once that is completed,\nyou can proceed with enhancing your application without the sea of deprecation warnings clouding your log.</p>","link":"./A1/configuring-ember/handling-deprecations.html","spaLink":"#/A1/configuring-ember/handling-deprecations","title":"1. Gather deprecations into one source"},{"content":"<h3 id=\"-deprecation-workflow-2-turn-on-a-deprecation\">2. “Turn on” a deprecation</h3><p>Once you have built your <code>deprecation-workflow.js</code> file and your deprecations are silenced, you can begin to work on deprecations one by one\nat your own leisure.  To find deprecations, you can change the handler value of that message to either <code>throw</code> or <code>log</code>.  Throw will\nthrow an actual exception when the deprecation is encountered, so that tests that use the deprecated feature will fail.  Choosing to log will\nsimply log a warning to the console as before.  These settings give you some flexibility on how you want to go about fixing the\ndeprecations.</p><p>The code below is the deprecation-workflow file with the first deprecation set to throw an exception on occurrence.  The image demonstrates what\nthat deprecation looks like when you run your tests.</p><p><img width=\"675px\" src=\"../../images/guides/configuring-ember/handling-deprecations/failed-test-from-deprecation.png\"></p>","link":"./A1/configuring-ember/handling-deprecations.html","spaLink":"#/A1/configuring-ember/handling-deprecations","title":"2. “Turn on” a deprecation"},{"content":"<h3 id=\"-deprecation-workflow-3-fix-and-repeat\">3. Fix and Repeat</h3><p>After fixing a deprecation and getting your scenarios working again, you might want to leave the deprecation message in the workflow file with the\nthrow handler enabled.  This will ensure you haven’t missed anything, and ensure no new deprecated calls of that type are introduced to your project.\nNext, it’s just a matter of going down the list, updating the handler, and fixing each remaining deprecation.</p><p>In the end, your deprecations can be fully turned on as “throw” and you should be able to use your application without error.  At this point, you can\ngo ahead and update your Ember version!  When you upgrade, be sure you remove the deprecations you’ve fixed from the deprecation workflow file,\nso that you can start the process over for the next release.</p>","link":"./A1/configuring-ember/handling-deprecations.html","spaLink":"#/A1/configuring-ember/handling-deprecations","title":"3. Fix and Repeat"},{"content":"<h2 id=\"-silencing-deprecation-warnings-during-compile\">Silencing Deprecation Warnings During Compile</h2><p>As you upgrade between releases, you might also notice that your terminal log begins to stream template-related deprecation warnings during the compile process, making\nit difficult to review your compilation logs.</p><p><img width=\"675px\" src=\"../../images/guides/configuring-ember/handling-deprecations/compile-deprecations.png\" title=\"Compile Deprecations Clouding Log\"></p><p>If you are using the deprecation workflow process above, you will likely prefer to gather these warnings during runtime execution instead.  The way to hide these\nwarnings during compile is to install the <a href=\"http://emberobserver.com/addons/ember-cli-template-lint\">ember-cli-template-lint</a> addon.  It suppresses\ntemplate deprecation warnings during compile in favor of showing them in the browser console during test suite execution or application usage.</p>","link":"./A1/configuring-ember/handling-deprecations.html","spaLink":"#/A1/configuring-ember/handling-deprecations","title":"SILENCING DEPRECATION WARNINGS DURING COMPILE"},{"content":"<h2 id=\"-deprecation-handling-in-ember-inspector\">Deprecation Handling in Ember Inspector</h2><p>Ember Inspector also provides deprecation handling capability.  It can work complimentary to ember-cli-deprecation-workflow.  As you unsilence deprecations to\nfix them, the inspector can allow you to more quickly find where in your code a deprecation occurs when you run into it at runtime, reducing the amount of\nstack trace browsing you have to do.  For more information on using deprecation handling in Ember Inspector, see its <a href=\"../../ember-inspector/deprecations/\">guides section</a>.</p>","link":"./A1/configuring-ember/handling-deprecations.html","spaLink":"#/A1/configuring-ember/handling-deprecations","title":"DEPRECATION HANDLING IN EMBER INSPECTOR"},{"content":"<h2 id=\"-history\">history</h2><p>When using <code>history</code>, Ember uses the browser’s\n<a href=\"http://caniuse.com/history\">history</a> API to produce URLs with a structure like\n<code>/posts/new</code>.</p><p>Given the following router, entering <code>/posts/new</code> will take you to the <code>posts.new</code>\nroute.</p><p>Keep in mind that your server must serve the Ember app from all the URLs defined in your\n<code>Router.map</code> function. In other words, if your user directly navigates to\n<code>/posts/new</code>, your server must be configured to serve your Ember app in\nresponse.</p>","link":"./A1/configuring-ember/specifying-url-type.html","spaLink":"#/A1/configuring-ember/specifying-url-type","title":"HISTORY"},{"content":"<h2 id=\"-hash\">hash</h2><p>The <code>hash</code> option uses the URL’s anchor to load the starting state of your\napplication and will keep it in sync as you move around. At present, this relies\non a <a href=\"http://caniuse.com/hashchange\">hashchange</a> event existing in the browser.</p><p>In the router example above, entering <code>/#/posts/new</code> will take you to the <code>posts.new</code>\nroute.</p>","link":"./A1/configuring-ember/specifying-url-type.html","spaLink":"#/A1/configuring-ember/specifying-url-type","title":"HASH"},{"content":"<h2 id=\"-none\">none</h2><p>Finally, if you don’t want the browser’s URL to interact with your application\nat all, you can disable the location API entirely by setting <code>ENV.locationType</code>\nto <code>none</code>. This is useful for\ntesting, or when you don’t want Ember to muck with the URL (for example when you embed your\napplication in a larger page).</p>","link":"./A1/configuring-ember/specifying-url-type.html","spaLink":"#/A1/configuring-ember/specifying-url-type","title":"NONE"},{"content":"<h3 id=\"-bug-fixes\">Bug Fixes</h3><p>Urgent bugfixes are bugfixes that need to be applied to the existing\nrelease branch. If possible, they should be made on master and prefixed\nwith [BUGFIX release].</p><p>Beta bugfixes are bugfixes that need to be applied to the beta branch.\nIf possible, they should be made on master and tagged with [BUGFIX\nbeta].</p><p>Security fixes need to be applied to the beta branch, the current\nrelease branch, and the previous tag. If possible, they should be made\non master and tagged with [SECURITY].</p>","link":"./A1/contributing/adding-new-features.html","spaLink":"#/A1/contributing/adding-new-features","title":"Bug Fixes"},{"content":"<h3 id=\"-features\">Features</h3><p>Features must always be wrapped in a feature flag. Tests for the feature\nmust also be wrapped in a feature flag.</p><p>Because the build-tools will process feature-flags, flags must use\nprecisely this format. We are choosing conditionals rather than a block\nform because functions change the surrounding scope and may introduce\nproblems with early return.</p><p>Tests will always run with all features on, so make sure that any tests\nfor the feature are passing against the current state of the feature.</p><p>Commits related to a specific feature should include  a prefix like\n[FEATURE htmlbars]. This will allow us to quickly identify all commits\nfor a specific feature in the future. Features will never be applied to\nbeta or release branches. Once a beta or release branch has been cut, it\ncontains all of the new features it will ever have.</p><p>If a feature has made it into beta or release, and you make a commit to\nmaster that fixes a bug in the feature, treat it like a bugfix as\ndescribed above.</p>","link":"./A1/contributing/adding-new-features.html","spaLink":"#/A1/contributing/adding-new-features","title":"Features"},{"content":"<h3 id=\"-builds\">Builds</h3><p>The Canary build, which is based off master, will include all features,\nguarded by the conditionals in the original source. This means that\nusers of the canary build can enable whatever features they want by\nenabling them before creating their Ember.Application.</p>","link":"./A1/contributing/adding-new-features.html","spaLink":"#/A1/contributing/adding-new-features","title":"Builds"},{"content":"<h3 id=\"-featuresjson\"><code>features.json</code></h3><p>The root of the repository will contain a features.json file, which will\ncontain a list of features that should be enabled for beta or release\nbuilds.</p><p>This file is populated when branching, and may not gain additional\nfeatures after the original branch. It may remove features.</p><p>The build process will remove any features not included in the list, and\nremove the conditionals for features in the list.</p>","link":"./A1/contributing/adding-new-features.html","spaLink":"#/A1/contributing/adding-new-features","title":"features.json"},{"content":"<h3 id=\"-travis-testing\">Travis Testing</h3><p>For a new PR:</p><p>For a new commit to master:</p><p>The idea is that new commits should be submitted as PRs to ensure they\napply cleanly, and once the merge button is pressed, Travis will apply\nthem to the right branches.</p>","link":"./A1/contributing/adding-new-features.html","spaLink":"#/A1/contributing/adding-new-features","title":"Travis Testing"},{"content":"<h3 id=\"-gono-go-process\">Go/No-Go Process</h3><p>Every six weeks, the core team goes through the following process.</p><p>All remaining features on the beta branch are vetted for readiness. If\nany feature isn’t ready, it is removed from features.json.</p><p>Once this is done, the beta branch is tagged and merged into release.</p><p>All features on the master branch are vetted for readiness. In order for\na feature to be considered “ready” at this stage, it must be ready as-is\nwith no blockers. Features are a no-go even if they are close and\nadditional work on the beta branch would make it ready.</p><p>Because this process happens every six weeks, there will be another\nopportunity for a feature to make it soon enough.</p><p>Once this is done, the master branch is merged into beta. A\n<code>features.json</code> file is added with the features that are ready.</p>","link":"./A1/contributing/adding-new-features.html","spaLink":"#/A1/contributing/adding-new-features","title":"Go/No-Go Process"},{"content":"<h3 id=\"-beta-releases\">Beta Releases</h3><p>Every week, we repeat the Go/No-Go process for the features that remain\non the beta branch. Any feature that has become unready is removed from\nthe features.json.</p><p>Once this is done, a Beta release is tagged and pushed.</p>","link":"./A1/contributing/adding-new-features.html","spaLink":"#/A1/contributing/adding-new-features","title":"Beta Releases"},{"content":"<h1 id=\"main-repositories\">Main Repositories</h1><p><strong>Ember.js</strong> - The main repository for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/ember.js\"></a><a href=\"https://github.com/emberjs/ember.js\">https://github.com/emberjs/ember.js</a></li>\n</ul><p><strong>Ember Data</strong> - A data persistence library for Ember.</p><ul>\n<li><a href=\"https://github.com/emberjs/data\"></a><a href=\"https://github.com/emberjs/data\">https://github.com/emberjs/data</a></li>\n</ul><p><strong>Ember Website</strong> - Source for <a href=\"http://emberjs.com\"></a><a href=\"http://emberjs.com\">http://emberjs.com</a></p><ul>\n<li><a href=\"https://github.com/emberjs/website\"></a><a href=\"https://github.com/emberjs/website\">https://github.com/emberjs/website</a></li>\n</ul><p><strong>Ember Guides</strong> - Source for <a href=\"http://guides.emberjs.com\"></a><a href=\"http://guides.emberjs.com\">http://guides.emberjs.com</a> which you are currently reading.</p><ul>\n<li><a href=\"https://github.com/emberjs/guides\"></a><a href=\"https://github.com/emberjs/guides\">https://github.com/emberjs/guides</a></li>\n</ul>","link":"./A1/contributing/repositories.html","spaLink":"#/A1/contributing/repositories","title":"MAIN REPOSITORIES"},{"content":"<h1 id=\"libraries-used-by-ember\">Libraries Used By Ember</h1><p>These libraries are part of the Ember.js source, but development of them takes place in a separate repository.</p>","link":"./A1/contributing/repositories.html","spaLink":"#/A1/contributing/repositories","title":"LIBRARIES USED BY EMBER"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-metallibvendorbackburnerjs\"><code>packages/ember-metal/lib/vendor/backburner.js</code></h2><ul>\n<li><strong>backburner.js</strong> - Implements the Ember run loop.</li>\n<li><a href=\"https://github.com/ebryn/backburner.js\"></a><a href=\"https://github.com/ebryn/backburner.js\">https://github.com/ebryn/backburner.js</a></li>\n</ul>","link":"./A1/contributing/repositories.html","spaLink":"#/A1/contributing/repositories","title":"PACKAGES/EMBER-METAL/LIB/VENDOR/BACKBURNER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorroute-recognizerjs\"><code>packages/ember-routing/lib/vendor/route-recognizer.js</code></h2><ul>\n<li><strong>route-recognizer.js</strong> - A lightweight JavaScript library that matches paths against registered routes.</li>\n<li><a href=\"https://github.com/tildeio/route-recognizer\"></a><a href=\"https://github.com/tildeio/route-recognizer\">https://github.com/tildeio/route-recognizer</a></li>\n</ul>","link":"./A1/contributing/repositories.html","spaLink":"#/A1/contributing/repositories","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTE-RECOGNIZER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesember-routinglibvendorrouterjs\"><code>packages/ember-routing/lib/vendor/router.js</code></h2><ul>\n<li><strong>router.js</strong> - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.</li>\n<li><a href=\"https://github.com/tildeio/router.js\"></a><a href=\"https://github.com/tildeio/router.js\">https://github.com/tildeio/router.js</a></li>\n</ul>","link":"./A1/contributing/repositories.html","spaLink":"#/A1/contributing/repositories","title":"PACKAGES/EMBER-ROUTING/LIB/VENDOR/ROUTER.JS"},{"content":"<h2 id=\"libraries-used-by-ember-packagesmetamorph\"><code>packages/metamorph</code></h2><ul>\n<li><strong>Metamorph.js</strong> - Used by Ember for databinding handlebars templates</li>\n<li><a href=\"https://github.com/tomhuda/metamorph.js\"></a><a href=\"https://github.com/tomhuda/metamorph.js\">https://github.com/tomhuda/metamorph.js</a></li>\n</ul>","link":"./A1/contributing/repositories.html","spaLink":"#/A1/contributing/repositories","title":"PACKAGES/METAMORPH"},{"content":"<h2 id=\"libraries-used-by-ember-packagesrsvp\"><code>packages/rsvp</code></h2><ul>\n<li><strong>RSVP.js</strong> - Implementation of the of Promises/A+ spec used by Ember.</li>\n<li><a href=\"https://github.com/tildeio/rsvp.js\"></a><a href=\"https://github.com/tildeio/rsvp.js\">https://github.com/tildeio/rsvp.js</a></li>\n</ul>","link":"./A1/contributing/repositories.html","spaLink":"#/A1/contributing/repositories","title":"PACKAGES/RSVP"},{"content":"<h2 id=\"-factory-registrations\">Factory Registrations</h2><p>A factory can represent any part of your application, like a <em>route</em>, <em>template</em>, or custom class. Every factory is registered with a particular key. For example, the index template is registered with the key <code>template:index</code>, and the application route is registered with the key <code>route:application</code>.</p><p>Registration keys have two segments split by a colon (<code>:</code>). The first segment is the framework factory type, and the second is the name of the particular factory. Hence, the <code>index</code> template has the key <code>template:index</code>. Ember has several built-in factory types, such as <code>service</code>, <code>route</code>, <code>template</code>, and <code>component</code>.</p><p>You can create your own factory type by simply registering a factory with the new type. For example, to create a <code>user</code> type, you’d simply register your factory with <code>application.register('user:user-to-register')</code>.</p><p>Factory registrations must be performed either in application or application instance initializers (with the former being much more common).</p><p>For example, an application initializer could register a <code>Logger</code> factory with the key <code>logger:main</code>:</p><p>```app/initializers/logger.js export function initialize(application) { var Logger = Ember.Object.extend({ log(m) { console.log(m); } });</p><p>application.register(‘logger:main’, Logger); }</p><p>export default { name: ‘logger’, initialize: initialize };</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"FACTORY REGISTRATIONS"},{"content":"<h3 id=\"-factory-registrations-registering-singletons-vs-non-singletons\">Registering Singletons vs. Non-Singletons</h3><p>By default, registrations are treated as “singletons”. This simply means that an instance will be created when it is first looked up, and this same instance will be cached and returned from subsequent lookups.</p><p>When you want fresh objects to be created for every lookup, register your factories as non-singletons using the <code>singleton: false</code> option.</p><p>In the following example, the <code>Message</code> class is registered as a non-singleton:</p><p>```app/initializers/notification.js export function initialize(application) { var Message = Ember.Object.extend({ text: ‘’ });</p><p>application.register(‘notification:message’, Message, { singleton: false }); }</p><p>export default { name: ‘notification’, initialize: initialize };</p><p>As a result of this type injection, all factories of the type <code>route</code> will be instantiated with the property <code>logger</code> injected. The value of <code>logger</code> will come from the factory named <code>logger:main</code>.</p><p>Routes in this example application can now access the injected logger:</p><p>```app/routes/index.js export default Ember.Route.extend({ activate() { // The logger property is injected into all routes this.get(‘logger’).log(‘Entered the index route!’); } });</p><p>In this case, the logger will only be injected on the index route.</p><p>Injections can be made onto any class that requires instantiation. This includes all of Ember’s major framework classes, such as components, helpers, routes, and the router.</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"Registering Singletons vs. Non-Singletons"},{"content":"<h3 id=\"-factory-registrations-ad-hoc-injections\">Ad Hoc Injections</h3><p>Dependency injections can also be declared directly on Ember classes using <code>Ember.inject</code>. Currently, <code>Ember.inject</code> supports injecting controllers (via <code>Ember.inject.controller</code>) and services (via <code>Ember.inject.service</code>).</p><p>The following code injects the <code>shopping-cart</code> service on the <code>cart-contents</code> component as the property <code>cart</code>:</p><p>```app/components/cart-contents.js export default Ember.Component.extend({ cart: Ember.inject.service(‘shopping-cart’) });</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"Ad Hoc Injections"},{"content":"<h2 id=\"-factory-instance-lookups\">Factory Instance Lookups</h2><p>To fetch an instantiated factory from the running application you can call the <a href=\"http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup\"><code>lookup</code></a> method on an application instance. This method takes a string to identify a factory and returns the appropriate object.</p><p>The application instance is passed to Ember’s instance initializer hooks and it is added as the “owner” of each object that was instantiated by the application instance.</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"FACTORY INSTANCE LOOKUPS"},{"content":"<h3 id=\"-factory-instance-lookups-using-an-application-instance-within-an-instance-initializer\">Using an Application Instance Within an Instance Initializer</h3><p>Instance initializers receive an application instance as an argument, providing an opportunity to look up an instance of a registered factory.</p><p>```app/instance-initializers/logger.js export function initialize(applicationInstance) { let logger = applicationInstance.lookup(‘logger:main’);</p><p>logger.log(‘Hello from the instance initializer!’); }</p><p>export default { name: ‘logger’, initialize: initialize };</p>","link":"./BR/applications/dependency-injection.pt-BR.html","spaLink":"#/BR/applications/dependency-injection.pt-BR","title":"Using an Application Instance Within an Instance Initializer"},{"content":"<h2 id=\"-application-initializers\">Application Initializers</h2><p>Application initializers can be created with Ember CLI’s <code>initializer</code> generator:</p><p>Let’s customize the <code>shopping-cart</code> initializer to inject a <code>cart</code> property into all the routes in your application:</p><p>```app/initializers/shopping-cart.js export function initialize(application) { application.inject(‘route’, ‘cart’, ‘service:shopping-cart’); };</p><p>export default { name: ‘shopping-cart’, initialize: initialize };</p><p>Let’s add some simple logging to indicate that the instance has booted:</p><p>```app/instance-initializers/logger.js export function initialize(applicationInstance) { var logger = applicationInstance.lookup(‘logger:main’); logger.log(‘Hello from the instance initializer!’); }</p><p>export default { name: ‘logger’, initialize: initialize };</p><p>```app/initializers/websocket-init.js export function initialize(application) { // … your code … };</p><p>export default { name: ‘websocketInit’, after: ‘configReader’, initialize: initialize }; ```</p><p>Note that ordering only applies to initializers of the same type (i.e. application or application instance). Application initializers will always run before application instance initializers.</p>","link":"./BR/applications/initializers.pt-BR.html","spaLink":"#/BR/applications/initializers.pt-BR","title":"APPLICATION INITIALIZERS"},{"content":"<h2 id=\"-why-is-the-run-loop-useful\">Why is the run loop useful?</h2><p>Very often, batching similar work has benefits. Web browsers do something quite similar by batching changes to the DOM.</p><p>Consider the following HTML snippet:</p><p>and executing the following code:</p><p>In this example, the sequence of code forced the browser to recalculate style, and relayout after each step. However, if we were able to batch similar jobs together, the browser would have only needed to recalculate the style and layout once.</p><p>Interestingly, this pattern holds true for many other types of work. Essentially, batching similar work allows for better pipelining, and further optimization.</p><p>Let’s look at a similar example that is optimized in Ember, starting with a <code>User</code> object:</p><p>and a template to display its attributes:</p><p>If we execute the following code without the run loop:</p><p>We see that the browser will rerender the template twice.</p><p>However, if we have the run loop in the above code, the browser will only rerender the template once the attributes have all been set.</p><p>In the above example with the run loop, since the user’s attributes end up at the same values as before execution, the template will not even rerender!</p><p>It is of course possible to optimize these scenarios on a case-by-case basis, but getting them for free is much nicer. Using the run loop, we can apply these classes of optimizations not only for each scenario, but holistically app-wide.</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"WHY IS THE RUN LOOP USEFUL?"},{"content":"<h2 id=\"-how-does-the-run-loop-work-in-ember\">How does the Run Loop work in Ember?</h2><p>As mentioned earlier, we schedule work (in the form of function invocations) on queues, and these queues are processed to completion in priority order.</p><p>What are the queues, and what is their priority order?</p><p>Because the priority is first to last, the “sync” queue has higher priority than the “render” or “destroy” queue.</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"HOW DOES THE RUN LOOP WORK IN EMBER?"},{"content":"<h2 id=\"-what-happens-in-these-queues\">What happens in these queues?</h2><ul>\n<li>The <code>sync</code> queue contains binding synchronization jobs.</li>\n<li>The <code>actions</code> queue is the general work queue and will typically contain scheduled tasks e.g. promises.</li>\n<li>The <code>routerTransitions</code> queue contains transition jobs in the router.</li>\n<li>The <code>render</code> queue contains jobs meant for rendering, these will typically update the DOM.</li>\n<li>The <code>afterRender</code> queue contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated.</li>\n<li>The <code>destroy</code> queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.</li>\n</ul>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"WHAT HAPPENS IN THESE QUEUES?"},{"content":"<h2 id=\"-in-what-order-are-jobs-executed-on-the-queues\">In what order are jobs executed on the queues?</h2><p>The algorithm works this way:</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"IN WHAT ORDER ARE JOBS EXECUTED ON THE QUEUES?"},{"content":"<h2 id=\"-an-example-of-the-internals\">An example of the internals</h2><p>Rather than writing the higher level app code that internally invokes the various run loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.</p><p>Working with this API directly is not common in most Ember apps, but understanding this example will help you to understand the run-loops algorithm, which will make you a better Ember developer. <iframe src=\"https://s3.amazonaws.com/emberjs.com/run-loop-guide/index.html\" width=\"678\" height=\"410\" style=\"border:1px solid rgb(170, 170, 170);margin-bottom:1.5em;\"></iframe></p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"AN EXAMPLE OF THE INTERNALS"},{"content":"<h2 id=\"-how-do-i-tell-ember-to-start-a-run-loop\">How do I tell Ember to start a run loop?</h2><p>You should begin a run loop when the callback fires.</p><p>The <code>Ember.run</code> method can be used to create a runloop. In this example, jQuery and <code>Ember.run</code> are used to handle a click event and run some Ember code.</p><p>This example uses the <code>=&gt;</code> function syntax, which is a [new ES2015 syntax for callback functions] (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>) that provides a lexical <code>this</code>. If this syntax is new, think of it as a function that has the same <code>this</code> as the context it is defined in.</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"HOW DO I TELL EMBER TO START A RUN LOOP?"},{"content":"<h2 id=\"-what-happens-if-i-forget-to-start-a-run-loop-in-an-async-handler\">What happens if I forget to start a run loop in an async handler?</h2><p>As mentioned above, you should wrap any non-Ember async callbacks in <code>Ember.run</code>. If you don’t, Ember will try to approximate a beginning and end for you. Consider the following callback:</p><p>The runloop API calls that <em>schedule</em> work i.e. <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_schedule\"><code>run.schedule</code></a>, <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce\"><code>run.scheduleOnce</code></a>, <a href=\"http://emberjs.com/api/classes/Ember.run.html#method_once\"><code>run.once</code></a> have the property that they will approximate a runloop for you if one does not already exist. These automatically created runloops we call <em>autoruns</em>.</p><p>Here is some pseudocode to describe what happens using the example above:</p><p>Although autoruns are convenient, they are suboptimal. The current JS frame is allowed to end before the run loop is flushed, which sometimes means the browser will take the opportunity to do other things, like garbage collection. GC running in between data changing and DOM rerendering can cause visual lag and should be minimized.</p><p>Relying on autoruns is not a rigorous or efficient way to use the runloop. Wrapping event handlers manually is preferred.</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"WHAT HAPPENS IF I FORGET TO START A RUN LOOP IN AN ASYNC HANDLER?"},{"content":"<h2 id=\"-how-is-runloop-behaviour-different-when-testing\">How is runloop behaviour different when testing?</h2><p>When your application is in <em>testing mode</em> then Ember will throw an error if you try to schedule work without an available runloop.</p><p>Autoruns are disabled in testing for several reasons:</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"HOW IS RUNLOOP BEHAVIOUR DIFFERENT WHEN TESTING?"},{"content":"<h2 id=\"-where-can-i-find-more-information\">Where can I find more information?</h2><p>Check out the <a href=\"http://emberjs.com/api/classes/Ember.run.html\">Ember.run</a> API documentation, as well as the <a href=\"https://github.com/ebryn/backburner.js/\">Backburner library</a> that powers the run loop.</p>","link":"./BR/applications/run-loop.pt-BR.html","spaLink":"#/BR/applications/run-loop.pt-BR","title":"WHERE CAN I FIND MORE INFORMATION?"}]